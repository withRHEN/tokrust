// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `data.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:TikTok.Common)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Common {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Common.method)
    pub method: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Common.msgId)
    pub msgId: i64,
    // @@protoc_insertion_point(field:TikTok.Common.roomId)
    pub roomId: i64,
    // @@protoc_insertion_point(field:TikTok.Common.createTime)
    pub createTime: i64,
    // @@protoc_insertion_point(field:TikTok.Common.monitor)
    pub monitor: i32,
    // @@protoc_insertion_point(field:TikTok.Common.isShowMsg)
    pub isShowMsg: bool,
    // @@protoc_insertion_point(field:TikTok.Common.describe)
    pub describe: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Common.displayText)
    pub displayText: ::protobuf::MessageField<Text>,
    // @@protoc_insertion_point(field:TikTok.Common.foldType)
    pub foldType: i64,
    // @@protoc_insertion_point(field:TikTok.Common.anchorFoldType)
    pub anchorFoldType: i64,
    // @@protoc_insertion_point(field:TikTok.Common.priorityScore)
    pub priorityScore: i64,
    // @@protoc_insertion_point(field:TikTok.Common.logId)
    pub logId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Common.msgProcessFilterK)
    pub msgProcessFilterK: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Common.msgProcessFilterV)
    pub msgProcessFilterV: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Common.fromIdc)
    pub fromIdc: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Common.toIdc)
    pub toIdc: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Common.filterMsgTagsList)
    pub filterMsgTagsList: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:TikTok.Common.sei)
    pub sei: ::protobuf::MessageField<common::LiveMessageSEI>,
    // @@protoc_insertion_point(field:TikTok.Common.dependRootId)
    pub dependRootId: ::protobuf::MessageField<common::LiveMessageID>,
    // @@protoc_insertion_point(field:TikTok.Common.dependId)
    pub dependId: ::protobuf::MessageField<common::LiveMessageID>,
    // @@protoc_insertion_point(field:TikTok.Common.anchorPriorityScore)
    pub anchorPriorityScore: i64,
    // @@protoc_insertion_point(field:TikTok.Common.roomMessageHeatLevel)
    pub roomMessageHeatLevel: i64,
    // @@protoc_insertion_point(field:TikTok.Common.foldTypeForWeb)
    pub foldTypeForWeb: i64,
    // @@protoc_insertion_point(field:TikTok.Common.anchorFoldTypeForWeb)
    pub anchorFoldTypeForWeb: i64,
    // @@protoc_insertion_point(field:TikTok.Common.clientSendTime)
    pub clientSendTime: i64,
    // @@protoc_insertion_point(field:TikTok.Common.dispatchStrategy)
    pub dispatchStrategy: ::protobuf::EnumOrUnknown<common::IMDispatchStrategy>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Common.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Common {
    fn default() -> &'a Common {
        <Common as ::protobuf::Message>::default_instance()
    }
}

impl Common {
    pub fn new() -> Common {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "method",
            |m: &Common| { &m.method },
            |m: &mut Common| { &mut m.method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msgId",
            |m: &Common| { &m.msgId },
            |m: &mut Common| { &mut m.msgId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomId",
            |m: &Common| { &m.roomId },
            |m: &mut Common| { &mut m.roomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createTime",
            |m: &Common| { &m.createTime },
            |m: &mut Common| { &mut m.createTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "monitor",
            |m: &Common| { &m.monitor },
            |m: &mut Common| { &mut m.monitor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isShowMsg",
            |m: &Common| { &m.isShowMsg },
            |m: &mut Common| { &mut m.isShowMsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "describe",
            |m: &Common| { &m.describe },
            |m: &mut Common| { &mut m.describe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Text>(
            "displayText",
            |m: &Common| { &m.displayText },
            |m: &mut Common| { &mut m.displayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "foldType",
            |m: &Common| { &m.foldType },
            |m: &mut Common| { &mut m.foldType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "anchorFoldType",
            |m: &Common| { &m.anchorFoldType },
            |m: &mut Common| { &mut m.anchorFoldType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "priorityScore",
            |m: &Common| { &m.priorityScore },
            |m: &mut Common| { &mut m.priorityScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logId",
            |m: &Common| { &m.logId },
            |m: &mut Common| { &mut m.logId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msgProcessFilterK",
            |m: &Common| { &m.msgProcessFilterK },
            |m: &mut Common| { &mut m.msgProcessFilterK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msgProcessFilterV",
            |m: &Common| { &m.msgProcessFilterV },
            |m: &mut Common| { &mut m.msgProcessFilterV },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromIdc",
            |m: &Common| { &m.fromIdc },
            |m: &mut Common| { &mut m.fromIdc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toIdc",
            |m: &Common| { &m.toIdc },
            |m: &mut Common| { &mut m.toIdc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filterMsgTagsList",
            |m: &Common| { &m.filterMsgTagsList },
            |m: &mut Common| { &mut m.filterMsgTagsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, common::LiveMessageSEI>(
            "sei",
            |m: &Common| { &m.sei },
            |m: &mut Common| { &mut m.sei },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, common::LiveMessageID>(
            "dependRootId",
            |m: &Common| { &m.dependRootId },
            |m: &mut Common| { &mut m.dependRootId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, common::LiveMessageID>(
            "dependId",
            |m: &Common| { &m.dependId },
            |m: &mut Common| { &mut m.dependId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "anchorPriorityScore",
            |m: &Common| { &m.anchorPriorityScore },
            |m: &mut Common| { &mut m.anchorPriorityScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomMessageHeatLevel",
            |m: &Common| { &m.roomMessageHeatLevel },
            |m: &mut Common| { &mut m.roomMessageHeatLevel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "foldTypeForWeb",
            |m: &Common| { &m.foldTypeForWeb },
            |m: &mut Common| { &mut m.foldTypeForWeb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "anchorFoldTypeForWeb",
            |m: &Common| { &m.anchorFoldTypeForWeb },
            |m: &mut Common| { &mut m.anchorFoldTypeForWeb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clientSendTime",
            |m: &Common| { &m.clientSendTime },
            |m: &mut Common| { &mut m.clientSendTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dispatchStrategy",
            |m: &Common| { &m.dispatchStrategy },
            |m: &mut Common| { &mut m.dispatchStrategy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Common>(
            "Common",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Common {
    const NAME: &'static str = "Common";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method = is.read_string()?;
                },
                16 => {
                    self.msgId = is.read_int64()?;
                },
                24 => {
                    self.roomId = is.read_int64()?;
                },
                32 => {
                    self.createTime = is.read_int64()?;
                },
                40 => {
                    self.monitor = is.read_int32()?;
                },
                48 => {
                    self.isShowMsg = is.read_bool()?;
                },
                58 => {
                    self.describe = is.read_string()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                },
                72 => {
                    self.foldType = is.read_int64()?;
                },
                80 => {
                    self.anchorFoldType = is.read_int64()?;
                },
                88 => {
                    self.priorityScore = is.read_int64()?;
                },
                98 => {
                    self.logId = is.read_string()?;
                },
                106 => {
                    self.msgProcessFilterK = is.read_string()?;
                },
                114 => {
                    self.msgProcessFilterV = is.read_string()?;
                },
                122 => {
                    self.fromIdc = is.read_string()?;
                },
                130 => {
                    self.toIdc = is.read_string()?;
                },
                138 => {
                    self.filterMsgTagsList.push(is.read_string()?);
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sei)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dependRootId)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dependId)?;
                },
                168 => {
                    self.anchorPriorityScore = is.read_int64()?;
                },
                176 => {
                    self.roomMessageHeatLevel = is.read_int64()?;
                },
                184 => {
                    self.foldTypeForWeb = is.read_int64()?;
                },
                192 => {
                    self.anchorFoldTypeForWeb = is.read_int64()?;
                },
                200 => {
                    self.clientSendTime = is.read_int64()?;
                },
                208 => {
                    self.dispatchStrategy = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.method);
        }
        if self.msgId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.msgId);
        }
        if self.roomId != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.roomId);
        }
        if self.createTime != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.createTime);
        }
        if self.monitor != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.monitor);
        }
        if self.isShowMsg != false {
            my_size += 1 + 1;
        }
        if !self.describe.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.describe);
        }
        if let Some(v) = self.displayText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.foldType != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.foldType);
        }
        if self.anchorFoldType != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.anchorFoldType);
        }
        if self.priorityScore != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.priorityScore);
        }
        if !self.logId.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.logId);
        }
        if !self.msgProcessFilterK.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.msgProcessFilterK);
        }
        if !self.msgProcessFilterV.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.msgProcessFilterV);
        }
        if !self.fromIdc.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.fromIdc);
        }
        if !self.toIdc.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.toIdc);
        }
        for value in &self.filterMsgTagsList {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        if let Some(v) = self.sei.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dependRootId.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dependId.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.anchorPriorityScore != 0 {
            my_size += ::protobuf::rt::int64_size(21, self.anchorPriorityScore);
        }
        if self.roomMessageHeatLevel != 0 {
            my_size += ::protobuf::rt::int64_size(22, self.roomMessageHeatLevel);
        }
        if self.foldTypeForWeb != 0 {
            my_size += ::protobuf::rt::int64_size(23, self.foldTypeForWeb);
        }
        if self.anchorFoldTypeForWeb != 0 {
            my_size += ::protobuf::rt::int64_size(24, self.anchorFoldTypeForWeb);
        }
        if self.clientSendTime != 0 {
            my_size += ::protobuf::rt::int64_size(25, self.clientSendTime);
        }
        if self.dispatchStrategy != ::protobuf::EnumOrUnknown::new(common::IMDispatchStrategy::IM_DISPATCH_STRATEGY_DEFAULT) {
            my_size += ::protobuf::rt::int32_size(26, self.dispatchStrategy.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.method.is_empty() {
            os.write_string(1, &self.method)?;
        }
        if self.msgId != 0 {
            os.write_int64(2, self.msgId)?;
        }
        if self.roomId != 0 {
            os.write_int64(3, self.roomId)?;
        }
        if self.createTime != 0 {
            os.write_int64(4, self.createTime)?;
        }
        if self.monitor != 0 {
            os.write_int32(5, self.monitor)?;
        }
        if self.isShowMsg != false {
            os.write_bool(6, self.isShowMsg)?;
        }
        if !self.describe.is_empty() {
            os.write_string(7, &self.describe)?;
        }
        if let Some(v) = self.displayText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.foldType != 0 {
            os.write_int64(9, self.foldType)?;
        }
        if self.anchorFoldType != 0 {
            os.write_int64(10, self.anchorFoldType)?;
        }
        if self.priorityScore != 0 {
            os.write_int64(11, self.priorityScore)?;
        }
        if !self.logId.is_empty() {
            os.write_string(12, &self.logId)?;
        }
        if !self.msgProcessFilterK.is_empty() {
            os.write_string(13, &self.msgProcessFilterK)?;
        }
        if !self.msgProcessFilterV.is_empty() {
            os.write_string(14, &self.msgProcessFilterV)?;
        }
        if !self.fromIdc.is_empty() {
            os.write_string(15, &self.fromIdc)?;
        }
        if !self.toIdc.is_empty() {
            os.write_string(16, &self.toIdc)?;
        }
        for v in &self.filterMsgTagsList {
            os.write_string(17, &v)?;
        };
        if let Some(v) = self.sei.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.dependRootId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.dependId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if self.anchorPriorityScore != 0 {
            os.write_int64(21, self.anchorPriorityScore)?;
        }
        if self.roomMessageHeatLevel != 0 {
            os.write_int64(22, self.roomMessageHeatLevel)?;
        }
        if self.foldTypeForWeb != 0 {
            os.write_int64(23, self.foldTypeForWeb)?;
        }
        if self.anchorFoldTypeForWeb != 0 {
            os.write_int64(24, self.anchorFoldTypeForWeb)?;
        }
        if self.clientSendTime != 0 {
            os.write_int64(25, self.clientSendTime)?;
        }
        if self.dispatchStrategy != ::protobuf::EnumOrUnknown::new(common::IMDispatchStrategy::IM_DISPATCH_STRATEGY_DEFAULT) {
            os.write_enum(26, ::protobuf::EnumOrUnknown::value(&self.dispatchStrategy))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Common {
        Common::new()
    }

    fn clear(&mut self) {
        self.method.clear();
        self.msgId = 0;
        self.roomId = 0;
        self.createTime = 0;
        self.monitor = 0;
        self.isShowMsg = false;
        self.describe.clear();
        self.displayText.clear();
        self.foldType = 0;
        self.anchorFoldType = 0;
        self.priorityScore = 0;
        self.logId.clear();
        self.msgProcessFilterK.clear();
        self.msgProcessFilterV.clear();
        self.fromIdc.clear();
        self.toIdc.clear();
        self.filterMsgTagsList.clear();
        self.sei.clear();
        self.dependRootId.clear();
        self.dependId.clear();
        self.anchorPriorityScore = 0;
        self.roomMessageHeatLevel = 0;
        self.foldTypeForWeb = 0;
        self.anchorFoldTypeForWeb = 0;
        self.clientSendTime = 0;
        self.dispatchStrategy = ::protobuf::EnumOrUnknown::new(common::IMDispatchStrategy::IM_DISPATCH_STRATEGY_DEFAULT);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Common {
        static instance: Common = Common {
            method: ::std::string::String::new(),
            msgId: 0,
            roomId: 0,
            createTime: 0,
            monitor: 0,
            isShowMsg: false,
            describe: ::std::string::String::new(),
            displayText: ::protobuf::MessageField::none(),
            foldType: 0,
            anchorFoldType: 0,
            priorityScore: 0,
            logId: ::std::string::String::new(),
            msgProcessFilterK: ::std::string::String::new(),
            msgProcessFilterV: ::std::string::String::new(),
            fromIdc: ::std::string::String::new(),
            toIdc: ::std::string::String::new(),
            filterMsgTagsList: ::std::vec::Vec::new(),
            sei: ::protobuf::MessageField::none(),
            dependRootId: ::protobuf::MessageField::none(),
            dependId: ::protobuf::MessageField::none(),
            anchorPriorityScore: 0,
            roomMessageHeatLevel: 0,
            foldTypeForWeb: 0,
            anchorFoldTypeForWeb: 0,
            clientSendTime: 0,
            dispatchStrategy: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Common {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Common").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Common {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Common {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Common`
pub mod common {
    // @@protoc_insertion_point(message:TikTok.Common.LiveMessageSEI)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LiveMessageSEI {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Common.LiveMessageSEI.uniqueId)
        pub uniqueId: ::protobuf::MessageField<LiveMessageID>,
        // @@protoc_insertion_point(field:TikTok.Common.LiveMessageSEI.timestamp)
        pub timestamp: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Common.LiveMessageSEI.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LiveMessageSEI {
        fn default() -> &'a LiveMessageSEI {
            <LiveMessageSEI as ::protobuf::Message>::default_instance()
        }
    }

    impl LiveMessageSEI {
        pub fn new() -> LiveMessageSEI {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LiveMessageID>(
                "uniqueId",
                |m: &LiveMessageSEI| { &m.uniqueId },
                |m: &mut LiveMessageSEI| { &mut m.uniqueId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timestamp",
                |m: &LiveMessageSEI| { &m.timestamp },
                |m: &mut LiveMessageSEI| { &mut m.timestamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveMessageSEI>(
                "Common.LiveMessageSEI",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LiveMessageSEI {
        const NAME: &'static str = "LiveMessageSEI";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.uniqueId)?;
                    },
                    16 => {
                        self.timestamp = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.uniqueId.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.timestamp);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.uniqueId.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.timestamp != 0 {
                os.write_int64(2, self.timestamp)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LiveMessageSEI {
            LiveMessageSEI::new()
        }

        fn clear(&mut self) {
            self.uniqueId.clear();
            self.timestamp = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LiveMessageSEI {
            static instance: LiveMessageSEI = LiveMessageSEI {
                uniqueId: ::protobuf::MessageField::none(),
                timestamp: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LiveMessageSEI {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Common.LiveMessageSEI").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LiveMessageSEI {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiveMessageSEI {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.Common.LiveMessageID)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LiveMessageID {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Common.LiveMessageID.primaryId)
        pub primaryId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.Common.LiveMessageID.messageScene)
        pub messageScene: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Common.LiveMessageID.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LiveMessageID {
        fn default() -> &'a LiveMessageID {
            <LiveMessageID as ::protobuf::Message>::default_instance()
        }
    }

    impl LiveMessageID {
        pub fn new() -> LiveMessageID {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "primaryId",
                |m: &LiveMessageID| { &m.primaryId },
                |m: &mut LiveMessageID| { &mut m.primaryId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "messageScene",
                |m: &LiveMessageID| { &m.messageScene },
                |m: &mut LiveMessageID| { &mut m.messageScene },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveMessageID>(
                "Common.LiveMessageID",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LiveMessageID {
        const NAME: &'static str = "LiveMessageID";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.primaryId = is.read_string()?;
                    },
                    18 => {
                        self.messageScene = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.primaryId.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.primaryId);
            }
            if !self.messageScene.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.messageScene);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.primaryId.is_empty() {
                os.write_string(1, &self.primaryId)?;
            }
            if !self.messageScene.is_empty() {
                os.write_string(2, &self.messageScene)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LiveMessageID {
            LiveMessageID::new()
        }

        fn clear(&mut self) {
            self.primaryId.clear();
            self.messageScene.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LiveMessageID {
            static instance: LiveMessageID = LiveMessageID {
                primaryId: ::std::string::String::new(),
                messageScene: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LiveMessageID {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Common.LiveMessageID").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LiveMessageID {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiveMessageID {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TikTok.Common.IMDispatchStrategy)
    pub enum IMDispatchStrategy {
        // @@protoc_insertion_point(enum_value:TikTok.Common.IMDispatchStrategy.IM_DISPATCH_STRATEGY_DEFAULT)
        IM_DISPATCH_STRATEGY_DEFAULT = 0,
        // @@protoc_insertion_point(enum_value:TikTok.Common.IMDispatchStrategy.IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE)
        IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE = 1,
    }

    impl ::protobuf::Enum for IMDispatchStrategy {
        const NAME: &'static str = "IMDispatchStrategy";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<IMDispatchStrategy> {
            match value {
                0 => ::std::option::Option::Some(IMDispatchStrategy::IM_DISPATCH_STRATEGY_DEFAULT),
                1 => ::std::option::Option::Some(IMDispatchStrategy::IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<IMDispatchStrategy> {
            match str {
                "IM_DISPATCH_STRATEGY_DEFAULT" => ::std::option::Option::Some(IMDispatchStrategy::IM_DISPATCH_STRATEGY_DEFAULT),
                "IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE" => ::std::option::Option::Some(IMDispatchStrategy::IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [IMDispatchStrategy] = &[
            IMDispatchStrategy::IM_DISPATCH_STRATEGY_DEFAULT,
            IMDispatchStrategy::IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE,
        ];
    }

    impl ::protobuf::EnumFull for IMDispatchStrategy {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Common.IMDispatchStrategy").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for IMDispatchStrategy {
        fn default() -> Self {
            IMDispatchStrategy::IM_DISPATCH_STRATEGY_DEFAULT
        }
    }

    impl IMDispatchStrategy {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<IMDispatchStrategy>("Common.IMDispatchStrategy")
        }
    }
}

// @@protoc_insertion_point(message:TikTok.Text)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Text {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Text.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Text.defaultPattern)
    pub defaultPattern: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Text.defaultFormat)
    pub defaultFormat: ::protobuf::MessageField<text::TextFormat>,
    // @@protoc_insertion_point(field:TikTok.Text.piecesList)
    pub piecesList: ::std::vec::Vec<text::TextPiece>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Text.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Text {
    fn default() -> &'a Text {
        <Text as ::protobuf::Message>::default_instance()
    }
}

impl Text {
    pub fn new() -> Text {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Text| { &m.key },
            |m: &mut Text| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "defaultPattern",
            |m: &Text| { &m.defaultPattern },
            |m: &mut Text| { &mut m.defaultPattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, text::TextFormat>(
            "defaultFormat",
            |m: &Text| { &m.defaultFormat },
            |m: &mut Text| { &mut m.defaultFormat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "piecesList",
            |m: &Text| { &m.piecesList },
            |m: &mut Text| { &mut m.piecesList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Text>(
            "Text",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Text {
    const NAME: &'static str = "Text";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.defaultPattern = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.defaultFormat)?;
                },
                34 => {
                    self.piecesList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.defaultPattern.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.defaultPattern);
        }
        if let Some(v) = self.defaultFormat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.piecesList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.defaultPattern.is_empty() {
            os.write_string(2, &self.defaultPattern)?;
        }
        if let Some(v) = self.defaultFormat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.piecesList {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Text {
        Text::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.defaultPattern.clear();
        self.defaultFormat.clear();
        self.piecesList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Text {
        static instance: Text = Text {
            key: ::std::string::String::new(),
            defaultPattern: ::std::string::String::new(),
            defaultFormat: ::protobuf::MessageField::none(),
            piecesList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Text {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Text").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Text {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Text {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Text`
pub mod text {
    // @@protoc_insertion_point(message:TikTok.Text.TextPiece)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextPiece {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Text.TextPiece.type)
        pub type_: i32,
        // @@protoc_insertion_point(field:TikTok.Text.TextPiece.format)
        pub format: ::protobuf::MessageField<TextFormat>,
        // @@protoc_insertion_point(field:TikTok.Text.TextPiece.stringValue)
        pub stringValue: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.Text.TextPiece.patternRefValue)
        pub patternRefValue: ::protobuf::MessageField<TextPiecePatternRef>,
        // message oneof groups
        pub textPieceType: ::std::option::Option<text_piece::TextPieceType>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Text.TextPiece.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextPiece {
        fn default() -> &'a TextPiece {
            <TextPiece as ::protobuf::Message>::default_instance()
        }
    }

    impl TextPiece {
        pub fn new() -> TextPiece {
            ::std::default::Default::default()
        }

        // .TikTok.Text.TextPieceUser userValue = 21;

        pub fn userValue(&self) -> &TextPieceUser {
            match self.textPieceType {
                ::std::option::Option::Some(text_piece::TextPieceType::UserValue(ref v)) => v,
                _ => <TextPieceUser as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_userValue(&mut self) {
            self.textPieceType = ::std::option::Option::None;
        }

        pub fn has_userValue(&self) -> bool {
            match self.textPieceType {
                ::std::option::Option::Some(text_piece::TextPieceType::UserValue(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_userValue(&mut self, v: TextPieceUser) {
            self.textPieceType = ::std::option::Option::Some(text_piece::TextPieceType::UserValue(v))
        }

        // Mutable pointer to the field.
        pub fn mut_userValue(&mut self) -> &mut TextPieceUser {
            if let ::std::option::Option::Some(text_piece::TextPieceType::UserValue(_)) = self.textPieceType {
            } else {
                self.textPieceType = ::std::option::Option::Some(text_piece::TextPieceType::UserValue(TextPieceUser::new()));
            }
            match self.textPieceType {
                ::std::option::Option::Some(text_piece::TextPieceType::UserValue(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_userValue(&mut self) -> TextPieceUser {
            if self.has_userValue() {
                match self.textPieceType.take() {
                    ::std::option::Option::Some(text_piece::TextPieceType::UserValue(v)) => v,
                    _ => panic!(),
                }
            } else {
                TextPieceUser::new()
            }
        }

        // .TikTok.Text.TextPieceGift giftValue = 22;

        pub fn giftValue(&self) -> &TextPieceGift {
            match self.textPieceType {
                ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(ref v)) => v,
                _ => <TextPieceGift as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_giftValue(&mut self) {
            self.textPieceType = ::std::option::Option::None;
        }

        pub fn has_giftValue(&self) -> bool {
            match self.textPieceType {
                ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_giftValue(&mut self, v: TextPieceGift) {
            self.textPieceType = ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(v))
        }

        // Mutable pointer to the field.
        pub fn mut_giftValue(&mut self) -> &mut TextPieceGift {
            if let ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(_)) = self.textPieceType {
            } else {
                self.textPieceType = ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(TextPieceGift::new()));
            }
            match self.textPieceType {
                ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_giftValue(&mut self) -> TextPieceGift {
            if self.has_giftValue() {
                match self.textPieceType.take() {
                    ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(v)) => v,
                    _ => panic!(),
                }
            } else {
                TextPieceGift::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &TextPiece| { &m.type_ },
                |m: &mut TextPiece| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TextFormat>(
                "format",
                |m: &TextPiece| { &m.format },
                |m: &mut TextPiece| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "stringValue",
                |m: &TextPiece| { &m.stringValue },
                |m: &mut TextPiece| { &mut m.stringValue },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TextPieceUser>(
                "userValue",
                TextPiece::has_userValue,
                TextPiece::userValue,
                TextPiece::mut_userValue,
                TextPiece::set_userValue,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TextPieceGift>(
                "giftValue",
                TextPiece::has_giftValue,
                TextPiece::giftValue,
                TextPiece::mut_giftValue,
                TextPiece::set_giftValue,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TextPiecePatternRef>(
                "patternRefValue",
                |m: &TextPiece| { &m.patternRefValue },
                |m: &mut TextPiece| { &mut m.patternRefValue },
            ));
            oneofs.push(text_piece::TextPieceType::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextPiece>(
                "Text.TextPiece",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextPiece {
        const NAME: &'static str = "TextPiece";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = is.read_int32()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.format)?;
                    },
                    90 => {
                        self.stringValue = is.read_string()?;
                    },
                    170 => {
                        self.textPieceType = ::std::option::Option::Some(text_piece::TextPieceType::UserValue(is.read_message()?));
                    },
                    178 => {
                        self.textPieceType = ::std::option::Option::Some(text_piece::TextPieceType::GiftValue(is.read_message()?));
                    },
                    194 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.patternRefValue)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.type_ != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.type_);
            }
            if let Some(v) = self.format.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.stringValue.is_empty() {
                my_size += ::protobuf::rt::string_size(11, &self.stringValue);
            }
            if let Some(v) = self.patternRefValue.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let ::std::option::Option::Some(ref v) = self.textPieceType {
                match v {
                    &text_piece::TextPieceType::UserValue(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &text_piece::TextPieceType::GiftValue(ref v) => {
                        let len = v.compute_size();
                        my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.type_ != 0 {
                os.write_int32(1, self.type_)?;
            }
            if let Some(v) = self.format.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if !self.stringValue.is_empty() {
                os.write_string(11, &self.stringValue)?;
            }
            if let Some(v) = self.patternRefValue.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
            }
            if let ::std::option::Option::Some(ref v) = self.textPieceType {
                match v {
                    &text_piece::TextPieceType::UserValue(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                    },
                    &text_piece::TextPieceType::GiftValue(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextPiece {
            TextPiece::new()
        }

        fn clear(&mut self) {
            self.type_ = 0;
            self.format.clear();
            self.stringValue.clear();
            self.textPieceType = ::std::option::Option::None;
            self.textPieceType = ::std::option::Option::None;
            self.patternRefValue.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextPiece {
            static instance: TextPiece = TextPiece {
                type_: 0,
                format: ::protobuf::MessageField::none(),
                stringValue: ::std::string::String::new(),
                patternRefValue: ::protobuf::MessageField::none(),
                textPieceType: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextPiece {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Text.TextPiece").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextPiece {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextPiece {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TextPiece`
    pub mod text_piece {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:TikTok.Text.TextPiece.textPieceType)
        pub enum TextPieceType {
            // @@protoc_insertion_point(oneof_field:TikTok.Text.TextPiece.userValue)
            UserValue(super::TextPieceUser),
            // @@protoc_insertion_point(oneof_field:TikTok.Text.TextPiece.giftValue)
            GiftValue(super::TextPieceGift),
        }

        impl ::protobuf::Oneof for TextPieceType {
        }

        impl ::protobuf::OneofFull for TextPieceType {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::TextPiece as ::protobuf::MessageFull>::descriptor().oneof_by_name("textPieceType").unwrap()).clone()
            }
        }

        impl TextPieceType {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<TextPieceType>("textPieceType")
            }
        }
    }

    // @@protoc_insertion_point(message:TikTok.Text.TextFormat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextFormat {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.color)
        pub color: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.bold)
        pub bold: bool,
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.italic)
        pub italic: bool,
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.weight)
        pub weight: i32,
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.italicAngle)
        pub italicAngle: i32,
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.fontSize)
        pub fontSize: i32,
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.useHeighLightColor)
        pub useHeighLightColor: bool,
        // @@protoc_insertion_point(field:TikTok.Text.TextFormat.useRemoteClor)
        pub useRemoteClor: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Text.TextFormat.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextFormat {
        fn default() -> &'a TextFormat {
            <TextFormat as ::protobuf::Message>::default_instance()
        }
    }

    impl TextFormat {
        pub fn new() -> TextFormat {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "color",
                |m: &TextFormat| { &m.color },
                |m: &mut TextFormat| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "bold",
                |m: &TextFormat| { &m.bold },
                |m: &mut TextFormat| { &mut m.bold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "italic",
                |m: &TextFormat| { &m.italic },
                |m: &mut TextFormat| { &mut m.italic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "weight",
                |m: &TextFormat| { &m.weight },
                |m: &mut TextFormat| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "italicAngle",
                |m: &TextFormat| { &m.italicAngle },
                |m: &mut TextFormat| { &mut m.italicAngle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fontSize",
                |m: &TextFormat| { &m.fontSize },
                |m: &mut TextFormat| { &mut m.fontSize },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "useHeighLightColor",
                |m: &TextFormat| { &m.useHeighLightColor },
                |m: &mut TextFormat| { &mut m.useHeighLightColor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "useRemoteClor",
                |m: &TextFormat| { &m.useRemoteClor },
                |m: &mut TextFormat| { &mut m.useRemoteClor },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextFormat>(
                "Text.TextFormat",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextFormat {
        const NAME: &'static str = "TextFormat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.color = is.read_string()?;
                    },
                    16 => {
                        self.bold = is.read_bool()?;
                    },
                    24 => {
                        self.italic = is.read_bool()?;
                    },
                    32 => {
                        self.weight = is.read_int32()?;
                    },
                    40 => {
                        self.italicAngle = is.read_int32()?;
                    },
                    48 => {
                        self.fontSize = is.read_int32()?;
                    },
                    56 => {
                        self.useHeighLightColor = is.read_bool()?;
                    },
                    64 => {
                        self.useRemoteClor = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.color.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.color);
            }
            if self.bold != false {
                my_size += 1 + 1;
            }
            if self.italic != false {
                my_size += 1 + 1;
            }
            if self.weight != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.weight);
            }
            if self.italicAngle != 0 {
                my_size += ::protobuf::rt::int32_size(5, self.italicAngle);
            }
            if self.fontSize != 0 {
                my_size += ::protobuf::rt::int32_size(6, self.fontSize);
            }
            if self.useHeighLightColor != false {
                my_size += 1 + 1;
            }
            if self.useRemoteClor != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.color.is_empty() {
                os.write_string(1, &self.color)?;
            }
            if self.bold != false {
                os.write_bool(2, self.bold)?;
            }
            if self.italic != false {
                os.write_bool(3, self.italic)?;
            }
            if self.weight != 0 {
                os.write_int32(4, self.weight)?;
            }
            if self.italicAngle != 0 {
                os.write_int32(5, self.italicAngle)?;
            }
            if self.fontSize != 0 {
                os.write_int32(6, self.fontSize)?;
            }
            if self.useHeighLightColor != false {
                os.write_bool(7, self.useHeighLightColor)?;
            }
            if self.useRemoteClor != false {
                os.write_bool(8, self.useRemoteClor)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextFormat {
            TextFormat::new()
        }

        fn clear(&mut self) {
            self.color.clear();
            self.bold = false;
            self.italic = false;
            self.weight = 0;
            self.italicAngle = 0;
            self.fontSize = 0;
            self.useHeighLightColor = false;
            self.useRemoteClor = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextFormat {
            static instance: TextFormat = TextFormat {
                color: ::std::string::String::new(),
                bold: false,
                italic: false,
                weight: 0,
                italicAngle: 0,
                fontSize: 0,
                useHeighLightColor: false,
                useRemoteClor: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextFormat {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Text.TextFormat").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextFormat {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.Text.TextPieceGift)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextPieceGift {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Text.TextPieceGift.giftId)
        pub giftId: i32,
        // @@protoc_insertion_point(field:TikTok.Text.TextPieceGift.colorId)
        pub colorId: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Text.TextPieceGift.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextPieceGift {
        fn default() -> &'a TextPieceGift {
            <TextPieceGift as ::protobuf::Message>::default_instance()
        }
    }

    impl TextPieceGift {
        pub fn new() -> TextPieceGift {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "giftId",
                |m: &TextPieceGift| { &m.giftId },
                |m: &mut TextPieceGift| { &mut m.giftId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "colorId",
                |m: &TextPieceGift| { &m.colorId },
                |m: &mut TextPieceGift| { &mut m.colorId },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextPieceGift>(
                "Text.TextPieceGift",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextPieceGift {
        const NAME: &'static str = "TextPieceGift";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.giftId = is.read_int32()?;
                    },
                    32 => {
                        self.colorId = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.giftId != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.giftId);
            }
            if self.colorId != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.colorId);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.giftId != 0 {
                os.write_int32(1, self.giftId)?;
            }
            if self.colorId != 0 {
                os.write_int64(4, self.colorId)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextPieceGift {
            TextPieceGift::new()
        }

        fn clear(&mut self) {
            self.giftId = 0;
            self.colorId = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextPieceGift {
            static instance: TextPieceGift = TextPieceGift {
                giftId: 0,
                colorId: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextPieceGift {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Text.TextPieceGift").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextPieceGift {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextPieceGift {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.Text.TextPiecePatternRef)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextPiecePatternRef {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Text.TextPiecePatternRef.key)
        pub key: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.Text.TextPiecePatternRef.defaultPattern)
        pub defaultPattern: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Text.TextPiecePatternRef.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextPiecePatternRef {
        fn default() -> &'a TextPiecePatternRef {
            <TextPiecePatternRef as ::protobuf::Message>::default_instance()
        }
    }

    impl TextPiecePatternRef {
        pub fn new() -> TextPiecePatternRef {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &TextPiecePatternRef| { &m.key },
                |m: &mut TextPiecePatternRef| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "defaultPattern",
                |m: &TextPiecePatternRef| { &m.defaultPattern },
                |m: &mut TextPiecePatternRef| { &mut m.defaultPattern },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextPiecePatternRef>(
                "Text.TextPiecePatternRef",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextPiecePatternRef {
        const NAME: &'static str = "TextPiecePatternRef";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    },
                    18 => {
                        self.defaultPattern = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            if !self.defaultPattern.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.defaultPattern);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            if !self.defaultPattern.is_empty() {
                os.write_string(2, &self.defaultPattern)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextPiecePatternRef {
            TextPiecePatternRef::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.defaultPattern.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextPiecePatternRef {
            static instance: TextPiecePatternRef = TextPiecePatternRef {
                key: ::std::string::String::new(),
                defaultPattern: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextPiecePatternRef {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Text.TextPiecePatternRef").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextPiecePatternRef {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextPiecePatternRef {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.Text.TextPieceUser)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextPieceUser {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Text.TextPieceUser.user)
        pub user: ::protobuf::MessageField<super::User>,
        // @@protoc_insertion_point(field:TikTok.Text.TextPieceUser.withColon)
        pub withColon: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Text.TextPieceUser.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextPieceUser {
        fn default() -> &'a TextPieceUser {
            <TextPieceUser as ::protobuf::Message>::default_instance()
        }
    }

    impl TextPieceUser {
        pub fn new() -> TextPieceUser {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::User>(
                "user",
                |m: &TextPieceUser| { &m.user },
                |m: &mut TextPieceUser| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "withColon",
                |m: &TextPieceUser| { &m.withColon },
                |m: &mut TextPieceUser| { &mut m.withColon },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextPieceUser>(
                "Text.TextPieceUser",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextPieceUser {
        const NAME: &'static str = "TextPieceUser";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                    },
                    16 => {
                        self.withColon = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.user.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.withColon != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.user.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.withColon != false {
                os.write_bool(2, self.withColon)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextPieceUser {
            TextPieceUser::new()
        }

        fn clear(&mut self) {
            self.user.clear();
            self.withColon = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextPieceUser {
            static instance: TextPieceUser = TextPieceUser {
                user: ::protobuf::MessageField::none(),
                withColon: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextPieceUser {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Text.TextPieceUser").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextPieceUser {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextPieceUser {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.Image)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Image {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Image.urlList)
    pub urlList: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:TikTok.Image.isAnimated)
    pub isAnimated: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Image.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "urlList",
            |m: &Image| { &m.urlList },
            |m: &mut Image| { &mut m.urlList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isAnimated",
            |m: &Image| { &m.isAnimated },
            |m: &mut Image| { &mut m.isAnimated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Image>(
            "Image",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Image {
    const NAME: &'static str = "Image";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.urlList.push(is.read_string()?);
                },
                72 => {
                    self.isAnimated = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.urlList {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.isAnimated != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.urlList {
            os.write_string(1, &v)?;
        };
        if self.isAnimated != false {
            os.write_bool(9, self.isAnimated)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Image {
        Image::new()
    }

    fn clear(&mut self) {
        self.urlList.clear();
        self.isAnimated = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Image {
        static instance: Image = Image {
            urlList: ::std::vec::Vec::new(),
            isAnimated: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Image {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Image").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.BadgeStruct)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BadgeStruct {
    // message fields
    // @@protoc_insertion_point(field:TikTok.BadgeStruct.displayType)
    pub displayType: ::protobuf::EnumOrUnknown<badge_struct::BadgeDisplayType>,
    // message oneof groups
    pub badgeType: ::std::option::Option<badge_struct::BadgeType>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BadgeStruct {
    fn default() -> &'a BadgeStruct {
        <BadgeStruct as ::protobuf::Message>::default_instance()
    }
}

impl BadgeStruct {
    pub fn new() -> BadgeStruct {
        ::std::default::Default::default()
    }

    // .TikTok.BadgeStruct.ImageBadge image = 20;

    pub fn image(&self) -> &badge_struct::ImageBadge {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Image(ref v)) => v,
            _ => <badge_struct::ImageBadge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_image(&mut self) {
        self.badgeType = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Image(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: badge_struct::ImageBadge) {
        self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Image(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image(&mut self) -> &mut badge_struct::ImageBadge {
        if let ::std::option::Option::Some(badge_struct::BadgeType::Image(_)) = self.badgeType {
        } else {
            self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Image(badge_struct::ImageBadge::new()));
        }
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Image(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image(&mut self) -> badge_struct::ImageBadge {
        if self.has_image() {
            match self.badgeType.take() {
                ::std::option::Option::Some(badge_struct::BadgeType::Image(v)) => v,
                _ => panic!(),
            }
        } else {
            badge_struct::ImageBadge::new()
        }
    }

    // .TikTok.BadgeStruct.TextBadge text = 21;

    pub fn text(&self) -> &badge_struct::TextBadge {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Text(ref v)) => v,
            _ => <badge_struct::TextBadge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_text(&mut self) {
        self.badgeType = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: badge_struct::TextBadge) {
        self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut badge_struct::TextBadge {
        if let ::std::option::Option::Some(badge_struct::BadgeType::Text(_)) = self.badgeType {
        } else {
            self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Text(badge_struct::TextBadge::new()));
        }
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> badge_struct::TextBadge {
        if self.has_text() {
            match self.badgeType.take() {
                ::std::option::Option::Some(badge_struct::BadgeType::Text(v)) => v,
                _ => panic!(),
            }
        } else {
            badge_struct::TextBadge::new()
        }
    }

    // .TikTok.BadgeStruct.StringBadge str = 22;

    pub fn str(&self) -> &badge_struct::StringBadge {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Str(ref v)) => v,
            _ => <badge_struct::StringBadge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_str(&mut self) {
        self.badgeType = ::std::option::Option::None;
    }

    pub fn has_str(&self) -> bool {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_str(&mut self, v: badge_struct::StringBadge) {
        self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_str(&mut self) -> &mut badge_struct::StringBadge {
        if let ::std::option::Option::Some(badge_struct::BadgeType::Str(_)) = self.badgeType {
        } else {
            self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Str(badge_struct::StringBadge::new()));
        }
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_str(&mut self) -> badge_struct::StringBadge {
        if self.has_str() {
            match self.badgeType.take() {
                ::std::option::Option::Some(badge_struct::BadgeType::Str(v)) => v,
                _ => panic!(),
            }
        } else {
            badge_struct::StringBadge::new()
        }
    }

    // .TikTok.BadgeStruct.CombineBadge combine = 23;

    pub fn combine(&self) -> &badge_struct::CombineBadge {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Combine(ref v)) => v,
            _ => <badge_struct::CombineBadge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_combine(&mut self) {
        self.badgeType = ::std::option::Option::None;
    }

    pub fn has_combine(&self) -> bool {
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Combine(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine(&mut self, v: badge_struct::CombineBadge) {
        self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Combine(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine(&mut self) -> &mut badge_struct::CombineBadge {
        if let ::std::option::Option::Some(badge_struct::BadgeType::Combine(_)) = self.badgeType {
        } else {
            self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Combine(badge_struct::CombineBadge::new()));
        }
        match self.badgeType {
            ::std::option::Option::Some(badge_struct::BadgeType::Combine(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine(&mut self) -> badge_struct::CombineBadge {
        if self.has_combine() {
            match self.badgeType.take() {
                ::std::option::Option::Some(badge_struct::BadgeType::Combine(v)) => v,
                _ => panic!(),
            }
        } else {
            badge_struct::CombineBadge::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "displayType",
            |m: &BadgeStruct| { &m.displayType },
            |m: &mut BadgeStruct| { &mut m.displayType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, badge_struct::ImageBadge>(
            "image",
            BadgeStruct::has_image,
            BadgeStruct::image,
            BadgeStruct::mut_image,
            BadgeStruct::set_image,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, badge_struct::TextBadge>(
            "text",
            BadgeStruct::has_text,
            BadgeStruct::text,
            BadgeStruct::mut_text,
            BadgeStruct::set_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, badge_struct::StringBadge>(
            "str",
            BadgeStruct::has_str,
            BadgeStruct::str,
            BadgeStruct::mut_str,
            BadgeStruct::set_str,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, badge_struct::CombineBadge>(
            "combine",
            BadgeStruct::has_combine,
            BadgeStruct::combine,
            BadgeStruct::mut_combine,
            BadgeStruct::set_combine,
        ));
        oneofs.push(badge_struct::BadgeType::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BadgeStruct>(
            "BadgeStruct",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BadgeStruct {
    const NAME: &'static str = "BadgeStruct";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.displayType = is.read_enum_or_unknown()?;
                },
                162 => {
                    self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Image(is.read_message()?));
                },
                170 => {
                    self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Text(is.read_message()?));
                },
                178 => {
                    self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Str(is.read_message()?));
                },
                186 => {
                    self.badgeType = ::std::option::Option::Some(badge_struct::BadgeType::Combine(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.displayType != ::protobuf::EnumOrUnknown::new(badge_struct::BadgeDisplayType::BADGEDISPLAYTYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.displayType.value());
        }
        if let ::std::option::Option::Some(ref v) = self.badgeType {
            match v {
                &badge_struct::BadgeType::Image(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &badge_struct::BadgeType::Text(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &badge_struct::BadgeType::Str(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &badge_struct::BadgeType::Combine(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.displayType != ::protobuf::EnumOrUnknown::new(badge_struct::BadgeDisplayType::BADGEDISPLAYTYPE_UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.displayType))?;
        }
        if let ::std::option::Option::Some(ref v) = self.badgeType {
            match v {
                &badge_struct::BadgeType::Image(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &badge_struct::BadgeType::Text(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &badge_struct::BadgeType::Str(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &badge_struct::BadgeType::Combine(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BadgeStruct {
        BadgeStruct::new()
    }

    fn clear(&mut self) {
        self.displayType = ::protobuf::EnumOrUnknown::new(badge_struct::BadgeDisplayType::BADGEDISPLAYTYPE_UNKNOWN);
        self.badgeType = ::std::option::Option::None;
        self.badgeType = ::std::option::Option::None;
        self.badgeType = ::std::option::Option::None;
        self.badgeType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BadgeStruct {
        static instance: BadgeStruct = BadgeStruct {
            displayType: ::protobuf::EnumOrUnknown::from_i32(0),
            badgeType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BadgeStruct {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BadgeStruct").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BadgeStruct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BadgeStruct {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BadgeStruct`
pub mod badge_struct {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TikTok.BadgeStruct.badgeType)
    pub enum BadgeType {
        // @@protoc_insertion_point(oneof_field:TikTok.BadgeStruct.image)
        Image(ImageBadge),
        // @@protoc_insertion_point(oneof_field:TikTok.BadgeStruct.text)
        Text(TextBadge),
        // @@protoc_insertion_point(oneof_field:TikTok.BadgeStruct.str)
        Str(StringBadge),
        // @@protoc_insertion_point(oneof_field:TikTok.BadgeStruct.combine)
        Combine(CombineBadge),
    }

    impl ::protobuf::Oneof for BadgeType {
    }

    impl ::protobuf::OneofFull for BadgeType {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BadgeStruct as ::protobuf::MessageFull>::descriptor().oneof_by_name("badgeType").unwrap()).clone()
        }
    }

    impl BadgeType {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<BadgeType>("badgeType")
        }
    }
    // @@protoc_insertion_point(message:TikTok.BadgeStruct.CombineBadge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CombineBadge {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.icon)
        pub icon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.text)
        pub text: ::protobuf::MessageField<TextBadge>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.str)
        pub str: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.profileCardPanel)
        pub profileCardPanel: ::protobuf::MessageField<ProfileCardPanel>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.background)
        pub background: ::protobuf::MessageField<CombineBadgeBackground>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.backgroundDarkMode)
        pub backgroundDarkMode: ::protobuf::MessageField<CombineBadgeBackground>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.iconAutoMirrored)
        pub iconAutoMirrored: bool,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.backgroundAutoMirrored)
        pub backgroundAutoMirrored: bool,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.publicScreenShowStyle)
        pub publicScreenShowStyle: i32,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.personalCardShowStyle)
        pub personalCardShowStyle: i32,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.ranklistOnlineAudienceShowStyle)
        pub ranklistOnlineAudienceShowStyle: i32,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadge.multiGuestShowStyle)
        pub multiGuestShowStyle: i32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.CombineBadge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CombineBadge {
        fn default() -> &'a CombineBadge {
            <CombineBadge as ::protobuf::Message>::default_instance()
        }
    }

    impl CombineBadge {
        pub fn new() -> CombineBadge {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "icon",
                |m: &CombineBadge| { &m.icon },
                |m: &mut CombineBadge| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TextBadge>(
                "text",
                |m: &CombineBadge| { &m.text },
                |m: &mut CombineBadge| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "str",
                |m: &CombineBadge| { &m.str },
                |m: &mut CombineBadge| { &mut m.str },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProfileCardPanel>(
                "profileCardPanel",
                |m: &CombineBadge| { &m.profileCardPanel },
                |m: &mut CombineBadge| { &mut m.profileCardPanel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CombineBadgeBackground>(
                "background",
                |m: &CombineBadge| { &m.background },
                |m: &mut CombineBadge| { &mut m.background },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CombineBadgeBackground>(
                "backgroundDarkMode",
                |m: &CombineBadge| { &m.backgroundDarkMode },
                |m: &mut CombineBadge| { &mut m.backgroundDarkMode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "iconAutoMirrored",
                |m: &CombineBadge| { &m.iconAutoMirrored },
                |m: &mut CombineBadge| { &mut m.iconAutoMirrored },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "backgroundAutoMirrored",
                |m: &CombineBadge| { &m.backgroundAutoMirrored },
                |m: &mut CombineBadge| { &mut m.backgroundAutoMirrored },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "publicScreenShowStyle",
                |m: &CombineBadge| { &m.publicScreenShowStyle },
                |m: &mut CombineBadge| { &mut m.publicScreenShowStyle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "personalCardShowStyle",
                |m: &CombineBadge| { &m.personalCardShowStyle },
                |m: &mut CombineBadge| { &mut m.personalCardShowStyle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ranklistOnlineAudienceShowStyle",
                |m: &CombineBadge| { &m.ranklistOnlineAudienceShowStyle },
                |m: &mut CombineBadge| { &mut m.ranklistOnlineAudienceShowStyle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "multiGuestShowStyle",
                |m: &CombineBadge| { &m.multiGuestShowStyle },
                |m: &mut CombineBadge| { &mut m.multiGuestShowStyle },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CombineBadge>(
                "BadgeStruct.CombineBadge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CombineBadge {
        const NAME: &'static str = "CombineBadge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.text)?;
                    },
                    34 => {
                        self.str = is.read_string()?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profileCardPanel)?;
                    },
                    90 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                    },
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.backgroundDarkMode)?;
                    },
                    104 => {
                        self.iconAutoMirrored = is.read_bool()?;
                    },
                    112 => {
                        self.backgroundAutoMirrored = is.read_bool()?;
                    },
                    120 => {
                        self.publicScreenShowStyle = is.read_int32()?;
                    },
                    128 => {
                        self.personalCardShowStyle = is.read_int32()?;
                    },
                    136 => {
                        self.ranklistOnlineAudienceShowStyle = is.read_int32()?;
                    },
                    144 => {
                        self.multiGuestShowStyle = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.icon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.text.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.str.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.str);
            }
            if let Some(v) = self.profileCardPanel.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.background.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.backgroundDarkMode.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.iconAutoMirrored != false {
                my_size += 1 + 1;
            }
            if self.backgroundAutoMirrored != false {
                my_size += 1 + 1;
            }
            if self.publicScreenShowStyle != 0 {
                my_size += ::protobuf::rt::int32_size(15, self.publicScreenShowStyle);
            }
            if self.personalCardShowStyle != 0 {
                my_size += ::protobuf::rt::int32_size(16, self.personalCardShowStyle);
            }
            if self.ranklistOnlineAudienceShowStyle != 0 {
                my_size += ::protobuf::rt::int32_size(17, self.ranklistOnlineAudienceShowStyle);
            }
            if self.multiGuestShowStyle != 0 {
                my_size += ::protobuf::rt::int32_size(18, self.multiGuestShowStyle);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.icon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.text.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if !self.str.is_empty() {
                os.write_string(4, &self.str)?;
            }
            if let Some(v) = self.profileCardPanel.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.background.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            }
            if let Some(v) = self.backgroundDarkMode.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if self.iconAutoMirrored != false {
                os.write_bool(13, self.iconAutoMirrored)?;
            }
            if self.backgroundAutoMirrored != false {
                os.write_bool(14, self.backgroundAutoMirrored)?;
            }
            if self.publicScreenShowStyle != 0 {
                os.write_int32(15, self.publicScreenShowStyle)?;
            }
            if self.personalCardShowStyle != 0 {
                os.write_int32(16, self.personalCardShowStyle)?;
            }
            if self.ranklistOnlineAudienceShowStyle != 0 {
                os.write_int32(17, self.ranklistOnlineAudienceShowStyle)?;
            }
            if self.multiGuestShowStyle != 0 {
                os.write_int32(18, self.multiGuestShowStyle)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CombineBadge {
            CombineBadge::new()
        }

        fn clear(&mut self) {
            self.icon.clear();
            self.text.clear();
            self.str.clear();
            self.profileCardPanel.clear();
            self.background.clear();
            self.backgroundDarkMode.clear();
            self.iconAutoMirrored = false;
            self.backgroundAutoMirrored = false;
            self.publicScreenShowStyle = 0;
            self.personalCardShowStyle = 0;
            self.ranklistOnlineAudienceShowStyle = 0;
            self.multiGuestShowStyle = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CombineBadge {
            static instance: CombineBadge = CombineBadge {
                icon: ::protobuf::MessageField::none(),
                text: ::protobuf::MessageField::none(),
                str: ::std::string::String::new(),
                profileCardPanel: ::protobuf::MessageField::none(),
                background: ::protobuf::MessageField::none(),
                backgroundDarkMode: ::protobuf::MessageField::none(),
                iconAutoMirrored: false,
                backgroundAutoMirrored: false,
                publicScreenShowStyle: 0,
                personalCardShowStyle: 0,
                ranklistOnlineAudienceShowStyle: 0,
                multiGuestShowStyle: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CombineBadge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.CombineBadge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CombineBadge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CombineBadge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.ProfileContent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProfileContent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProfileContent.useContent)
        pub useContent: bool,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProfileContent.iconList)
        pub iconList: ::std::vec::Vec<IconConfig>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProfileContent.numberConfig)
        pub numberConfig: ::protobuf::MessageField<NumberConfig>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.ProfileContent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProfileContent {
        fn default() -> &'a ProfileContent {
            <ProfileContent as ::protobuf::Message>::default_instance()
        }
    }

    impl ProfileContent {
        pub fn new() -> ProfileContent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "useContent",
                |m: &ProfileContent| { &m.useContent },
                |m: &mut ProfileContent| { &mut m.useContent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "iconList",
                |m: &ProfileContent| { &m.iconList },
                |m: &mut ProfileContent| { &mut m.iconList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NumberConfig>(
                "numberConfig",
                |m: &ProfileContent| { &m.numberConfig },
                |m: &mut ProfileContent| { &mut m.numberConfig },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProfileContent>(
                "BadgeStruct.ProfileContent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProfileContent {
        const NAME: &'static str = "ProfileContent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.useContent = is.read_bool()?;
                    },
                    18 => {
                        self.iconList.push(is.read_message()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.numberConfig)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.useContent != false {
                my_size += 1 + 1;
            }
            for value in &self.iconList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.numberConfig.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.useContent != false {
                os.write_bool(1, self.useContent)?;
            }
            for v in &self.iconList {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.numberConfig.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProfileContent {
            ProfileContent::new()
        }

        fn clear(&mut self) {
            self.useContent = false;
            self.iconList.clear();
            self.numberConfig.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProfileContent {
            static instance: ProfileContent = ProfileContent {
                useContent: false,
                iconList: ::std::vec::Vec::new(),
                numberConfig: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProfileContent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.ProfileContent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProfileContent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProfileContent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.ProjectionConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProjectionConfig {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProjectionConfig.useProjection)
        pub useProjection: bool,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProjectionConfig.icon)
        pub icon: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.ProjectionConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProjectionConfig {
        fn default() -> &'a ProjectionConfig {
            <ProjectionConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl ProjectionConfig {
        pub fn new() -> ProjectionConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "useProjection",
                |m: &ProjectionConfig| { &m.useProjection },
                |m: &mut ProjectionConfig| { &mut m.useProjection },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "icon",
                |m: &ProjectionConfig| { &m.icon },
                |m: &mut ProjectionConfig| { &mut m.icon },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProjectionConfig>(
                "BadgeStruct.ProjectionConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProjectionConfig {
        const NAME: &'static str = "ProjectionConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.useProjection = is.read_bool()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.useProjection != false {
                my_size += 1 + 1;
            }
            if let Some(v) = self.icon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.useProjection != false {
                os.write_bool(1, self.useProjection)?;
            }
            if let Some(v) = self.icon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProjectionConfig {
            ProjectionConfig::new()
        }

        fn clear(&mut self) {
            self.useProjection = false;
            self.icon.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProjectionConfig {
            static instance: ProjectionConfig = ProjectionConfig {
                useProjection: false,
                icon: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProjectionConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.ProjectionConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProjectionConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProjectionConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.NumberConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NumberConfig {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.NumberConfig.number)
        pub number: i64,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.NumberConfig.background)
        pub background: ::protobuf::MessageField<CombineBadgeBackground>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.NumberConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NumberConfig {
        fn default() -> &'a NumberConfig {
            <NumberConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl NumberConfig {
        pub fn new() -> NumberConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "number",
                |m: &NumberConfig| { &m.number },
                |m: &mut NumberConfig| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CombineBadgeBackground>(
                "background",
                |m: &NumberConfig| { &m.background },
                |m: &mut NumberConfig| { &mut m.background },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumberConfig>(
                "BadgeStruct.NumberConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NumberConfig {
        const NAME: &'static str = "NumberConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.number = is.read_int64()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.number != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.number);
            }
            if let Some(v) = self.background.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.number != 0 {
                os.write_int64(1, self.number)?;
            }
            if let Some(v) = self.background.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NumberConfig {
            NumberConfig::new()
        }

        fn clear(&mut self) {
            self.number = 0;
            self.background.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NumberConfig {
            static instance: NumberConfig = NumberConfig {
                number: 0,
                background: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NumberConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.NumberConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NumberConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NumberConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.ProfileCardPanel)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProfileCardPanel {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProfileCardPanel.useNewProfileCardStyle)
        pub useNewProfileCardStyle: bool,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProfileCardPanel.projectionConfig)
        pub projectionConfig: ::protobuf::MessageField<ProjectionConfig>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ProfileCardPanel.profileContent)
        pub profileContent: ::protobuf::MessageField<ProfileContent>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.ProfileCardPanel.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProfileCardPanel {
        fn default() -> &'a ProfileCardPanel {
            <ProfileCardPanel as ::protobuf::Message>::default_instance()
        }
    }

    impl ProfileCardPanel {
        pub fn new() -> ProfileCardPanel {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "useNewProfileCardStyle",
                |m: &ProfileCardPanel| { &m.useNewProfileCardStyle },
                |m: &mut ProfileCardPanel| { &mut m.useNewProfileCardStyle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProjectionConfig>(
                "projectionConfig",
                |m: &ProfileCardPanel| { &m.projectionConfig },
                |m: &mut ProfileCardPanel| { &mut m.projectionConfig },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProfileContent>(
                "profileContent",
                |m: &ProfileCardPanel| { &m.profileContent },
                |m: &mut ProfileCardPanel| { &mut m.profileContent },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProfileCardPanel>(
                "BadgeStruct.ProfileCardPanel",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProfileCardPanel {
        const NAME: &'static str = "ProfileCardPanel";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.useNewProfileCardStyle = is.read_bool()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.projectionConfig)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profileContent)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.useNewProfileCardStyle != false {
                my_size += 1 + 1;
            }
            if let Some(v) = self.projectionConfig.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.profileContent.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.useNewProfileCardStyle != false {
                os.write_bool(1, self.useNewProfileCardStyle)?;
            }
            if let Some(v) = self.projectionConfig.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.profileContent.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProfileCardPanel {
            ProfileCardPanel::new()
        }

        fn clear(&mut self) {
            self.useNewProfileCardStyle = false;
            self.projectionConfig.clear();
            self.profileContent.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProfileCardPanel {
            static instance: ProfileCardPanel = ProfileCardPanel {
                useNewProfileCardStyle: false,
                projectionConfig: ::protobuf::MessageField::none(),
                profileContent: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProfileCardPanel {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.ProfileCardPanel").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProfileCardPanel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProfileCardPanel {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.CombineBadgeBackground)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CombineBadgeBackground {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadgeBackground.image)
        pub image: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadgeBackground.backgroundColorCode)
        pub backgroundColorCode: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.CombineBadgeBackground.borderColorCode)
        pub borderColorCode: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.CombineBadgeBackground.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CombineBadgeBackground {
        fn default() -> &'a CombineBadgeBackground {
            <CombineBadgeBackground as ::protobuf::Message>::default_instance()
        }
    }

    impl CombineBadgeBackground {
        pub fn new() -> CombineBadgeBackground {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "image",
                |m: &CombineBadgeBackground| { &m.image },
                |m: &mut CombineBadgeBackground| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "backgroundColorCode",
                |m: &CombineBadgeBackground| { &m.backgroundColorCode },
                |m: &mut CombineBadgeBackground| { &mut m.backgroundColorCode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "borderColorCode",
                |m: &CombineBadgeBackground| { &m.borderColorCode },
                |m: &mut CombineBadgeBackground| { &mut m.borderColorCode },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CombineBadgeBackground>(
                "BadgeStruct.CombineBadgeBackground",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CombineBadgeBackground {
        const NAME: &'static str = "CombineBadgeBackground";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                    },
                    18 => {
                        self.backgroundColorCode = is.read_string()?;
                    },
                    26 => {
                        self.borderColorCode = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.image.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.backgroundColorCode.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.backgroundColorCode);
            }
            if !self.borderColorCode.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.borderColorCode);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.image.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if !self.backgroundColorCode.is_empty() {
                os.write_string(2, &self.backgroundColorCode)?;
            }
            if !self.borderColorCode.is_empty() {
                os.write_string(3, &self.borderColorCode)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CombineBadgeBackground {
            CombineBadgeBackground::new()
        }

        fn clear(&mut self) {
            self.image.clear();
            self.backgroundColorCode.clear();
            self.borderColorCode.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CombineBadgeBackground {
            static instance: CombineBadgeBackground = CombineBadgeBackground {
                image: ::protobuf::MessageField::none(),
                backgroundColorCode: ::std::string::String::new(),
                borderColorCode: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CombineBadgeBackground {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.CombineBadgeBackground").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CombineBadgeBackground {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CombineBadgeBackground {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.ImageBadge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ImageBadge {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.ImageBadge.image)
        pub image: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.ImageBadge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ImageBadge {
        fn default() -> &'a ImageBadge {
            <ImageBadge as ::protobuf::Message>::default_instance()
        }
    }

    impl ImageBadge {
        pub fn new() -> ImageBadge {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "image",
                |m: &ImageBadge| { &m.image },
                |m: &mut ImageBadge| { &mut m.image },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImageBadge>(
                "BadgeStruct.ImageBadge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ImageBadge {
        const NAME: &'static str = "ImageBadge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.image.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.image.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ImageBadge {
            ImageBadge::new()
        }

        fn clear(&mut self) {
            self.image.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ImageBadge {
            static instance: ImageBadge = ImageBadge {
                image: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ImageBadge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.ImageBadge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ImageBadge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ImageBadge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.TextBadge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextBadge {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.TextBadge.defaultPattern)
        pub defaultPattern: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.TextBadge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextBadge {
        fn default() -> &'a TextBadge {
            <TextBadge as ::protobuf::Message>::default_instance()
        }
    }

    impl TextBadge {
        pub fn new() -> TextBadge {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "defaultPattern",
                |m: &TextBadge| { &m.defaultPattern },
                |m: &mut TextBadge| { &mut m.defaultPattern },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextBadge>(
                "BadgeStruct.TextBadge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextBadge {
        const NAME: &'static str = "TextBadge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    26 => {
                        self.defaultPattern = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.defaultPattern.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.defaultPattern);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.defaultPattern.is_empty() {
                os.write_string(3, &self.defaultPattern)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextBadge {
            TextBadge::new()
        }

        fn clear(&mut self) {
            self.defaultPattern.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextBadge {
            static instance: TextBadge = TextBadge {
                defaultPattern: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextBadge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.TextBadge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextBadge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextBadge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.IconConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct IconConfig {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.IconConfig.icon)
        pub icon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.IconConfig.background)
        pub background: ::protobuf::MessageField<CombineBadgeBackground>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.IconConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IconConfig {
        fn default() -> &'a IconConfig {
            <IconConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl IconConfig {
        pub fn new() -> IconConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "icon",
                |m: &IconConfig| { &m.icon },
                |m: &mut IconConfig| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CombineBadgeBackground>(
                "background",
                |m: &IconConfig| { &m.background },
                |m: &mut IconConfig| { &mut m.background },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IconConfig>(
                "BadgeStruct.IconConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for IconConfig {
        const NAME: &'static str = "IconConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.icon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.background.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.icon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.background.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IconConfig {
            IconConfig::new()
        }

        fn clear(&mut self) {
            self.icon.clear();
            self.background.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IconConfig {
            static instance: IconConfig = IconConfig {
                icon: ::protobuf::MessageField::none(),
                background: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for IconConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.IconConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IconConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IconConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BadgeStruct.StringBadge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StringBadge {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BadgeStruct.StringBadge.str)
        pub str: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BadgeStruct.StringBadge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StringBadge {
        fn default() -> &'a StringBadge {
            <StringBadge as ::protobuf::Message>::default_instance()
        }
    }

    impl StringBadge {
        pub fn new() -> StringBadge {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "str",
                |m: &StringBadge| { &m.str },
                |m: &mut StringBadge| { &mut m.str },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringBadge>(
                "BadgeStruct.StringBadge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StringBadge {
        const NAME: &'static str = "StringBadge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.str = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.str.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.str);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.str.is_empty() {
                os.write_string(2, &self.str)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StringBadge {
            StringBadge::new()
        }

        fn clear(&mut self) {
            self.str.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StringBadge {
            static instance: StringBadge = StringBadge {
                str: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StringBadge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BadgeStruct.StringBadge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StringBadge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StringBadge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TikTok.BadgeStruct.DataCase)
    pub enum DataCase {
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.DataCase.DATA_NOT_SET)
        DATA_NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.DataCase.IMAGE)
        IMAGE = 20,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.DataCase.TEXT)
        TEXT = 21,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.DataCase.STR)
        STR = 22,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.DataCase.COMBINE)
        COMBINE = 23,
    }

    impl ::protobuf::Enum for DataCase {
        const NAME: &'static str = "DataCase";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DataCase> {
            match value {
                0 => ::std::option::Option::Some(DataCase::DATA_NOT_SET),
                20 => ::std::option::Option::Some(DataCase::IMAGE),
                21 => ::std::option::Option::Some(DataCase::TEXT),
                22 => ::std::option::Option::Some(DataCase::STR),
                23 => ::std::option::Option::Some(DataCase::COMBINE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<DataCase> {
            match str {
                "DATA_NOT_SET" => ::std::option::Option::Some(DataCase::DATA_NOT_SET),
                "IMAGE" => ::std::option::Option::Some(DataCase::IMAGE),
                "TEXT" => ::std::option::Option::Some(DataCase::TEXT),
                "STR" => ::std::option::Option::Some(DataCase::STR),
                "COMBINE" => ::std::option::Option::Some(DataCase::COMBINE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DataCase] = &[
            DataCase::DATA_NOT_SET,
            DataCase::IMAGE,
            DataCase::TEXT,
            DataCase::STR,
            DataCase::COMBINE,
        ];
    }

    impl ::protobuf::EnumFull for DataCase {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BadgeStruct.DataCase").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                DataCase::DATA_NOT_SET => 0,
                DataCase::IMAGE => 1,
                DataCase::TEXT => 2,
                DataCase::STR => 3,
                DataCase::COMBINE => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DataCase {
        fn default() -> Self {
            DataCase::DATA_NOT_SET
        }
    }

    impl DataCase {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataCase>("BadgeStruct.DataCase")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TikTok.BadgeStruct.BadgeDisplayType)
    pub enum BadgeDisplayType {
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.BadgeDisplayType.BADGEDISPLAYTYPE_UNKNOWN)
        BADGEDISPLAYTYPE_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.BadgeDisplayType.BADGEDISPLAYTYPE_IMAGE)
        BADGEDISPLAYTYPE_IMAGE = 1,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.BadgeDisplayType.BADGEDISPLAYTYPE_TEXT)
        BADGEDISPLAYTYPE_TEXT = 2,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.BadgeDisplayType.BADGEDISPLAYTYPE_STRING)
        BADGEDISPLAYTYPE_STRING = 3,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.BadgeDisplayType.BADGEDISPLAYTYPE_COMBINE)
        BADGEDISPLAYTYPE_COMBINE = 4,
    }

    impl ::protobuf::Enum for BadgeDisplayType {
        const NAME: &'static str = "BadgeDisplayType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BadgeDisplayType> {
            match value {
                0 => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_UNKNOWN),
                1 => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_IMAGE),
                2 => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_TEXT),
                3 => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_STRING),
                4 => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_COMBINE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BadgeDisplayType> {
            match str {
                "BADGEDISPLAYTYPE_UNKNOWN" => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_UNKNOWN),
                "BADGEDISPLAYTYPE_IMAGE" => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_IMAGE),
                "BADGEDISPLAYTYPE_TEXT" => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_TEXT),
                "BADGEDISPLAYTYPE_STRING" => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_STRING),
                "BADGEDISPLAYTYPE_COMBINE" => ::std::option::Option::Some(BadgeDisplayType::BADGEDISPLAYTYPE_COMBINE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BadgeDisplayType] = &[
            BadgeDisplayType::BADGEDISPLAYTYPE_UNKNOWN,
            BadgeDisplayType::BADGEDISPLAYTYPE_IMAGE,
            BadgeDisplayType::BADGEDISPLAYTYPE_TEXT,
            BadgeDisplayType::BADGEDISPLAYTYPE_STRING,
            BadgeDisplayType::BADGEDISPLAYTYPE_COMBINE,
        ];
    }

    impl ::protobuf::EnumFull for BadgeDisplayType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BadgeStruct.BadgeDisplayType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BadgeDisplayType {
        fn default() -> Self {
            BadgeDisplayType::BADGEDISPLAYTYPE_UNKNOWN
        }
    }

    impl BadgeDisplayType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BadgeDisplayType>("BadgeStruct.BadgeDisplayType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TikTok.BadgeStruct.Position)
    pub enum Position {
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.Position.POSITIONUNKNOWN)
        POSITIONUNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.Position.POSITIONLEFT)
        POSITIONLEFT = 1,
        // @@protoc_insertion_point(enum_value:TikTok.BadgeStruct.Position.POSITIONRIGHT)
        POSITIONRIGHT = 2,
    }

    impl ::protobuf::Enum for Position {
        const NAME: &'static str = "Position";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Position> {
            match value {
                0 => ::std::option::Option::Some(Position::POSITIONUNKNOWN),
                1 => ::std::option::Option::Some(Position::POSITIONLEFT),
                2 => ::std::option::Option::Some(Position::POSITIONRIGHT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Position> {
            match str {
                "POSITIONUNKNOWN" => ::std::option::Option::Some(Position::POSITIONUNKNOWN),
                "POSITIONLEFT" => ::std::option::Option::Some(Position::POSITIONLEFT),
                "POSITIONRIGHT" => ::std::option::Option::Some(Position::POSITIONRIGHT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Position] = &[
            Position::POSITIONUNKNOWN,
            Position::POSITIONLEFT,
            Position::POSITIONRIGHT,
        ];
    }

    impl ::protobuf::EnumFull for Position {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BadgeStruct.Position").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Position {
        fn default() -> Self {
            Position::POSITIONUNKNOWN
        }
    }

    impl Position {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Position>("BadgeStruct.Position")
        }
    }
}

// @@protoc_insertion_point(message:TikTok.GiftStruct)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GiftStruct {
    // message fields
    // @@protoc_insertion_point(field:TikTok.GiftStruct.image)
    pub image: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.describe)
    pub describe: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.duration)
    pub duration: i64,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.id)
    pub id: i64,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.forLinkmic)
    pub forLinkmic: bool,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.combo)
    pub combo: bool,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.diamondCount)
    pub diamondCount: i32,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.isDisplayedOnPanel)
    pub isDisplayedOnPanel: bool,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.primaryEffectId)
    pub primaryEffectId: i64,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.giftLabelIcon)
    pub giftLabelIcon: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.icon)
    pub icon: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.goldEffect)
    pub goldEffect: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.previewImage)
    pub previewImage: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.giftPanelBanner)
    pub giftPanelBanner: ::protobuf::MessageField<gift_struct::GiftPanelBanner>,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.isBroadcastGift)
    pub isBroadcastGift: bool,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.isEffectBefview)
    pub isEffectBefview: bool,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.isRandomGift)
    pub isRandomGift: bool,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.isBoxGift)
    pub isBoxGift: bool,
    // @@protoc_insertion_point(field:TikTok.GiftStruct.canPutInGiftBox)
    pub canPutInGiftBox: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.GiftStruct.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GiftStruct {
    fn default() -> &'a GiftStruct {
        <GiftStruct as ::protobuf::Message>::default_instance()
    }
}

impl GiftStruct {
    pub fn new() -> GiftStruct {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &GiftStruct| { &m.image },
            |m: &mut GiftStruct| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "describe",
            |m: &GiftStruct| { &m.describe },
            |m: &mut GiftStruct| { &mut m.describe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &GiftStruct| { &m.duration },
            |m: &mut GiftStruct| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GiftStruct| { &m.id },
            |m: &mut GiftStruct| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "forLinkmic",
            |m: &GiftStruct| { &m.forLinkmic },
            |m: &mut GiftStruct| { &mut m.forLinkmic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "combo",
            |m: &GiftStruct| { &m.combo },
            |m: &mut GiftStruct| { &mut m.combo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &GiftStruct| { &m.type_ },
            |m: &mut GiftStruct| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "diamondCount",
            |m: &GiftStruct| { &m.diamondCount },
            |m: &mut GiftStruct| { &mut m.diamondCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isDisplayedOnPanel",
            |m: &GiftStruct| { &m.isDisplayedOnPanel },
            |m: &mut GiftStruct| { &mut m.isDisplayedOnPanel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "primaryEffectId",
            |m: &GiftStruct| { &m.primaryEffectId },
            |m: &mut GiftStruct| { &mut m.primaryEffectId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "giftLabelIcon",
            |m: &GiftStruct| { &m.giftLabelIcon },
            |m: &mut GiftStruct| { &mut m.giftLabelIcon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GiftStruct| { &m.name },
            |m: &mut GiftStruct| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "icon",
            |m: &GiftStruct| { &m.icon },
            |m: &mut GiftStruct| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "goldEffect",
            |m: &GiftStruct| { &m.goldEffect },
            |m: &mut GiftStruct| { &mut m.goldEffect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "previewImage",
            |m: &GiftStruct| { &m.previewImage },
            |m: &mut GiftStruct| { &mut m.previewImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, gift_struct::GiftPanelBanner>(
            "giftPanelBanner",
            |m: &GiftStruct| { &m.giftPanelBanner },
            |m: &mut GiftStruct| { &mut m.giftPanelBanner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isBroadcastGift",
            |m: &GiftStruct| { &m.isBroadcastGift },
            |m: &mut GiftStruct| { &mut m.isBroadcastGift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isEffectBefview",
            |m: &GiftStruct| { &m.isEffectBefview },
            |m: &mut GiftStruct| { &mut m.isEffectBefview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isRandomGift",
            |m: &GiftStruct| { &m.isRandomGift },
            |m: &mut GiftStruct| { &mut m.isRandomGift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isBoxGift",
            |m: &GiftStruct| { &m.isBoxGift },
            |m: &mut GiftStruct| { &mut m.isBoxGift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "canPutInGiftBox",
            |m: &GiftStruct| { &m.canPutInGiftBox },
            |m: &mut GiftStruct| { &mut m.canPutInGiftBox },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GiftStruct>(
            "GiftStruct",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GiftStruct {
    const NAME: &'static str = "GiftStruct";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                18 => {
                    self.describe = is.read_string()?;
                },
                32 => {
                    self.duration = is.read_int64()?;
                },
                40 => {
                    self.id = is.read_int64()?;
                },
                56 => {
                    self.forLinkmic = is.read_bool()?;
                },
                80 => {
                    self.combo = is.read_bool()?;
                },
                88 => {
                    self.type_ = is.read_int32()?;
                },
                96 => {
                    self.diamondCount = is.read_int32()?;
                },
                104 => {
                    self.isDisplayedOnPanel = is.read_bool()?;
                },
                112 => {
                    self.primaryEffectId = is.read_int64()?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.giftLabelIcon)?;
                },
                130 => {
                    self.name = is.read_string()?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                },
                194 => {
                    self.goldEffect = is.read_string()?;
                },
                378 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.previewImage)?;
                },
                386 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.giftPanelBanner)?;
                },
                392 => {
                    self.isBroadcastGift = is.read_bool()?;
                },
                400 => {
                    self.isEffectBefview = is.read_bool()?;
                },
                408 => {
                    self.isRandomGift = is.read_bool()?;
                },
                416 => {
                    self.isBoxGift = is.read_bool()?;
                },
                424 => {
                    self.canPutInGiftBox = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.describe.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.describe);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.duration);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.id);
        }
        if self.forLinkmic != false {
            my_size += 1 + 1;
        }
        if self.combo != false {
            my_size += 1 + 1;
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.type_);
        }
        if self.diamondCount != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.diamondCount);
        }
        if self.isDisplayedOnPanel != false {
            my_size += 1 + 1;
        }
        if self.primaryEffectId != 0 {
            my_size += ::protobuf::rt::int64_size(14, self.primaryEffectId);
        }
        if let Some(v) = self.giftLabelIcon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.name);
        }
        if let Some(v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.goldEffect.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.goldEffect);
        }
        if let Some(v) = self.previewImage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.giftPanelBanner.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.isBroadcastGift != false {
            my_size += 2 + 1;
        }
        if self.isEffectBefview != false {
            my_size += 2 + 1;
        }
        if self.isRandomGift != false {
            my_size += 2 + 1;
        }
        if self.isBoxGift != false {
            my_size += 2 + 1;
        }
        if self.canPutInGiftBox != false {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.describe.is_empty() {
            os.write_string(2, &self.describe)?;
        }
        if self.duration != 0 {
            os.write_int64(4, self.duration)?;
        }
        if self.id != 0 {
            os.write_int64(5, self.id)?;
        }
        if self.forLinkmic != false {
            os.write_bool(7, self.forLinkmic)?;
        }
        if self.combo != false {
            os.write_bool(10, self.combo)?;
        }
        if self.type_ != 0 {
            os.write_int32(11, self.type_)?;
        }
        if self.diamondCount != 0 {
            os.write_int32(12, self.diamondCount)?;
        }
        if self.isDisplayedOnPanel != false {
            os.write_bool(13, self.isDisplayedOnPanel)?;
        }
        if self.primaryEffectId != 0 {
            os.write_int64(14, self.primaryEffectId)?;
        }
        if let Some(v) = self.giftLabelIcon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(16, &self.name)?;
        }
        if let Some(v) = self.icon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if !self.goldEffect.is_empty() {
            os.write_string(24, &self.goldEffect)?;
        }
        if let Some(v) = self.previewImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        }
        if let Some(v) = self.giftPanelBanner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        }
        if self.isBroadcastGift != false {
            os.write_bool(49, self.isBroadcastGift)?;
        }
        if self.isEffectBefview != false {
            os.write_bool(50, self.isEffectBefview)?;
        }
        if self.isRandomGift != false {
            os.write_bool(51, self.isRandomGift)?;
        }
        if self.isBoxGift != false {
            os.write_bool(52, self.isBoxGift)?;
        }
        if self.canPutInGiftBox != false {
            os.write_bool(53, self.canPutInGiftBox)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GiftStruct {
        GiftStruct::new()
    }

    fn clear(&mut self) {
        self.image.clear();
        self.describe.clear();
        self.duration = 0;
        self.id = 0;
        self.forLinkmic = false;
        self.combo = false;
        self.type_ = 0;
        self.diamondCount = 0;
        self.isDisplayedOnPanel = false;
        self.primaryEffectId = 0;
        self.giftLabelIcon.clear();
        self.name.clear();
        self.icon.clear();
        self.goldEffect.clear();
        self.previewImage.clear();
        self.giftPanelBanner.clear();
        self.isBroadcastGift = false;
        self.isEffectBefview = false;
        self.isRandomGift = false;
        self.isBoxGift = false;
        self.canPutInGiftBox = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GiftStruct {
        static instance: GiftStruct = GiftStruct {
            image: ::protobuf::MessageField::none(),
            describe: ::std::string::String::new(),
            duration: 0,
            id: 0,
            forLinkmic: false,
            combo: false,
            type_: 0,
            diamondCount: 0,
            isDisplayedOnPanel: false,
            primaryEffectId: 0,
            giftLabelIcon: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            icon: ::protobuf::MessageField::none(),
            goldEffect: ::std::string::String::new(),
            previewImage: ::protobuf::MessageField::none(),
            giftPanelBanner: ::protobuf::MessageField::none(),
            isBroadcastGift: false,
            isEffectBefview: false,
            isRandomGift: false,
            isBoxGift: false,
            canPutInGiftBox: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GiftStruct {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GiftStruct").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GiftStruct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GiftStruct {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GiftStruct`
pub mod gift_struct {
    // @@protoc_insertion_point(message:TikTok.GiftStruct.GiftPanelBanner)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GiftPanelBanner {
        // message fields
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftPanelBanner.displayText)
        pub displayText: ::protobuf::MessageField<super::Text>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftPanelBanner.leftIcon)
        pub leftIcon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftPanelBanner.schemaUrl)
        pub schemaUrl: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftPanelBanner.bgColorValuesList)
        pub bgColorValuesList: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftPanelBanner.bannerLynxUrl)
        pub bannerLynxUrl: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.GiftStruct.GiftPanelBanner.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GiftPanelBanner {
        fn default() -> &'a GiftPanelBanner {
            <GiftPanelBanner as ::protobuf::Message>::default_instance()
        }
    }

    impl GiftPanelBanner {
        pub fn new() -> GiftPanelBanner {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Text>(
                "displayText",
                |m: &GiftPanelBanner| { &m.displayText },
                |m: &mut GiftPanelBanner| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "leftIcon",
                |m: &GiftPanelBanner| { &m.leftIcon },
                |m: &mut GiftPanelBanner| { &mut m.leftIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "schemaUrl",
                |m: &GiftPanelBanner| { &m.schemaUrl },
                |m: &mut GiftPanelBanner| { &mut m.schemaUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bgColorValuesList",
                |m: &GiftPanelBanner| { &m.bgColorValuesList },
                |m: &mut GiftPanelBanner| { &mut m.bgColorValuesList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "bannerLynxUrl",
                |m: &GiftPanelBanner| { &m.bannerLynxUrl },
                |m: &mut GiftPanelBanner| { &mut m.bannerLynxUrl },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GiftPanelBanner>(
                "GiftStruct.GiftPanelBanner",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GiftPanelBanner {
        const NAME: &'static str = "GiftPanelBanner";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.leftIcon)?;
                    },
                    26 => {
                        self.schemaUrl = is.read_string()?;
                    },
                    42 => {
                        self.bgColorValuesList.push(is.read_string()?);
                    },
                    50 => {
                        self.bannerLynxUrl = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.displayText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.leftIcon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.schemaUrl.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.schemaUrl);
            }
            for value in &self.bgColorValuesList {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            if !self.bannerLynxUrl.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.bannerLynxUrl);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.displayText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.leftIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if !self.schemaUrl.is_empty() {
                os.write_string(3, &self.schemaUrl)?;
            }
            for v in &self.bgColorValuesList {
                os.write_string(5, &v)?;
            };
            if !self.bannerLynxUrl.is_empty() {
                os.write_string(6, &self.bannerLynxUrl)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GiftPanelBanner {
            GiftPanelBanner::new()
        }

        fn clear(&mut self) {
            self.displayText.clear();
            self.leftIcon.clear();
            self.schemaUrl.clear();
            self.bgColorValuesList.clear();
            self.bannerLynxUrl.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GiftPanelBanner {
            static instance: GiftPanelBanner = GiftPanelBanner {
                displayText: ::protobuf::MessageField::none(),
                leftIcon: ::protobuf::MessageField::none(),
                schemaUrl: ::std::string::String::new(),
                bgColorValuesList: ::std::vec::Vec::new(),
                bannerLynxUrl: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GiftPanelBanner {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GiftStruct.GiftPanelBanner").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GiftPanelBanner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GiftPanelBanner {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.GiftStruct.GiftRandomEffectInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GiftRandomEffectInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftRandomEffectInfo.randomGiftPanelBanner)
        pub randomGiftPanelBanner: ::protobuf::MessageField<RandomGiftPanelBanner>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftRandomEffectInfo.effectIdsList)
        pub effectIdsList: ::std::vec::Vec<i64>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftRandomEffectInfo.hostKey)
        pub hostKey: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftRandomEffectInfo.audienceKey)
        pub audienceKey: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.GiftRandomEffectInfo.randomGiftBubble)
        pub randomGiftBubble: ::protobuf::MessageField<RandomGiftBubble>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.GiftStruct.GiftRandomEffectInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GiftRandomEffectInfo {
        fn default() -> &'a GiftRandomEffectInfo {
            <GiftRandomEffectInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl GiftRandomEffectInfo {
        pub fn new() -> GiftRandomEffectInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RandomGiftPanelBanner>(
                "randomGiftPanelBanner",
                |m: &GiftRandomEffectInfo| { &m.randomGiftPanelBanner },
                |m: &mut GiftRandomEffectInfo| { &mut m.randomGiftPanelBanner },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "effectIdsList",
                |m: &GiftRandomEffectInfo| { &m.effectIdsList },
                |m: &mut GiftRandomEffectInfo| { &mut m.effectIdsList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hostKey",
                |m: &GiftRandomEffectInfo| { &m.hostKey },
                |m: &mut GiftRandomEffectInfo| { &mut m.hostKey },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "audienceKey",
                |m: &GiftRandomEffectInfo| { &m.audienceKey },
                |m: &mut GiftRandomEffectInfo| { &mut m.audienceKey },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RandomGiftBubble>(
                "randomGiftBubble",
                |m: &GiftRandomEffectInfo| { &m.randomGiftBubble },
                |m: &mut GiftRandomEffectInfo| { &mut m.randomGiftBubble },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GiftRandomEffectInfo>(
                "GiftStruct.GiftRandomEffectInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GiftRandomEffectInfo {
        const NAME: &'static str = "GiftRandomEffectInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.randomGiftPanelBanner)?;
                    },
                    18 => {
                        is.read_repeated_packed_int64_into(&mut self.effectIdsList)?;
                    },
                    16 => {
                        self.effectIdsList.push(is.read_int64()?);
                    },
                    26 => {
                        self.hostKey = is.read_string()?;
                    },
                    34 => {
                        self.audienceKey = is.read_string()?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.randomGiftBubble)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.randomGiftPanelBanner.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.effectIdsList {
                my_size += ::protobuf::rt::int64_size(2, *value);
            };
            if !self.hostKey.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.hostKey);
            }
            if !self.audienceKey.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.audienceKey);
            }
            if let Some(v) = self.randomGiftBubble.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.randomGiftPanelBanner.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.effectIdsList {
                os.write_int64(2, *v)?;
            };
            if !self.hostKey.is_empty() {
                os.write_string(3, &self.hostKey)?;
            }
            if !self.audienceKey.is_empty() {
                os.write_string(4, &self.audienceKey)?;
            }
            if let Some(v) = self.randomGiftBubble.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GiftRandomEffectInfo {
            GiftRandomEffectInfo::new()
        }

        fn clear(&mut self) {
            self.randomGiftPanelBanner.clear();
            self.effectIdsList.clear();
            self.hostKey.clear();
            self.audienceKey.clear();
            self.randomGiftBubble.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GiftRandomEffectInfo {
            static instance: GiftRandomEffectInfo = GiftRandomEffectInfo {
                randomGiftPanelBanner: ::protobuf::MessageField::none(),
                effectIdsList: ::std::vec::Vec::new(),
                hostKey: ::std::string::String::new(),
                audienceKey: ::std::string::String::new(),
                randomGiftBubble: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GiftRandomEffectInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GiftStruct.GiftRandomEffectInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GiftRandomEffectInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GiftRandomEffectInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.GiftStruct.RandomGiftBubble)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RandomGiftBubble {
        // message fields
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftBubble.displayText)
        pub displayText: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftBubble.iconDynamicEffect)
        pub iconDynamicEffect: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.GiftStruct.RandomGiftBubble.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RandomGiftBubble {
        fn default() -> &'a RandomGiftBubble {
            <RandomGiftBubble as ::protobuf::Message>::default_instance()
        }
    }

    impl RandomGiftBubble {
        pub fn new() -> RandomGiftBubble {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "displayText",
                |m: &RandomGiftBubble| { &m.displayText },
                |m: &mut RandomGiftBubble| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "iconDynamicEffect",
                |m: &RandomGiftBubble| { &m.iconDynamicEffect },
                |m: &mut RandomGiftBubble| { &mut m.iconDynamicEffect },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RandomGiftBubble>(
                "GiftStruct.RandomGiftBubble",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RandomGiftBubble {
        const NAME: &'static str = "RandomGiftBubble";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.displayText = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.iconDynamicEffect)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.displayText.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.displayText);
            }
            if let Some(v) = self.iconDynamicEffect.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.displayText.is_empty() {
                os.write_string(1, &self.displayText)?;
            }
            if let Some(v) = self.iconDynamicEffect.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RandomGiftBubble {
            RandomGiftBubble::new()
        }

        fn clear(&mut self) {
            self.displayText.clear();
            self.iconDynamicEffect.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RandomGiftBubble {
            static instance: RandomGiftBubble = RandomGiftBubble {
                displayText: ::std::string::String::new(),
                iconDynamicEffect: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RandomGiftBubble {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GiftStruct.RandomGiftBubble").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RandomGiftBubble {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RandomGiftBubble {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.GiftStruct.RandomGiftPanelBanner)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RandomGiftPanelBanner {
        // message fields
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.bgImage)
        pub bgImage: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.shadingImage)
        pub shadingImage: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.targetNum)
        pub targetNum: i64,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.collectNum)
        pub collectNum: i64,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.displayText)
        pub displayText: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.leftIcon)
        pub leftIcon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.schemaUrl)
        pub schemaUrl: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.bgColorValuesList)
        pub bgColorValuesList: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:TikTok.GiftStruct.RandomGiftPanelBanner.round)
        pub round: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.GiftStruct.RandomGiftPanelBanner.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RandomGiftPanelBanner {
        fn default() -> &'a RandomGiftPanelBanner {
            <RandomGiftPanelBanner as ::protobuf::Message>::default_instance()
        }
    }

    impl RandomGiftPanelBanner {
        pub fn new() -> RandomGiftPanelBanner {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "bgImage",
                |m: &RandomGiftPanelBanner| { &m.bgImage },
                |m: &mut RandomGiftPanelBanner| { &mut m.bgImage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "shadingImage",
                |m: &RandomGiftPanelBanner| { &m.shadingImage },
                |m: &mut RandomGiftPanelBanner| { &mut m.shadingImage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "targetNum",
                |m: &RandomGiftPanelBanner| { &m.targetNum },
                |m: &mut RandomGiftPanelBanner| { &mut m.targetNum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "collectNum",
                |m: &RandomGiftPanelBanner| { &m.collectNum },
                |m: &mut RandomGiftPanelBanner| { &mut m.collectNum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "displayText",
                |m: &RandomGiftPanelBanner| { &m.displayText },
                |m: &mut RandomGiftPanelBanner| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "leftIcon",
                |m: &RandomGiftPanelBanner| { &m.leftIcon },
                |m: &mut RandomGiftPanelBanner| { &mut m.leftIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "schemaUrl",
                |m: &RandomGiftPanelBanner| { &m.schemaUrl },
                |m: &mut RandomGiftPanelBanner| { &mut m.schemaUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bgColorValuesList",
                |m: &RandomGiftPanelBanner| { &m.bgColorValuesList },
                |m: &mut RandomGiftPanelBanner| { &mut m.bgColorValuesList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "round",
                |m: &RandomGiftPanelBanner| { &m.round },
                |m: &mut RandomGiftPanelBanner| { &mut m.round },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RandomGiftPanelBanner>(
                "GiftStruct.RandomGiftPanelBanner",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RandomGiftPanelBanner {
        const NAME: &'static str = "RandomGiftPanelBanner";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.bgImage)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.shadingImage)?;
                    },
                    24 => {
                        self.targetNum = is.read_int64()?;
                    },
                    32 => {
                        self.collectNum = is.read_int64()?;
                    },
                    42 => {
                        self.displayText = is.read_string()?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.leftIcon)?;
                    },
                    58 => {
                        self.schemaUrl = is.read_string()?;
                    },
                    66 => {
                        self.bgColorValuesList.push(is.read_string()?);
                    },
                    72 => {
                        self.round = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.bgImage.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.shadingImage.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.targetNum != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.targetNum);
            }
            if self.collectNum != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.collectNum);
            }
            if !self.displayText.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.displayText);
            }
            if let Some(v) = self.leftIcon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.schemaUrl.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.schemaUrl);
            }
            for value in &self.bgColorValuesList {
                my_size += ::protobuf::rt::string_size(8, &value);
            };
            if self.round != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.round);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.bgImage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.shadingImage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.targetNum != 0 {
                os.write_int64(3, self.targetNum)?;
            }
            if self.collectNum != 0 {
                os.write_int64(4, self.collectNum)?;
            }
            if !self.displayText.is_empty() {
                os.write_string(5, &self.displayText)?;
            }
            if let Some(v) = self.leftIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if !self.schemaUrl.is_empty() {
                os.write_string(7, &self.schemaUrl)?;
            }
            for v in &self.bgColorValuesList {
                os.write_string(8, &v)?;
            };
            if self.round != 0 {
                os.write_int64(9, self.round)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RandomGiftPanelBanner {
            RandomGiftPanelBanner::new()
        }

        fn clear(&mut self) {
            self.bgImage.clear();
            self.shadingImage.clear();
            self.targetNum = 0;
            self.collectNum = 0;
            self.displayText.clear();
            self.leftIcon.clear();
            self.schemaUrl.clear();
            self.bgColorValuesList.clear();
            self.round = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RandomGiftPanelBanner {
            static instance: RandomGiftPanelBanner = RandomGiftPanelBanner {
                bgImage: ::protobuf::MessageField::none(),
                shadingImage: ::protobuf::MessageField::none(),
                targetNum: 0,
                collectNum: 0,
                displayText: ::std::string::String::new(),
                leftIcon: ::protobuf::MessageField::none(),
                schemaUrl: ::std::string::String::new(),
                bgColorValuesList: ::std::vec::Vec::new(),
                round: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RandomGiftPanelBanner {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GiftStruct.RandomGiftPanelBanner").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RandomGiftPanelBanner {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RandomGiftPanelBanner {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.User)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct User {
    // message fields
    // @@protoc_insertion_point(field:TikTok.User.id)
    pub id: i64,
    // @@protoc_insertion_point(field:TikTok.User.nickname)
    pub nickname: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.bioDescription)
    pub bioDescription: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.avatarThumb)
    pub avatarThumb: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.User.avatarMedium)
    pub avatarMedium: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.User.avatarLarge)
    pub avatarLarge: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.User.verified)
    pub verified: bool,
    // @@protoc_insertion_point(field:TikTok.User.status)
    pub status: i32,
    // @@protoc_insertion_point(field:TikTok.User.createTime)
    pub createTime: i64,
    // @@protoc_insertion_point(field:TikTok.User.modifyTime)
    pub modifyTime: i64,
    // @@protoc_insertion_point(field:TikTok.User.secret)
    pub secret: i32,
    // @@protoc_insertion_point(field:TikTok.User.shareQrcodeUri)
    pub shareQrcodeUri: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.badgeImageList)
    pub badgeImageList: ::std::vec::Vec<Image>,
    // @@protoc_insertion_point(field:TikTok.User.followInfo)
    pub followInfo: ::protobuf::MessageField<user::FollowInfo>,
    // @@protoc_insertion_point(field:TikTok.User.payGrade)
    pub payGrade: ::protobuf::MessageField<user::PayGrade>,
    // @@protoc_insertion_point(field:TikTok.User.fansClub)
    pub fansClub: ::protobuf::MessageField<user::FansClub>,
    // @@protoc_insertion_point(field:TikTok.User.border)
    pub border: ::protobuf::MessageField<user::Border>,
    // @@protoc_insertion_point(field:TikTok.User.specialId)
    pub specialId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.avatarBorder)
    pub avatarBorder: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.User.medal)
    pub medal: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.User.realTimeIconsList)
    pub realTimeIconsList: ::std::vec::Vec<Image>,
    // @@protoc_insertion_point(field:TikTok.User.newRealTimeIconsList)
    pub newRealTimeIconsList: ::std::vec::Vec<Image>,
    // @@protoc_insertion_point(field:TikTok.User.topVipNo)
    pub topVipNo: i64,
    // @@protoc_insertion_point(field:TikTok.User.userAttr)
    pub userAttr: ::protobuf::MessageField<user::UserAttr>,
    // @@protoc_insertion_point(field:TikTok.User.ownRoom)
    pub ownRoom: ::protobuf::MessageField<user::OwnRoom>,
    // @@protoc_insertion_point(field:TikTok.User.payScore)
    pub payScore: i64,
    // @@protoc_insertion_point(field:TikTok.User.ticketCount)
    pub ticketCount: i64,
    // @@protoc_insertion_point(field:TikTok.User.linkMicStats)
    pub linkMicStats: ::protobuf::EnumOrUnknown<super::enums::LinkmicStatus>,
    // @@protoc_insertion_point(field:TikTok.User.displayId)
    pub displayId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.withCommercePermission)
    pub withCommercePermission: bool,
    // @@protoc_insertion_point(field:TikTok.User.withFusionShopEntry)
    pub withFusionShopEntry: bool,
    // @@protoc_insertion_point(field:TikTok.User.webcastAnchorLevel)
    pub webcastAnchorLevel: ::protobuf::MessageField<user::AnchorLevel>,
    // @@protoc_insertion_point(field:TikTok.User.verifiedContent)
    pub verifiedContent: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.authorStats)
    pub authorStats: ::protobuf::MessageField<user::AuthorStats>,
    // @@protoc_insertion_point(field:TikTok.User.topFansList)
    pub topFansList: ::std::vec::Vec<User>,
    // @@protoc_insertion_point(field:TikTok.User.secUid)
    pub secUid: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.userRole)
    pub userRole: i32,
    // @@protoc_insertion_point(field:TikTok.User.activityReward)
    pub activityReward: ::protobuf::MessageField<user::ActivityInfo>,
    // @@protoc_insertion_point(field:TikTok.User.personalCard)
    pub personalCard: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.User.authenticationInfo)
    pub authenticationInfo: ::protobuf::MessageField<user::AuthenticationInfo>,
    // @@protoc_insertion_point(field:TikTok.User.mediaBadgeImageList)
    pub mediaBadgeImageList: ::std::vec::Vec<Image>,
    // @@protoc_insertion_point(field:TikTok.User.commerceWebcastConfigIdsList)
    pub commerceWebcastConfigIdsList: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:TikTok.User.borderList)
    pub borderList: ::std::vec::Vec<user::Border>,
    // @@protoc_insertion_point(field:TikTok.User.comboBadgeInfo)
    pub comboBadgeInfo: ::protobuf::MessageField<user::ComboBadgeInfo>,
    // @@protoc_insertion_point(field:TikTok.User.subscribeInfo)
    pub subscribeInfo: ::protobuf::MessageField<user::SubscribeInfo>,
    // @@protoc_insertion_point(field:TikTok.User.badgeList)
    pub badgeList: ::std::vec::Vec<BadgeStruct>,
    // @@protoc_insertion_point(field:TikTok.User.mintTypeLabelList)
    pub mintTypeLabelList: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:TikTok.User.fansClubInfo)
    pub fansClubInfo: ::protobuf::MessageField<user::FansClubInfo>,
    // @@protoc_insertion_point(field:TikTok.User.allowFindByContacts)
    pub allowFindByContacts: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowOthersDownloadVideo)
    pub allowOthersDownloadVideo: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowOthersDownloadWhenSharingVideo)
    pub allowOthersDownloadWhenSharingVideo: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowShareShowProfile)
    pub allowShareShowProfile: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowShowInGossip)
    pub allowShowInGossip: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowShowMyAction)
    pub allowShowMyAction: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowStrangeComment)
    pub allowStrangeComment: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowUnfollowerComment)
    pub allowUnfollowerComment: bool,
    // @@protoc_insertion_point(field:TikTok.User.allowUseLinkmic)
    pub allowUseLinkmic: bool,
    // @@protoc_insertion_point(field:TikTok.User.anchorLevel)
    pub anchorLevel: ::protobuf::MessageField<user::AnchorLevel>,
    // @@protoc_insertion_point(field:TikTok.User.avatarJpg)
    pub avatarJpg: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.User.bgImgUrl)
    pub bgImgUrl: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.blockStatus)
    pub blockStatus: i32,
    // @@protoc_insertion_point(field:TikTok.User.commentRestrict)
    pub commentRestrict: i32,
    // @@protoc_insertion_point(field:TikTok.User.constellation)
    pub constellation: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.disableIchat)
    pub disableIchat: i32,
    // @@protoc_insertion_point(field:TikTok.User.enableIchatImg)
    pub enableIchatImg: i64,
    // @@protoc_insertion_point(field:TikTok.User.exp)
    pub exp: i32,
    // @@protoc_insertion_point(field:TikTok.User.fanTicketCount)
    pub fanTicketCount: i64,
    // @@protoc_insertion_point(field:TikTok.User.foldStrangerChat)
    pub foldStrangerChat: bool,
    // @@protoc_insertion_point(field:TikTok.User.followStatus)
    pub followStatus: i64,
    // @@protoc_insertion_point(field:TikTok.User.ichatRestrictType)
    pub ichatRestrictType: i32,
    // @@protoc_insertion_point(field:TikTok.User.idStr)
    pub idStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.isFollower)
    pub isFollower: bool,
    // @@protoc_insertion_point(field:TikTok.User.isFollowing)
    pub isFollowing: bool,
    // @@protoc_insertion_point(field:TikTok.User.needProfileGuide)
    pub needProfileGuide: bool,
    // @@protoc_insertion_point(field:TikTok.User.payScores)
    pub payScores: i64,
    // @@protoc_insertion_point(field:TikTok.User.pushCommentStatus)
    pub pushCommentStatus: bool,
    // @@protoc_insertion_point(field:TikTok.User.pushDigg)
    pub pushDigg: bool,
    // @@protoc_insertion_point(field:TikTok.User.pushFollow)
    pub pushFollow: bool,
    // @@protoc_insertion_point(field:TikTok.User.pushFriendAction)
    pub pushFriendAction: bool,
    // @@protoc_insertion_point(field:TikTok.User.pushIchat)
    pub pushIchat: bool,
    // @@protoc_insertion_point(field:TikTok.User.pushStatus)
    pub pushStatus: bool,
    // @@protoc_insertion_point(field:TikTok.User.pushVideoPost)
    pub pushVideoPost: bool,
    // @@protoc_insertion_point(field:TikTok.User.pushVideoRecommend)
    pub pushVideoRecommend: bool,
    // @@protoc_insertion_point(field:TikTok.User.stats)
    pub stats: ::protobuf::MessageField<user::UserStats>,
    // @@protoc_insertion_point(field:TikTok.User.verifiedReason)
    pub verifiedReason: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.withCarManagementPermission)
    pub withCarManagementPermission: bool,
    // @@protoc_insertion_point(field:TikTok.User.upcomingEventList)
    pub upcomingEventList: ::std::vec::Vec<user::LiveEventInfo>,
    // @@protoc_insertion_point(field:TikTok.User.scmLabel)
    pub scmLabel: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.User.ecommerceEntrance)
    pub ecommerceEntrance: ::protobuf::MessageField<user::EcommerceEntrance>,
    // @@protoc_insertion_point(field:TikTok.User.isBlock)
    pub isBlock: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.User.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(90);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &User| { &m.id },
            |m: &mut User| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nickname",
            |m: &User| { &m.nickname },
            |m: &mut User| { &mut m.nickname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bioDescription",
            |m: &User| { &m.bioDescription },
            |m: &mut User| { &mut m.bioDescription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "avatarThumb",
            |m: &User| { &m.avatarThumb },
            |m: &mut User| { &mut m.avatarThumb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "avatarMedium",
            |m: &User| { &m.avatarMedium },
            |m: &mut User| { &mut m.avatarMedium },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "avatarLarge",
            |m: &User| { &m.avatarLarge },
            |m: &mut User| { &mut m.avatarLarge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verified",
            |m: &User| { &m.verified },
            |m: &mut User| { &mut m.verified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &User| { &m.status },
            |m: &mut User| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createTime",
            |m: &User| { &m.createTime },
            |m: &mut User| { &mut m.createTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modifyTime",
            |m: &User| { &m.modifyTime },
            |m: &mut User| { &mut m.modifyTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "secret",
            |m: &User| { &m.secret },
            |m: &mut User| { &mut m.secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shareQrcodeUri",
            |m: &User| { &m.shareQrcodeUri },
            |m: &mut User| { &mut m.shareQrcodeUri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "badgeImageList",
            |m: &User| { &m.badgeImageList },
            |m: &mut User| { &mut m.badgeImageList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::FollowInfo>(
            "followInfo",
            |m: &User| { &m.followInfo },
            |m: &mut User| { &mut m.followInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::PayGrade>(
            "payGrade",
            |m: &User| { &m.payGrade },
            |m: &mut User| { &mut m.payGrade },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::FansClub>(
            "fansClub",
            |m: &User| { &m.fansClub },
            |m: &mut User| { &mut m.fansClub },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::Border>(
            "border",
            |m: &User| { &m.border },
            |m: &mut User| { &mut m.border },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "specialId",
            |m: &User| { &m.specialId },
            |m: &mut User| { &mut m.specialId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "avatarBorder",
            |m: &User| { &m.avatarBorder },
            |m: &mut User| { &mut m.avatarBorder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "medal",
            |m: &User| { &m.medal },
            |m: &mut User| { &mut m.medal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "realTimeIconsList",
            |m: &User| { &m.realTimeIconsList },
            |m: &mut User| { &mut m.realTimeIconsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "newRealTimeIconsList",
            |m: &User| { &m.newRealTimeIconsList },
            |m: &mut User| { &mut m.newRealTimeIconsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topVipNo",
            |m: &User| { &m.topVipNo },
            |m: &mut User| { &mut m.topVipNo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::UserAttr>(
            "userAttr",
            |m: &User| { &m.userAttr },
            |m: &mut User| { &mut m.userAttr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::OwnRoom>(
            "ownRoom",
            |m: &User| { &m.ownRoom },
            |m: &mut User| { &mut m.ownRoom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payScore",
            |m: &User| { &m.payScore },
            |m: &mut User| { &mut m.payScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ticketCount",
            |m: &User| { &m.ticketCount },
            |m: &mut User| { &mut m.ticketCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkMicStats",
            |m: &User| { &m.linkMicStats },
            |m: &mut User| { &mut m.linkMicStats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "displayId",
            |m: &User| { &m.displayId },
            |m: &mut User| { &mut m.displayId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withCommercePermission",
            |m: &User| { &m.withCommercePermission },
            |m: &mut User| { &mut m.withCommercePermission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withFusionShopEntry",
            |m: &User| { &m.withFusionShopEntry },
            |m: &mut User| { &mut m.withFusionShopEntry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::AnchorLevel>(
            "webcastAnchorLevel",
            |m: &User| { &m.webcastAnchorLevel },
            |m: &mut User| { &mut m.webcastAnchorLevel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verifiedContent",
            |m: &User| { &m.verifiedContent },
            |m: &mut User| { &mut m.verifiedContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::AuthorStats>(
            "authorStats",
            |m: &User| { &m.authorStats },
            |m: &mut User| { &mut m.authorStats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "topFansList",
            |m: &User| { &m.topFansList },
            |m: &mut User| { &mut m.topFansList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "secUid",
            |m: &User| { &m.secUid },
            |m: &mut User| { &mut m.secUid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userRole",
            |m: &User| { &m.userRole },
            |m: &mut User| { &mut m.userRole },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::ActivityInfo>(
            "activityReward",
            |m: &User| { &m.activityReward },
            |m: &mut User| { &mut m.activityReward },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "personalCard",
            |m: &User| { &m.personalCard },
            |m: &mut User| { &mut m.personalCard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::AuthenticationInfo>(
            "authenticationInfo",
            |m: &User| { &m.authenticationInfo },
            |m: &mut User| { &mut m.authenticationInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mediaBadgeImageList",
            |m: &User| { &m.mediaBadgeImageList },
            |m: &mut User| { &mut m.mediaBadgeImageList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "commerceWebcastConfigIdsList",
            |m: &User| { &m.commerceWebcastConfigIdsList },
            |m: &mut User| { &mut m.commerceWebcastConfigIdsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "borderList",
            |m: &User| { &m.borderList },
            |m: &mut User| { &mut m.borderList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::ComboBadgeInfo>(
            "comboBadgeInfo",
            |m: &User| { &m.comboBadgeInfo },
            |m: &mut User| { &mut m.comboBadgeInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::SubscribeInfo>(
            "subscribeInfo",
            |m: &User| { &m.subscribeInfo },
            |m: &mut User| { &mut m.subscribeInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "badgeList",
            |m: &User| { &m.badgeList },
            |m: &mut User| { &mut m.badgeList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mintTypeLabelList",
            |m: &User| { &m.mintTypeLabelList },
            |m: &mut User| { &mut m.mintTypeLabelList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::FansClubInfo>(
            "fansClubInfo",
            |m: &User| { &m.fansClubInfo },
            |m: &mut User| { &mut m.fansClubInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowFindByContacts",
            |m: &User| { &m.allowFindByContacts },
            |m: &mut User| { &mut m.allowFindByContacts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowOthersDownloadVideo",
            |m: &User| { &m.allowOthersDownloadVideo },
            |m: &mut User| { &mut m.allowOthersDownloadVideo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowOthersDownloadWhenSharingVideo",
            |m: &User| { &m.allowOthersDownloadWhenSharingVideo },
            |m: &mut User| { &mut m.allowOthersDownloadWhenSharingVideo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowShareShowProfile",
            |m: &User| { &m.allowShareShowProfile },
            |m: &mut User| { &mut m.allowShareShowProfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowShowInGossip",
            |m: &User| { &m.allowShowInGossip },
            |m: &mut User| { &mut m.allowShowInGossip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowShowMyAction",
            |m: &User| { &m.allowShowMyAction },
            |m: &mut User| { &mut m.allowShowMyAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowStrangeComment",
            |m: &User| { &m.allowStrangeComment },
            |m: &mut User| { &mut m.allowStrangeComment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowUnfollowerComment",
            |m: &User| { &m.allowUnfollowerComment },
            |m: &mut User| { &mut m.allowUnfollowerComment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowUseLinkmic",
            |m: &User| { &m.allowUseLinkmic },
            |m: &mut User| { &mut m.allowUseLinkmic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::AnchorLevel>(
            "anchorLevel",
            |m: &User| { &m.anchorLevel },
            |m: &mut User| { &mut m.anchorLevel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "avatarJpg",
            |m: &User| { &m.avatarJpg },
            |m: &mut User| { &mut m.avatarJpg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bgImgUrl",
            |m: &User| { &m.bgImgUrl },
            |m: &mut User| { &mut m.bgImgUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockStatus",
            |m: &User| { &m.blockStatus },
            |m: &mut User| { &mut m.blockStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "commentRestrict",
            |m: &User| { &m.commentRestrict },
            |m: &mut User| { &mut m.commentRestrict },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "constellation",
            |m: &User| { &m.constellation },
            |m: &mut User| { &mut m.constellation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disableIchat",
            |m: &User| { &m.disableIchat },
            |m: &mut User| { &mut m.disableIchat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enableIchatImg",
            |m: &User| { &m.enableIchatImg },
            |m: &mut User| { &mut m.enableIchatImg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exp",
            |m: &User| { &m.exp },
            |m: &mut User| { &mut m.exp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fanTicketCount",
            |m: &User| { &m.fanTicketCount },
            |m: &mut User| { &mut m.fanTicketCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "foldStrangerChat",
            |m: &User| { &m.foldStrangerChat },
            |m: &mut User| { &mut m.foldStrangerChat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "followStatus",
            |m: &User| { &m.followStatus },
            |m: &mut User| { &mut m.followStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ichatRestrictType",
            |m: &User| { &m.ichatRestrictType },
            |m: &mut User| { &mut m.ichatRestrictType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "idStr",
            |m: &User| { &m.idStr },
            |m: &mut User| { &mut m.idStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isFollower",
            |m: &User| { &m.isFollower },
            |m: &mut User| { &mut m.isFollower },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isFollowing",
            |m: &User| { &m.isFollowing },
            |m: &mut User| { &mut m.isFollowing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "needProfileGuide",
            |m: &User| { &m.needProfileGuide },
            |m: &mut User| { &mut m.needProfileGuide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payScores",
            |m: &User| { &m.payScores },
            |m: &mut User| { &mut m.payScores },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushCommentStatus",
            |m: &User| { &m.pushCommentStatus },
            |m: &mut User| { &mut m.pushCommentStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushDigg",
            |m: &User| { &m.pushDigg },
            |m: &mut User| { &mut m.pushDigg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushFollow",
            |m: &User| { &m.pushFollow },
            |m: &mut User| { &mut m.pushFollow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushFriendAction",
            |m: &User| { &m.pushFriendAction },
            |m: &mut User| { &mut m.pushFriendAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushIchat",
            |m: &User| { &m.pushIchat },
            |m: &mut User| { &mut m.pushIchat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushStatus",
            |m: &User| { &m.pushStatus },
            |m: &mut User| { &mut m.pushStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushVideoPost",
            |m: &User| { &m.pushVideoPost },
            |m: &mut User| { &mut m.pushVideoPost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushVideoRecommend",
            |m: &User| { &m.pushVideoRecommend },
            |m: &mut User| { &mut m.pushVideoRecommend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::UserStats>(
            "stats",
            |m: &User| { &m.stats },
            |m: &mut User| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verifiedReason",
            |m: &User| { &m.verifiedReason },
            |m: &mut User| { &mut m.verifiedReason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withCarManagementPermission",
            |m: &User| { &m.withCarManagementPermission },
            |m: &mut User| { &mut m.withCarManagementPermission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "upcomingEventList",
            |m: &User| { &m.upcomingEventList },
            |m: &mut User| { &mut m.upcomingEventList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scmLabel",
            |m: &User| { &m.scmLabel },
            |m: &mut User| { &mut m.scmLabel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user::EcommerceEntrance>(
            "ecommerceEntrance",
            |m: &User| { &m.ecommerceEntrance },
            |m: &mut User| { &mut m.ecommerceEntrance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isBlock",
            |m: &User| { &m.isBlock },
            |m: &mut User| { &mut m.isBlock },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<User>(
            "User",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for User {
    const NAME: &'static str = "User";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                26 => {
                    self.nickname = is.read_string()?;
                },
                42 => {
                    self.bioDescription = is.read_string()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatarThumb)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatarMedium)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatarLarge)?;
                },
                96 => {
                    self.verified = is.read_bool()?;
                },
                120 => {
                    self.status = is.read_int32()?;
                },
                128 => {
                    self.createTime = is.read_int64()?;
                },
                136 => {
                    self.modifyTime = is.read_int64()?;
                },
                144 => {
                    self.secret = is.read_int32()?;
                },
                154 => {
                    self.shareQrcodeUri = is.read_string()?;
                },
                170 => {
                    self.badgeImageList.push(is.read_message()?);
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.followInfo)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payGrade)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fansClub)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.border)?;
                },
                210 => {
                    self.specialId = is.read_string()?;
                },
                218 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatarBorder)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.medal)?;
                },
                234 => {
                    self.realTimeIconsList.push(is.read_message()?);
                },
                242 => {
                    self.newRealTimeIconsList.push(is.read_message()?);
                },
                248 => {
                    self.topVipNo = is.read_int64()?;
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userAttr)?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ownRoom)?;
                },
                272 => {
                    self.payScore = is.read_int64()?;
                },
                280 => {
                    self.ticketCount = is.read_int64()?;
                },
                296 => {
                    self.linkMicStats = is.read_enum_or_unknown()?;
                },
                306 => {
                    self.displayId = is.read_string()?;
                },
                312 => {
                    self.withCommercePermission = is.read_bool()?;
                },
                320 => {
                    self.withFusionShopEntry = is.read_bool()?;
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webcastAnchorLevel)?;
                },
                346 => {
                    self.verifiedContent = is.read_string()?;
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authorStats)?;
                },
                362 => {
                    self.topFansList.push(is.read_message()?);
                },
                370 => {
                    self.secUid = is.read_string()?;
                },
                376 => {
                    self.userRole = is.read_int32()?;
                },
                394 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.activityReward)?;
                },
                418 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.personalCard)?;
                },
                426 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authenticationInfo)?;
                },
                458 => {
                    self.mediaBadgeImageList.push(is.read_message()?);
                },
                482 => {
                    is.read_repeated_packed_int64_into(&mut self.commerceWebcastConfigIdsList)?;
                },
                480 => {
                    self.commerceWebcastConfigIdsList.push(is.read_int64()?);
                },
                490 => {
                    self.borderList.push(is.read_message()?);
                },
                498 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.comboBadgeInfo)?;
                },
                506 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subscribeInfo)?;
                },
                514 => {
                    self.badgeList.push(is.read_message()?);
                },
                522 => {
                    is.read_repeated_packed_int64_into(&mut self.mintTypeLabelList)?;
                },
                520 => {
                    self.mintTypeLabelList.push(is.read_int64()?);
                },
                530 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fansClubInfo)?;
                },
                8016 => {
                    self.allowFindByContacts = is.read_bool()?;
                },
                8024 => {
                    self.allowOthersDownloadVideo = is.read_bool()?;
                },
                8032 => {
                    self.allowOthersDownloadWhenSharingVideo = is.read_bool()?;
                },
                8040 => {
                    self.allowShareShowProfile = is.read_bool()?;
                },
                8048 => {
                    self.allowShowInGossip = is.read_bool()?;
                },
                8056 => {
                    self.allowShowMyAction = is.read_bool()?;
                },
                8064 => {
                    self.allowStrangeComment = is.read_bool()?;
                },
                8072 => {
                    self.allowUnfollowerComment = is.read_bool()?;
                },
                8080 => {
                    self.allowUseLinkmic = is.read_bool()?;
                },
                8090 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.anchorLevel)?;
                },
                8098 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatarJpg)?;
                },
                8106 => {
                    self.bgImgUrl = is.read_string()?;
                },
                8128 => {
                    self.blockStatus = is.read_int32()?;
                },
                8136 => {
                    self.commentRestrict = is.read_int32()?;
                },
                8146 => {
                    self.constellation = is.read_string()?;
                },
                8152 => {
                    self.disableIchat = is.read_int32()?;
                },
                8160 => {
                    self.enableIchatImg = is.read_int64()?;
                },
                8168 => {
                    self.exp = is.read_int32()?;
                },
                8176 => {
                    self.fanTicketCount = is.read_int64()?;
                },
                8184 => {
                    self.foldStrangerChat = is.read_bool()?;
                },
                8192 => {
                    self.followStatus = is.read_int64()?;
                },
                8216 => {
                    self.ichatRestrictType = is.read_int32()?;
                },
                8226 => {
                    self.idStr = is.read_string()?;
                },
                8232 => {
                    self.isFollower = is.read_bool()?;
                },
                8240 => {
                    self.isFollowing = is.read_bool()?;
                },
                8248 => {
                    self.needProfileGuide = is.read_bool()?;
                },
                8256 => {
                    self.payScores = is.read_int64()?;
                },
                8264 => {
                    self.pushCommentStatus = is.read_bool()?;
                },
                8272 => {
                    self.pushDigg = is.read_bool()?;
                },
                8280 => {
                    self.pushFollow = is.read_bool()?;
                },
                8288 => {
                    self.pushFriendAction = is.read_bool()?;
                },
                8296 => {
                    self.pushIchat = is.read_bool()?;
                },
                8304 => {
                    self.pushStatus = is.read_bool()?;
                },
                8312 => {
                    self.pushVideoPost = is.read_bool()?;
                },
                8320 => {
                    self.pushVideoRecommend = is.read_bool()?;
                },
                8330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                8346 => {
                    self.verifiedReason = is.read_string()?;
                },
                8352 => {
                    self.withCarManagementPermission = is.read_bool()?;
                },
                8362 => {
                    self.upcomingEventList.push(is.read_message()?);
                },
                8370 => {
                    self.scmLabel = is.read_string()?;
                },
                8378 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ecommerceEntrance)?;
                },
                8384 => {
                    self.isBlock = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.nickname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nickname);
        }
        if !self.bioDescription.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bioDescription);
        }
        if let Some(v) = self.avatarThumb.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.avatarMedium.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.avatarLarge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.verified != false {
            my_size += 1 + 1;
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::int32_size(15, self.status);
        }
        if self.createTime != 0 {
            my_size += ::protobuf::rt::int64_size(16, self.createTime);
        }
        if self.modifyTime != 0 {
            my_size += ::protobuf::rt::int64_size(17, self.modifyTime);
        }
        if self.secret != 0 {
            my_size += ::protobuf::rt::int32_size(18, self.secret);
        }
        if !self.shareQrcodeUri.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.shareQrcodeUri);
        }
        for value in &self.badgeImageList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.followInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.payGrade.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fansClub.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.border.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.specialId.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.specialId);
        }
        if let Some(v) = self.avatarBorder.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.medal.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.realTimeIconsList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.newRealTimeIconsList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.topVipNo != 0 {
            my_size += ::protobuf::rt::int64_size(31, self.topVipNo);
        }
        if let Some(v) = self.userAttr.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ownRoom.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.payScore != 0 {
            my_size += ::protobuf::rt::int64_size(34, self.payScore);
        }
        if self.ticketCount != 0 {
            my_size += ::protobuf::rt::int64_size(35, self.ticketCount);
        }
        if self.linkMicStats != ::protobuf::EnumOrUnknown::new(super::enums::LinkmicStatus::Disable) {
            my_size += ::protobuf::rt::int32_size(37, self.linkMicStats.value());
        }
        if !self.displayId.is_empty() {
            my_size += ::protobuf::rt::string_size(38, &self.displayId);
        }
        if self.withCommercePermission != false {
            my_size += 2 + 1;
        }
        if self.withFusionShopEntry != false {
            my_size += 2 + 1;
        }
        if let Some(v) = self.webcastAnchorLevel.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.verifiedContent.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.verifiedContent);
        }
        if let Some(v) = self.authorStats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.topFansList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.secUid.is_empty() {
            my_size += ::protobuf::rt::string_size(46, &self.secUid);
        }
        if self.userRole != 0 {
            my_size += ::protobuf::rt::int32_size(47, self.userRole);
        }
        if let Some(v) = self.activityReward.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.personalCard.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.authenticationInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.mediaBadgeImageList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.commerceWebcastConfigIdsList {
            my_size += ::protobuf::rt::int64_size(60, *value);
        };
        for value in &self.borderList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.comboBadgeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subscribeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.badgeList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.mintTypeLabelList {
            my_size += ::protobuf::rt::int64_size(65, *value);
        };
        if let Some(v) = self.fansClubInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.allowFindByContacts != false {
            my_size += 2 + 1;
        }
        if self.allowOthersDownloadVideo != false {
            my_size += 2 + 1;
        }
        if self.allowOthersDownloadWhenSharingVideo != false {
            my_size += 2 + 1;
        }
        if self.allowShareShowProfile != false {
            my_size += 2 + 1;
        }
        if self.allowShowInGossip != false {
            my_size += 2 + 1;
        }
        if self.allowShowMyAction != false {
            my_size += 2 + 1;
        }
        if self.allowStrangeComment != false {
            my_size += 2 + 1;
        }
        if self.allowUnfollowerComment != false {
            my_size += 2 + 1;
        }
        if self.allowUseLinkmic != false {
            my_size += 2 + 1;
        }
        if let Some(v) = self.anchorLevel.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.avatarJpg.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.bgImgUrl.is_empty() {
            my_size += ::protobuf::rt::string_size(1013, &self.bgImgUrl);
        }
        if self.blockStatus != 0 {
            my_size += ::protobuf::rt::int32_size(1016, self.blockStatus);
        }
        if self.commentRestrict != 0 {
            my_size += ::protobuf::rt::int32_size(1017, self.commentRestrict);
        }
        if !self.constellation.is_empty() {
            my_size += ::protobuf::rt::string_size(1018, &self.constellation);
        }
        if self.disableIchat != 0 {
            my_size += ::protobuf::rt::int32_size(1019, self.disableIchat);
        }
        if self.enableIchatImg != 0 {
            my_size += ::protobuf::rt::int64_size(1020, self.enableIchatImg);
        }
        if self.exp != 0 {
            my_size += ::protobuf::rt::int32_size(1021, self.exp);
        }
        if self.fanTicketCount != 0 {
            my_size += ::protobuf::rt::int64_size(1022, self.fanTicketCount);
        }
        if self.foldStrangerChat != false {
            my_size += 2 + 1;
        }
        if self.followStatus != 0 {
            my_size += ::protobuf::rt::int64_size(1024, self.followStatus);
        }
        if self.ichatRestrictType != 0 {
            my_size += ::protobuf::rt::int32_size(1027, self.ichatRestrictType);
        }
        if !self.idStr.is_empty() {
            my_size += ::protobuf::rt::string_size(1028, &self.idStr);
        }
        if self.isFollower != false {
            my_size += 2 + 1;
        }
        if self.isFollowing != false {
            my_size += 2 + 1;
        }
        if self.needProfileGuide != false {
            my_size += 2 + 1;
        }
        if self.payScores != 0 {
            my_size += ::protobuf::rt::int64_size(1032, self.payScores);
        }
        if self.pushCommentStatus != false {
            my_size += 2 + 1;
        }
        if self.pushDigg != false {
            my_size += 2 + 1;
        }
        if self.pushFollow != false {
            my_size += 2 + 1;
        }
        if self.pushFriendAction != false {
            my_size += 2 + 1;
        }
        if self.pushIchat != false {
            my_size += 2 + 1;
        }
        if self.pushStatus != false {
            my_size += 2 + 1;
        }
        if self.pushVideoPost != false {
            my_size += 2 + 1;
        }
        if self.pushVideoRecommend != false {
            my_size += 2 + 1;
        }
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.verifiedReason.is_empty() {
            my_size += ::protobuf::rt::string_size(1043, &self.verifiedReason);
        }
        if self.withCarManagementPermission != false {
            my_size += 2 + 1;
        }
        for value in &self.upcomingEventList {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.scmLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(1046, &self.scmLabel);
        }
        if let Some(v) = self.ecommerceEntrance.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.isBlock != false {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.nickname.is_empty() {
            os.write_string(3, &self.nickname)?;
        }
        if !self.bioDescription.is_empty() {
            os.write_string(5, &self.bioDescription)?;
        }
        if let Some(v) = self.avatarThumb.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.avatarMedium.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.avatarLarge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if self.verified != false {
            os.write_bool(12, self.verified)?;
        }
        if self.status != 0 {
            os.write_int32(15, self.status)?;
        }
        if self.createTime != 0 {
            os.write_int64(16, self.createTime)?;
        }
        if self.modifyTime != 0 {
            os.write_int64(17, self.modifyTime)?;
        }
        if self.secret != 0 {
            os.write_int32(18, self.secret)?;
        }
        if !self.shareQrcodeUri.is_empty() {
            os.write_string(19, &self.shareQrcodeUri)?;
        }
        for v in &self.badgeImageList {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        if let Some(v) = self.followInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.payGrade.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.fansClub.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.border.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if !self.specialId.is_empty() {
            os.write_string(26, &self.specialId)?;
        }
        if let Some(v) = self.avatarBorder.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.medal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        for v in &self.realTimeIconsList {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        };
        for v in &self.newRealTimeIconsList {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        };
        if self.topVipNo != 0 {
            os.write_int64(31, self.topVipNo)?;
        }
        if let Some(v) = self.userAttr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.ownRoom.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if self.payScore != 0 {
            os.write_int64(34, self.payScore)?;
        }
        if self.ticketCount != 0 {
            os.write_int64(35, self.ticketCount)?;
        }
        if self.linkMicStats != ::protobuf::EnumOrUnknown::new(super::enums::LinkmicStatus::Disable) {
            os.write_enum(37, ::protobuf::EnumOrUnknown::value(&self.linkMicStats))?;
        }
        if !self.displayId.is_empty() {
            os.write_string(38, &self.displayId)?;
        }
        if self.withCommercePermission != false {
            os.write_bool(39, self.withCommercePermission)?;
        }
        if self.withFusionShopEntry != false {
            os.write_bool(40, self.withFusionShopEntry)?;
        }
        if let Some(v) = self.webcastAnchorLevel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if !self.verifiedContent.is_empty() {
            os.write_string(43, &self.verifiedContent)?;
        }
        if let Some(v) = self.authorStats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        for v in &self.topFansList {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        };
        if !self.secUid.is_empty() {
            os.write_string(46, &self.secUid)?;
        }
        if self.userRole != 0 {
            os.write_int32(47, self.userRole)?;
        }
        if let Some(v) = self.activityReward.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        }
        if let Some(v) = self.personalCard.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
        }
        if let Some(v) = self.authenticationInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
        }
        for v in &self.mediaBadgeImageList {
            ::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
        };
        for v in &self.commerceWebcastConfigIdsList {
            os.write_int64(60, *v)?;
        };
        for v in &self.borderList {
            ::protobuf::rt::write_message_field_with_cached_size(61, v, os)?;
        };
        if let Some(v) = self.comboBadgeInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(62, v, os)?;
        }
        if let Some(v) = self.subscribeInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(63, v, os)?;
        }
        for v in &self.badgeList {
            ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
        };
        for v in &self.mintTypeLabelList {
            os.write_int64(65, *v)?;
        };
        if let Some(v) = self.fansClubInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(66, v, os)?;
        }
        if self.allowFindByContacts != false {
            os.write_bool(1002, self.allowFindByContacts)?;
        }
        if self.allowOthersDownloadVideo != false {
            os.write_bool(1003, self.allowOthersDownloadVideo)?;
        }
        if self.allowOthersDownloadWhenSharingVideo != false {
            os.write_bool(1004, self.allowOthersDownloadWhenSharingVideo)?;
        }
        if self.allowShareShowProfile != false {
            os.write_bool(1005, self.allowShareShowProfile)?;
        }
        if self.allowShowInGossip != false {
            os.write_bool(1006, self.allowShowInGossip)?;
        }
        if self.allowShowMyAction != false {
            os.write_bool(1007, self.allowShowMyAction)?;
        }
        if self.allowStrangeComment != false {
            os.write_bool(1008, self.allowStrangeComment)?;
        }
        if self.allowUnfollowerComment != false {
            os.write_bool(1009, self.allowUnfollowerComment)?;
        }
        if self.allowUseLinkmic != false {
            os.write_bool(1010, self.allowUseLinkmic)?;
        }
        if let Some(v) = self.anchorLevel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1011, v, os)?;
        }
        if let Some(v) = self.avatarJpg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1012, v, os)?;
        }
        if !self.bgImgUrl.is_empty() {
            os.write_string(1013, &self.bgImgUrl)?;
        }
        if self.blockStatus != 0 {
            os.write_int32(1016, self.blockStatus)?;
        }
        if self.commentRestrict != 0 {
            os.write_int32(1017, self.commentRestrict)?;
        }
        if !self.constellation.is_empty() {
            os.write_string(1018, &self.constellation)?;
        }
        if self.disableIchat != 0 {
            os.write_int32(1019, self.disableIchat)?;
        }
        if self.enableIchatImg != 0 {
            os.write_int64(1020, self.enableIchatImg)?;
        }
        if self.exp != 0 {
            os.write_int32(1021, self.exp)?;
        }
        if self.fanTicketCount != 0 {
            os.write_int64(1022, self.fanTicketCount)?;
        }
        if self.foldStrangerChat != false {
            os.write_bool(1023, self.foldStrangerChat)?;
        }
        if self.followStatus != 0 {
            os.write_int64(1024, self.followStatus)?;
        }
        if self.ichatRestrictType != 0 {
            os.write_int32(1027, self.ichatRestrictType)?;
        }
        if !self.idStr.is_empty() {
            os.write_string(1028, &self.idStr)?;
        }
        if self.isFollower != false {
            os.write_bool(1029, self.isFollower)?;
        }
        if self.isFollowing != false {
            os.write_bool(1030, self.isFollowing)?;
        }
        if self.needProfileGuide != false {
            os.write_bool(1031, self.needProfileGuide)?;
        }
        if self.payScores != 0 {
            os.write_int64(1032, self.payScores)?;
        }
        if self.pushCommentStatus != false {
            os.write_bool(1033, self.pushCommentStatus)?;
        }
        if self.pushDigg != false {
            os.write_bool(1034, self.pushDigg)?;
        }
        if self.pushFollow != false {
            os.write_bool(1035, self.pushFollow)?;
        }
        if self.pushFriendAction != false {
            os.write_bool(1036, self.pushFriendAction)?;
        }
        if self.pushIchat != false {
            os.write_bool(1037, self.pushIchat)?;
        }
        if self.pushStatus != false {
            os.write_bool(1038, self.pushStatus)?;
        }
        if self.pushVideoPost != false {
            os.write_bool(1039, self.pushVideoPost)?;
        }
        if self.pushVideoRecommend != false {
            os.write_bool(1040, self.pushVideoRecommend)?;
        }
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1041, v, os)?;
        }
        if !self.verifiedReason.is_empty() {
            os.write_string(1043, &self.verifiedReason)?;
        }
        if self.withCarManagementPermission != false {
            os.write_bool(1044, self.withCarManagementPermission)?;
        }
        for v in &self.upcomingEventList {
            ::protobuf::rt::write_message_field_with_cached_size(1045, v, os)?;
        };
        if !self.scmLabel.is_empty() {
            os.write_string(1046, &self.scmLabel)?;
        }
        if let Some(v) = self.ecommerceEntrance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1047, v, os)?;
        }
        if self.isBlock != false {
            os.write_bool(1048, self.isBlock)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> User {
        User::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.nickname.clear();
        self.bioDescription.clear();
        self.avatarThumb.clear();
        self.avatarMedium.clear();
        self.avatarLarge.clear();
        self.verified = false;
        self.status = 0;
        self.createTime = 0;
        self.modifyTime = 0;
        self.secret = 0;
        self.shareQrcodeUri.clear();
        self.badgeImageList.clear();
        self.followInfo.clear();
        self.payGrade.clear();
        self.fansClub.clear();
        self.border.clear();
        self.specialId.clear();
        self.avatarBorder.clear();
        self.medal.clear();
        self.realTimeIconsList.clear();
        self.newRealTimeIconsList.clear();
        self.topVipNo = 0;
        self.userAttr.clear();
        self.ownRoom.clear();
        self.payScore = 0;
        self.ticketCount = 0;
        self.linkMicStats = ::protobuf::EnumOrUnknown::new(super::enums::LinkmicStatus::Disable);
        self.displayId.clear();
        self.withCommercePermission = false;
        self.withFusionShopEntry = false;
        self.webcastAnchorLevel.clear();
        self.verifiedContent.clear();
        self.authorStats.clear();
        self.topFansList.clear();
        self.secUid.clear();
        self.userRole = 0;
        self.activityReward.clear();
        self.personalCard.clear();
        self.authenticationInfo.clear();
        self.mediaBadgeImageList.clear();
        self.commerceWebcastConfigIdsList.clear();
        self.borderList.clear();
        self.comboBadgeInfo.clear();
        self.subscribeInfo.clear();
        self.badgeList.clear();
        self.mintTypeLabelList.clear();
        self.fansClubInfo.clear();
        self.allowFindByContacts = false;
        self.allowOthersDownloadVideo = false;
        self.allowOthersDownloadWhenSharingVideo = false;
        self.allowShareShowProfile = false;
        self.allowShowInGossip = false;
        self.allowShowMyAction = false;
        self.allowStrangeComment = false;
        self.allowUnfollowerComment = false;
        self.allowUseLinkmic = false;
        self.anchorLevel.clear();
        self.avatarJpg.clear();
        self.bgImgUrl.clear();
        self.blockStatus = 0;
        self.commentRestrict = 0;
        self.constellation.clear();
        self.disableIchat = 0;
        self.enableIchatImg = 0;
        self.exp = 0;
        self.fanTicketCount = 0;
        self.foldStrangerChat = false;
        self.followStatus = 0;
        self.ichatRestrictType = 0;
        self.idStr.clear();
        self.isFollower = false;
        self.isFollowing = false;
        self.needProfileGuide = false;
        self.payScores = 0;
        self.pushCommentStatus = false;
        self.pushDigg = false;
        self.pushFollow = false;
        self.pushFriendAction = false;
        self.pushIchat = false;
        self.pushStatus = false;
        self.pushVideoPost = false;
        self.pushVideoRecommend = false;
        self.stats.clear();
        self.verifiedReason.clear();
        self.withCarManagementPermission = false;
        self.upcomingEventList.clear();
        self.scmLabel.clear();
        self.ecommerceEntrance.clear();
        self.isBlock = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static User {
        static instance: User = User {
            id: 0,
            nickname: ::std::string::String::new(),
            bioDescription: ::std::string::String::new(),
            avatarThumb: ::protobuf::MessageField::none(),
            avatarMedium: ::protobuf::MessageField::none(),
            avatarLarge: ::protobuf::MessageField::none(),
            verified: false,
            status: 0,
            createTime: 0,
            modifyTime: 0,
            secret: 0,
            shareQrcodeUri: ::std::string::String::new(),
            badgeImageList: ::std::vec::Vec::new(),
            followInfo: ::protobuf::MessageField::none(),
            payGrade: ::protobuf::MessageField::none(),
            fansClub: ::protobuf::MessageField::none(),
            border: ::protobuf::MessageField::none(),
            specialId: ::std::string::String::new(),
            avatarBorder: ::protobuf::MessageField::none(),
            medal: ::protobuf::MessageField::none(),
            realTimeIconsList: ::std::vec::Vec::new(),
            newRealTimeIconsList: ::std::vec::Vec::new(),
            topVipNo: 0,
            userAttr: ::protobuf::MessageField::none(),
            ownRoom: ::protobuf::MessageField::none(),
            payScore: 0,
            ticketCount: 0,
            linkMicStats: ::protobuf::EnumOrUnknown::from_i32(0),
            displayId: ::std::string::String::new(),
            withCommercePermission: false,
            withFusionShopEntry: false,
            webcastAnchorLevel: ::protobuf::MessageField::none(),
            verifiedContent: ::std::string::String::new(),
            authorStats: ::protobuf::MessageField::none(),
            topFansList: ::std::vec::Vec::new(),
            secUid: ::std::string::String::new(),
            userRole: 0,
            activityReward: ::protobuf::MessageField::none(),
            personalCard: ::protobuf::MessageField::none(),
            authenticationInfo: ::protobuf::MessageField::none(),
            mediaBadgeImageList: ::std::vec::Vec::new(),
            commerceWebcastConfigIdsList: ::std::vec::Vec::new(),
            borderList: ::std::vec::Vec::new(),
            comboBadgeInfo: ::protobuf::MessageField::none(),
            subscribeInfo: ::protobuf::MessageField::none(),
            badgeList: ::std::vec::Vec::new(),
            mintTypeLabelList: ::std::vec::Vec::new(),
            fansClubInfo: ::protobuf::MessageField::none(),
            allowFindByContacts: false,
            allowOthersDownloadVideo: false,
            allowOthersDownloadWhenSharingVideo: false,
            allowShareShowProfile: false,
            allowShowInGossip: false,
            allowShowMyAction: false,
            allowStrangeComment: false,
            allowUnfollowerComment: false,
            allowUseLinkmic: false,
            anchorLevel: ::protobuf::MessageField::none(),
            avatarJpg: ::protobuf::MessageField::none(),
            bgImgUrl: ::std::string::String::new(),
            blockStatus: 0,
            commentRestrict: 0,
            constellation: ::std::string::String::new(),
            disableIchat: 0,
            enableIchatImg: 0,
            exp: 0,
            fanTicketCount: 0,
            foldStrangerChat: false,
            followStatus: 0,
            ichatRestrictType: 0,
            idStr: ::std::string::String::new(),
            isFollower: false,
            isFollowing: false,
            needProfileGuide: false,
            payScores: 0,
            pushCommentStatus: false,
            pushDigg: false,
            pushFollow: false,
            pushFriendAction: false,
            pushIchat: false,
            pushStatus: false,
            pushVideoPost: false,
            pushVideoRecommend: false,
            stats: ::protobuf::MessageField::none(),
            verifiedReason: ::std::string::String::new(),
            withCarManagementPermission: false,
            upcomingEventList: ::std::vec::Vec::new(),
            scmLabel: ::std::string::String::new(),
            ecommerceEntrance: ::protobuf::MessageField::none(),
            isBlock: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for User {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("User").unwrap()).clone()
    }
}

impl ::std::fmt::Display for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `User`
pub mod user {
    // @@protoc_insertion_point(message:TikTok.User.LiveEventInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LiveEventInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.eventId)
        pub eventId: i64,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.startTime)
        pub startTime: i64,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.duration)
        pub duration: i64,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.description)
        pub description: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.hasSubscribed)
        pub hasSubscribed: bool,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.isPaidEvent)
        pub isPaidEvent: bool,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.ticketAmount)
        pub ticketAmount: i64,
        // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.payMethod)
        pub payMethod: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.LiveEventInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LiveEventInfo {
        fn default() -> &'a LiveEventInfo {
            <LiveEventInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl LiveEventInfo {
        pub fn new() -> LiveEventInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "eventId",
                |m: &LiveEventInfo| { &m.eventId },
                |m: &mut LiveEventInfo| { &mut m.eventId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "startTime",
                |m: &LiveEventInfo| { &m.startTime },
                |m: &mut LiveEventInfo| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "duration",
                |m: &LiveEventInfo| { &m.duration },
                |m: &mut LiveEventInfo| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &LiveEventInfo| { &m.title },
                |m: &mut LiveEventInfo| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "description",
                |m: &LiveEventInfo| { &m.description },
                |m: &mut LiveEventInfo| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hasSubscribed",
                |m: &LiveEventInfo| { &m.hasSubscribed },
                |m: &mut LiveEventInfo| { &mut m.hasSubscribed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isPaidEvent",
                |m: &LiveEventInfo| { &m.isPaidEvent },
                |m: &mut LiveEventInfo| { &mut m.isPaidEvent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ticketAmount",
                |m: &LiveEventInfo| { &m.ticketAmount },
                |m: &mut LiveEventInfo| { &mut m.ticketAmount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "payMethod",
                |m: &LiveEventInfo| { &m.payMethod },
                |m: &mut LiveEventInfo| { &mut m.payMethod },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveEventInfo>(
                "User.LiveEventInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LiveEventInfo {
        const NAME: &'static str = "LiveEventInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eventId = is.read_int64()?;
                    },
                    16 => {
                        self.startTime = is.read_int64()?;
                    },
                    24 => {
                        self.duration = is.read_int64()?;
                    },
                    34 => {
                        self.title = is.read_string()?;
                    },
                    42 => {
                        self.description = is.read_string()?;
                    },
                    48 => {
                        self.hasSubscribed = is.read_bool()?;
                    },
                    56 => {
                        self.isPaidEvent = is.read_bool()?;
                    },
                    64 => {
                        self.ticketAmount = is.read_int64()?;
                    },
                    72 => {
                        self.payMethod = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.eventId != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.eventId);
            }
            if self.startTime != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.startTime);
            }
            if self.duration != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.duration);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.title);
            }
            if !self.description.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.description);
            }
            if self.hasSubscribed != false {
                my_size += 1 + 1;
            }
            if self.isPaidEvent != false {
                my_size += 1 + 1;
            }
            if self.ticketAmount != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.ticketAmount);
            }
            if self.payMethod != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.payMethod);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.eventId != 0 {
                os.write_int64(1, self.eventId)?;
            }
            if self.startTime != 0 {
                os.write_int64(2, self.startTime)?;
            }
            if self.duration != 0 {
                os.write_int64(3, self.duration)?;
            }
            if !self.title.is_empty() {
                os.write_string(4, &self.title)?;
            }
            if !self.description.is_empty() {
                os.write_string(5, &self.description)?;
            }
            if self.hasSubscribed != false {
                os.write_bool(6, self.hasSubscribed)?;
            }
            if self.isPaidEvent != false {
                os.write_bool(7, self.isPaidEvent)?;
            }
            if self.ticketAmount != 0 {
                os.write_int64(8, self.ticketAmount)?;
            }
            if self.payMethod != 0 {
                os.write_int64(9, self.payMethod)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LiveEventInfo {
            LiveEventInfo::new()
        }

        fn clear(&mut self) {
            self.eventId = 0;
            self.startTime = 0;
            self.duration = 0;
            self.title.clear();
            self.description.clear();
            self.hasSubscribed = false;
            self.isPaidEvent = false;
            self.ticketAmount = 0;
            self.payMethod = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LiveEventInfo {
            static instance: LiveEventInfo = LiveEventInfo {
                eventId: 0,
                startTime: 0,
                duration: 0,
                title: ::std::string::String::new(),
                description: ::std::string::String::new(),
                hasSubscribed: false,
                isPaidEvent: false,
                ticketAmount: 0,
                payMethod: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LiveEventInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.LiveEventInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LiveEventInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiveEventInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `LiveEventInfo`
    pub mod live_event_info {
        // @@protoc_insertion_point(message:TikTok.User.LiveEventInfo.WalletPackage)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct WalletPackage {
            // message fields
            // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.WalletPackage.iapId)
            pub iapId: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.LiveEventInfo.WalletPackage.usdPriceShow)
            pub usdPriceShow: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.User.LiveEventInfo.WalletPackage.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a WalletPackage {
            fn default() -> &'a WalletPackage {
                <WalletPackage as ::protobuf::Message>::default_instance()
            }
        }

        impl WalletPackage {
            pub fn new() -> WalletPackage {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "iapId",
                    |m: &WalletPackage| { &m.iapId },
                    |m: &mut WalletPackage| { &mut m.iapId },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "usdPriceShow",
                    |m: &WalletPackage| { &m.usdPriceShow },
                    |m: &mut WalletPackage| { &mut m.usdPriceShow },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WalletPackage>(
                    "User.LiveEventInfo.WalletPackage",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for WalletPackage {
            const NAME: &'static str = "WalletPackage";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.iapId = is.read_string()?;
                        },
                        18 => {
                            self.usdPriceShow = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.iapId.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.iapId);
                }
                if !self.usdPriceShow.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.usdPriceShow);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.iapId.is_empty() {
                    os.write_string(1, &self.iapId)?;
                }
                if !self.usdPriceShow.is_empty() {
                    os.write_string(2, &self.usdPriceShow)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> WalletPackage {
                WalletPackage::new()
            }

            fn clear(&mut self) {
                self.iapId.clear();
                self.usdPriceShow.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static WalletPackage {
                static instance: WalletPackage = WalletPackage {
                    iapId: ::std::string::String::new(),
                    usdPriceShow: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for WalletPackage {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("User.LiveEventInfo.WalletPackage").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for WalletPackage {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for WalletPackage {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:TikTok.User.LiveEventInfo.EventPayMethod)
        pub enum EventPayMethod {
            // @@protoc_insertion_point(enum_value:TikTok.User.LiveEventInfo.EventPayMethod.EVENTPAYMETHODINVALID)
            EVENTPAYMETHODINVALID = 0,
            // @@protoc_insertion_point(enum_value:TikTok.User.LiveEventInfo.EventPayMethod.EVENTPAYMETHODCOINS)
            EVENTPAYMETHODCOINS = 1,
            // @@protoc_insertion_point(enum_value:TikTok.User.LiveEventInfo.EventPayMethod.EVENTPAYMETHODCASH)
            EVENTPAYMETHODCASH = 2,
        }

        impl ::protobuf::Enum for EventPayMethod {
            const NAME: &'static str = "EventPayMethod";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EventPayMethod> {
                match value {
                    0 => ::std::option::Option::Some(EventPayMethod::EVENTPAYMETHODINVALID),
                    1 => ::std::option::Option::Some(EventPayMethod::EVENTPAYMETHODCOINS),
                    2 => ::std::option::Option::Some(EventPayMethod::EVENTPAYMETHODCASH),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EventPayMethod> {
                match str {
                    "EVENTPAYMETHODINVALID" => ::std::option::Option::Some(EventPayMethod::EVENTPAYMETHODINVALID),
                    "EVENTPAYMETHODCOINS" => ::std::option::Option::Some(EventPayMethod::EVENTPAYMETHODCOINS),
                    "EVENTPAYMETHODCASH" => ::std::option::Option::Some(EventPayMethod::EVENTPAYMETHODCASH),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EventPayMethod] = &[
                EventPayMethod::EVENTPAYMETHODINVALID,
                EventPayMethod::EVENTPAYMETHODCOINS,
                EventPayMethod::EVENTPAYMETHODCASH,
            ];
        }

        impl ::protobuf::EnumFull for EventPayMethod {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("User.LiveEventInfo.EventPayMethod").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for EventPayMethod {
            fn default() -> Self {
                EventPayMethod::EVENTPAYMETHODINVALID
            }
        }

        impl EventPayMethod {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EventPayMethod>("User.LiveEventInfo.EventPayMethod")
            }
        }
    }

    // @@protoc_insertion_point(message:TikTok.User.ActivityInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ActivityInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.ActivityInfo.badge)
        pub badge: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.ActivityInfo.storytag)
        pub storytag: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.ActivityInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ActivityInfo {
        fn default() -> &'a ActivityInfo {
            <ActivityInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ActivityInfo {
        pub fn new() -> ActivityInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "badge",
                |m: &ActivityInfo| { &m.badge },
                |m: &mut ActivityInfo| { &mut m.badge },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "storytag",
                |m: &ActivityInfo| { &m.storytag },
                |m: &mut ActivityInfo| { &mut m.storytag },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityInfo>(
                "User.ActivityInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ActivityInfo {
        const NAME: &'static str = "ActivityInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.badge)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.storytag)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.badge.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.storytag.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.badge.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.storytag.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ActivityInfo {
            ActivityInfo::new()
        }

        fn clear(&mut self) {
            self.badge.clear();
            self.storytag.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ActivityInfo {
            static instance: ActivityInfo = ActivityInfo {
                badge: ::protobuf::MessageField::none(),
                storytag: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ActivityInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.ActivityInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ActivityInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ActivityInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.AnchorLevel)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AnchorLevel {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.level)
        pub level: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.experience)
        pub experience: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.lowestExperienceThisLevel)
        pub lowestExperienceThisLevel: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.highestExperienceThisLevel)
        pub highestExperienceThisLevel: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.taskStartExperience)
        pub taskStartExperience: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.taskStartTime)
        pub taskStartTime: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.taskDecreaseExperience)
        pub taskDecreaseExperience: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.taskTargetExperience)
        pub taskTargetExperience: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.taskEndTime)
        pub taskEndTime: i64,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.profileDialogBg)
        pub profileDialogBg: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.profileDialogBgBack)
        pub profileDialogBgBack: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.stageLevel)
        pub stageLevel: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.AnchorLevel.smallIcon)
        pub smallIcon: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.AnchorLevel.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnchorLevel {
        fn default() -> &'a AnchorLevel {
            <AnchorLevel as ::protobuf::Message>::default_instance()
        }
    }

    impl AnchorLevel {
        pub fn new() -> AnchorLevel {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "level",
                |m: &AnchorLevel| { &m.level },
                |m: &mut AnchorLevel| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "experience",
                |m: &AnchorLevel| { &m.experience },
                |m: &mut AnchorLevel| { &mut m.experience },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lowestExperienceThisLevel",
                |m: &AnchorLevel| { &m.lowestExperienceThisLevel },
                |m: &mut AnchorLevel| { &mut m.lowestExperienceThisLevel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "highestExperienceThisLevel",
                |m: &AnchorLevel| { &m.highestExperienceThisLevel },
                |m: &mut AnchorLevel| { &mut m.highestExperienceThisLevel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "taskStartExperience",
                |m: &AnchorLevel| { &m.taskStartExperience },
                |m: &mut AnchorLevel| { &mut m.taskStartExperience },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "taskStartTime",
                |m: &AnchorLevel| { &m.taskStartTime },
                |m: &mut AnchorLevel| { &mut m.taskStartTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "taskDecreaseExperience",
                |m: &AnchorLevel| { &m.taskDecreaseExperience },
                |m: &mut AnchorLevel| { &mut m.taskDecreaseExperience },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "taskTargetExperience",
                |m: &AnchorLevel| { &m.taskTargetExperience },
                |m: &mut AnchorLevel| { &mut m.taskTargetExperience },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "taskEndTime",
                |m: &AnchorLevel| { &m.taskEndTime },
                |m: &mut AnchorLevel| { &mut m.taskEndTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "profileDialogBg",
                |m: &AnchorLevel| { &m.profileDialogBg },
                |m: &mut AnchorLevel| { &mut m.profileDialogBg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "profileDialogBgBack",
                |m: &AnchorLevel| { &m.profileDialogBgBack },
                |m: &mut AnchorLevel| { &mut m.profileDialogBgBack },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "stageLevel",
                |m: &AnchorLevel| { &m.stageLevel },
                |m: &mut AnchorLevel| { &mut m.stageLevel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "smallIcon",
                |m: &AnchorLevel| { &m.smallIcon },
                |m: &mut AnchorLevel| { &mut m.smallIcon },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnchorLevel>(
                "User.AnchorLevel",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnchorLevel {
        const NAME: &'static str = "AnchorLevel";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.level = is.read_int64()?;
                    },
                    16 => {
                        self.experience = is.read_int64()?;
                    },
                    24 => {
                        self.lowestExperienceThisLevel = is.read_int64()?;
                    },
                    32 => {
                        self.highestExperienceThisLevel = is.read_int64()?;
                    },
                    40 => {
                        self.taskStartExperience = is.read_int64()?;
                    },
                    48 => {
                        self.taskStartTime = is.read_int64()?;
                    },
                    56 => {
                        self.taskDecreaseExperience = is.read_int64()?;
                    },
                    64 => {
                        self.taskTargetExperience = is.read_int64()?;
                    },
                    72 => {
                        self.taskEndTime = is.read_int64()?;
                    },
                    82 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profileDialogBg)?;
                    },
                    90 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profileDialogBgBack)?;
                    },
                    98 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stageLevel)?;
                    },
                    106 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.smallIcon)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.level != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.level);
            }
            if self.experience != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.experience);
            }
            if self.lowestExperienceThisLevel != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.lowestExperienceThisLevel);
            }
            if self.highestExperienceThisLevel != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.highestExperienceThisLevel);
            }
            if self.taskStartExperience != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.taskStartExperience);
            }
            if self.taskStartTime != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.taskStartTime);
            }
            if self.taskDecreaseExperience != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.taskDecreaseExperience);
            }
            if self.taskTargetExperience != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.taskTargetExperience);
            }
            if self.taskEndTime != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.taskEndTime);
            }
            if let Some(v) = self.profileDialogBg.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.profileDialogBgBack.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.stageLevel.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.smallIcon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.level != 0 {
                os.write_int64(1, self.level)?;
            }
            if self.experience != 0 {
                os.write_int64(2, self.experience)?;
            }
            if self.lowestExperienceThisLevel != 0 {
                os.write_int64(3, self.lowestExperienceThisLevel)?;
            }
            if self.highestExperienceThisLevel != 0 {
                os.write_int64(4, self.highestExperienceThisLevel)?;
            }
            if self.taskStartExperience != 0 {
                os.write_int64(5, self.taskStartExperience)?;
            }
            if self.taskStartTime != 0 {
                os.write_int64(6, self.taskStartTime)?;
            }
            if self.taskDecreaseExperience != 0 {
                os.write_int64(7, self.taskDecreaseExperience)?;
            }
            if self.taskTargetExperience != 0 {
                os.write_int64(8, self.taskTargetExperience)?;
            }
            if self.taskEndTime != 0 {
                os.write_int64(9, self.taskEndTime)?;
            }
            if let Some(v) = self.profileDialogBg.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            if let Some(v) = self.profileDialogBgBack.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            }
            if let Some(v) = self.stageLevel.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if let Some(v) = self.smallIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnchorLevel {
            AnchorLevel::new()
        }

        fn clear(&mut self) {
            self.level = 0;
            self.experience = 0;
            self.lowestExperienceThisLevel = 0;
            self.highestExperienceThisLevel = 0;
            self.taskStartExperience = 0;
            self.taskStartTime = 0;
            self.taskDecreaseExperience = 0;
            self.taskTargetExperience = 0;
            self.taskEndTime = 0;
            self.profileDialogBg.clear();
            self.profileDialogBgBack.clear();
            self.stageLevel.clear();
            self.smallIcon.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnchorLevel {
            static instance: AnchorLevel = AnchorLevel {
                level: 0,
                experience: 0,
                lowestExperienceThisLevel: 0,
                highestExperienceThisLevel: 0,
                taskStartExperience: 0,
                taskStartTime: 0,
                taskDecreaseExperience: 0,
                taskTargetExperience: 0,
                taskEndTime: 0,
                profileDialogBg: ::protobuf::MessageField::none(),
                profileDialogBgBack: ::protobuf::MessageField::none(),
                stageLevel: ::protobuf::MessageField::none(),
                smallIcon: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnchorLevel {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.AnchorLevel").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnchorLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnchorLevel {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.AuthenticationInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AuthenticationInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.AuthenticationInfo.customVerify)
        pub customVerify: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.AuthenticationInfo.enterpriseVerifyReason)
        pub enterpriseVerifyReason: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.AuthenticationInfo.authenticationBadge)
        pub authenticationBadge: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.AuthenticationInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AuthenticationInfo {
        fn default() -> &'a AuthenticationInfo {
            <AuthenticationInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl AuthenticationInfo {
        pub fn new() -> AuthenticationInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "customVerify",
                |m: &AuthenticationInfo| { &m.customVerify },
                |m: &mut AuthenticationInfo| { &mut m.customVerify },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "enterpriseVerifyReason",
                |m: &AuthenticationInfo| { &m.enterpriseVerifyReason },
                |m: &mut AuthenticationInfo| { &mut m.enterpriseVerifyReason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "authenticationBadge",
                |m: &AuthenticationInfo| { &m.authenticationBadge },
                |m: &mut AuthenticationInfo| { &mut m.authenticationBadge },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthenticationInfo>(
                "User.AuthenticationInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AuthenticationInfo {
        const NAME: &'static str = "AuthenticationInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.customVerify = is.read_string()?;
                    },
                    18 => {
                        self.enterpriseVerifyReason = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.authenticationBadge)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.customVerify.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.customVerify);
            }
            if !self.enterpriseVerifyReason.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.enterpriseVerifyReason);
            }
            if let Some(v) = self.authenticationBadge.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.customVerify.is_empty() {
                os.write_string(1, &self.customVerify)?;
            }
            if !self.enterpriseVerifyReason.is_empty() {
                os.write_string(2, &self.enterpriseVerifyReason)?;
            }
            if let Some(v) = self.authenticationBadge.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AuthenticationInfo {
            AuthenticationInfo::new()
        }

        fn clear(&mut self) {
            self.customVerify.clear();
            self.enterpriseVerifyReason.clear();
            self.authenticationBadge.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AuthenticationInfo {
            static instance: AuthenticationInfo = AuthenticationInfo {
                customVerify: ::std::string::String::new(),
                enterpriseVerifyReason: ::std::string::String::new(),
                authenticationBadge: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AuthenticationInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.AuthenticationInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AuthenticationInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AuthenticationInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.AuthorStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AuthorStats {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.AuthorStats.videoTotalCount)
        pub videoTotalCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.AuthorStats.videoTotalPlayCount)
        pub videoTotalPlayCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.AuthorStats.videoTotalShareCount)
        pub videoTotalShareCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.AuthorStats.videoTotalSeriesCount)
        pub videoTotalSeriesCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.AuthorStats.varietyShowPlayCount)
        pub varietyShowPlayCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.AuthorStats.videoTotalFavoriteCount)
        pub videoTotalFavoriteCount: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.AuthorStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AuthorStats {
        fn default() -> &'a AuthorStats {
            <AuthorStats as ::protobuf::Message>::default_instance()
        }
    }

    impl AuthorStats {
        pub fn new() -> AuthorStats {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "videoTotalCount",
                |m: &AuthorStats| { &m.videoTotalCount },
                |m: &mut AuthorStats| { &mut m.videoTotalCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "videoTotalPlayCount",
                |m: &AuthorStats| { &m.videoTotalPlayCount },
                |m: &mut AuthorStats| { &mut m.videoTotalPlayCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "videoTotalShareCount",
                |m: &AuthorStats| { &m.videoTotalShareCount },
                |m: &mut AuthorStats| { &mut m.videoTotalShareCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "videoTotalSeriesCount",
                |m: &AuthorStats| { &m.videoTotalSeriesCount },
                |m: &mut AuthorStats| { &mut m.videoTotalSeriesCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "varietyShowPlayCount",
                |m: &AuthorStats| { &m.varietyShowPlayCount },
                |m: &mut AuthorStats| { &mut m.varietyShowPlayCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "videoTotalFavoriteCount",
                |m: &AuthorStats| { &m.videoTotalFavoriteCount },
                |m: &mut AuthorStats| { &mut m.videoTotalFavoriteCount },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthorStats>(
                "User.AuthorStats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AuthorStats {
        const NAME: &'static str = "AuthorStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.videoTotalCount = is.read_int64()?;
                    },
                    16 => {
                        self.videoTotalPlayCount = is.read_int64()?;
                    },
                    24 => {
                        self.videoTotalShareCount = is.read_int64()?;
                    },
                    32 => {
                        self.videoTotalSeriesCount = is.read_int64()?;
                    },
                    40 => {
                        self.varietyShowPlayCount = is.read_int64()?;
                    },
                    48 => {
                        self.videoTotalFavoriteCount = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.videoTotalCount != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.videoTotalCount);
            }
            if self.videoTotalPlayCount != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.videoTotalPlayCount);
            }
            if self.videoTotalShareCount != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.videoTotalShareCount);
            }
            if self.videoTotalSeriesCount != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.videoTotalSeriesCount);
            }
            if self.varietyShowPlayCount != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.varietyShowPlayCount);
            }
            if self.videoTotalFavoriteCount != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.videoTotalFavoriteCount);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.videoTotalCount != 0 {
                os.write_int64(1, self.videoTotalCount)?;
            }
            if self.videoTotalPlayCount != 0 {
                os.write_int64(2, self.videoTotalPlayCount)?;
            }
            if self.videoTotalShareCount != 0 {
                os.write_int64(3, self.videoTotalShareCount)?;
            }
            if self.videoTotalSeriesCount != 0 {
                os.write_int64(4, self.videoTotalSeriesCount)?;
            }
            if self.varietyShowPlayCount != 0 {
                os.write_int64(5, self.varietyShowPlayCount)?;
            }
            if self.videoTotalFavoriteCount != 0 {
                os.write_int64(6, self.videoTotalFavoriteCount)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AuthorStats {
            AuthorStats::new()
        }

        fn clear(&mut self) {
            self.videoTotalCount = 0;
            self.videoTotalPlayCount = 0;
            self.videoTotalShareCount = 0;
            self.videoTotalSeriesCount = 0;
            self.varietyShowPlayCount = 0;
            self.videoTotalFavoriteCount = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AuthorStats {
            static instance: AuthorStats = AuthorStats {
                videoTotalCount: 0,
                videoTotalPlayCount: 0,
                videoTotalShareCount: 0,
                videoTotalSeriesCount: 0,
                varietyShowPlayCount: 0,
                videoTotalFavoriteCount: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AuthorStats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.AuthorStats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AuthorStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AuthorStats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.Border)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Border {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.Border.icon)
        pub icon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.Border.level)
        pub level: i64,
        // @@protoc_insertion_point(field:TikTok.User.Border.source)
        pub source: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.Border.profileDecorationRibbon)
        pub profileDecorationRibbon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.Border.avatarBackgroundColor)
        pub avatarBackgroundColor: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.Border.avatarBackgroundBorderColor)
        pub avatarBackgroundBorderColor: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.Border.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Border {
        fn default() -> &'a Border {
            <Border as ::protobuf::Message>::default_instance()
        }
    }

    impl Border {
        pub fn new() -> Border {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "icon",
                |m: &Border| { &m.icon },
                |m: &mut Border| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "level",
                |m: &Border| { &m.level },
                |m: &mut Border| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "source",
                |m: &Border| { &m.source },
                |m: &mut Border| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "profileDecorationRibbon",
                |m: &Border| { &m.profileDecorationRibbon },
                |m: &mut Border| { &mut m.profileDecorationRibbon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "avatarBackgroundColor",
                |m: &Border| { &m.avatarBackgroundColor },
                |m: &mut Border| { &mut m.avatarBackgroundColor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "avatarBackgroundBorderColor",
                |m: &Border| { &m.avatarBackgroundBorderColor },
                |m: &mut Border| { &mut m.avatarBackgroundBorderColor },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Border>(
                "User.Border",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Border {
        const NAME: &'static str = "Border";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                    },
                    16 => {
                        self.level = is.read_int64()?;
                    },
                    26 => {
                        self.source = is.read_string()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profileDecorationRibbon)?;
                    },
                    58 => {
                        self.avatarBackgroundColor = is.read_string()?;
                    },
                    66 => {
                        self.avatarBackgroundBorderColor = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.icon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.level != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.level);
            }
            if !self.source.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.source);
            }
            if let Some(v) = self.profileDecorationRibbon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.avatarBackgroundColor.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.avatarBackgroundColor);
            }
            if !self.avatarBackgroundBorderColor.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.avatarBackgroundBorderColor);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.icon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.level != 0 {
                os.write_int64(2, self.level)?;
            }
            if !self.source.is_empty() {
                os.write_string(3, &self.source)?;
            }
            if let Some(v) = self.profileDecorationRibbon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if !self.avatarBackgroundColor.is_empty() {
                os.write_string(7, &self.avatarBackgroundColor)?;
            }
            if !self.avatarBackgroundBorderColor.is_empty() {
                os.write_string(8, &self.avatarBackgroundBorderColor)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Border {
            Border::new()
        }

        fn clear(&mut self) {
            self.icon.clear();
            self.level = 0;
            self.source.clear();
            self.profileDecorationRibbon.clear();
            self.avatarBackgroundColor.clear();
            self.avatarBackgroundBorderColor.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Border {
            static instance: Border = Border {
                icon: ::protobuf::MessageField::none(),
                level: 0,
                source: ::std::string::String::new(),
                profileDecorationRibbon: ::protobuf::MessageField::none(),
                avatarBackgroundColor: ::std::string::String::new(),
                avatarBackgroundBorderColor: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Border {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.Border").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Border {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Border {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.ComboBadgeInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ComboBadgeInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.ComboBadgeInfo.icon)
        pub icon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.ComboBadgeInfo.comboCount)
        pub comboCount: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.ComboBadgeInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ComboBadgeInfo {
        fn default() -> &'a ComboBadgeInfo {
            <ComboBadgeInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ComboBadgeInfo {
        pub fn new() -> ComboBadgeInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "icon",
                |m: &ComboBadgeInfo| { &m.icon },
                |m: &mut ComboBadgeInfo| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "comboCount",
                |m: &ComboBadgeInfo| { &m.comboCount },
                |m: &mut ComboBadgeInfo| { &mut m.comboCount },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComboBadgeInfo>(
                "User.ComboBadgeInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ComboBadgeInfo {
        const NAME: &'static str = "ComboBadgeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                    },
                    16 => {
                        self.comboCount = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.icon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.comboCount != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.comboCount);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.icon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.comboCount != 0 {
                os.write_int64(2, self.comboCount)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ComboBadgeInfo {
            ComboBadgeInfo::new()
        }

        fn clear(&mut self) {
            self.icon.clear();
            self.comboCount = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ComboBadgeInfo {
            static instance: ComboBadgeInfo = ComboBadgeInfo {
                icon: ::protobuf::MessageField::none(),
                comboCount: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ComboBadgeInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.ComboBadgeInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ComboBadgeInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ComboBadgeInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.EcommerceEntrance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EcommerceEntrance {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.entranceType)
        pub entranceType: ::protobuf::EnumOrUnknown<ecommerce_entrance::EntranceType>,
        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.creatorType)
        pub creatorType: ::protobuf::EnumOrUnknown<ecommerce_entrance::CreatorType>,
        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.schema)
        pub schema: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.shopEntranceInfo)
        pub shopEntranceInfo: ::protobuf::MessageField<ecommerce_entrance::ShopEntranceInfo>,
        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.showcaseEntranceInfo)
        pub showcaseEntranceInfo: ::protobuf::MessageField<ecommerce_entrance::ShowcaseEntranceInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.EcommerceEntrance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EcommerceEntrance {
        fn default() -> &'a EcommerceEntrance {
            <EcommerceEntrance as ::protobuf::Message>::default_instance()
        }
    }

    impl EcommerceEntrance {
        pub fn new() -> EcommerceEntrance {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "entranceType",
                |m: &EcommerceEntrance| { &m.entranceType },
                |m: &mut EcommerceEntrance| { &mut m.entranceType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "creatorType",
                |m: &EcommerceEntrance| { &m.creatorType },
                |m: &mut EcommerceEntrance| { &mut m.creatorType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "schema",
                |m: &EcommerceEntrance| { &m.schema },
                |m: &mut EcommerceEntrance| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ecommerce_entrance::ShopEntranceInfo>(
                "shopEntranceInfo",
                |m: &EcommerceEntrance| { &m.shopEntranceInfo },
                |m: &mut EcommerceEntrance| { &mut m.shopEntranceInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ecommerce_entrance::ShowcaseEntranceInfo>(
                "showcaseEntranceInfo",
                |m: &EcommerceEntrance| { &m.showcaseEntranceInfo },
                |m: &mut EcommerceEntrance| { &mut m.showcaseEntranceInfo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EcommerceEntrance>(
                "User.EcommerceEntrance",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EcommerceEntrance {
        const NAME: &'static str = "EcommerceEntrance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entranceType = is.read_enum_or_unknown()?;
                    },
                    16 => {
                        self.creatorType = is.read_enum_or_unknown()?;
                    },
                    26 => {
                        self.schema = is.read_string()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.shopEntranceInfo)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.showcaseEntranceInfo)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.entranceType != ::protobuf::EnumOrUnknown::new(ecommerce_entrance::EntranceType::PROFILE) {
                my_size += ::protobuf::rt::int32_size(1, self.entranceType.value());
            }
            if self.creatorType != ::protobuf::EnumOrUnknown::new(ecommerce_entrance::CreatorType::UNDEFINED) {
                my_size += ::protobuf::rt::int32_size(2, self.creatorType.value());
            }
            if !self.schema.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.schema);
            }
            if let Some(v) = self.shopEntranceInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.showcaseEntranceInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.entranceType != ::protobuf::EnumOrUnknown::new(ecommerce_entrance::EntranceType::PROFILE) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.entranceType))?;
            }
            if self.creatorType != ::protobuf::EnumOrUnknown::new(ecommerce_entrance::CreatorType::UNDEFINED) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.creatorType))?;
            }
            if !self.schema.is_empty() {
                os.write_string(3, &self.schema)?;
            }
            if let Some(v) = self.shopEntranceInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.showcaseEntranceInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EcommerceEntrance {
            EcommerceEntrance::new()
        }

        fn clear(&mut self) {
            self.entranceType = ::protobuf::EnumOrUnknown::new(ecommerce_entrance::EntranceType::PROFILE);
            self.creatorType = ::protobuf::EnumOrUnknown::new(ecommerce_entrance::CreatorType::UNDEFINED);
            self.schema.clear();
            self.shopEntranceInfo.clear();
            self.showcaseEntranceInfo.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EcommerceEntrance {
            static instance: EcommerceEntrance = EcommerceEntrance {
                entranceType: ::protobuf::EnumOrUnknown::from_i32(0),
                creatorType: ::protobuf::EnumOrUnknown::from_i32(0),
                schema: ::std::string::String::new(),
                shopEntranceInfo: ::protobuf::MessageField::none(),
                showcaseEntranceInfo: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EcommerceEntrance {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.EcommerceEntrance").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EcommerceEntrance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EcommerceEntrance {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `EcommerceEntrance`
    pub mod ecommerce_entrance {
        // @@protoc_insertion_point(message:TikTok.User.EcommerceEntrance.ShopEntranceInfo)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ShopEntranceInfo {
            // message fields
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.shopId)
            pub shopId: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.shopName)
            pub shopName: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.shopRating)
            pub shopRating: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.storeLabel)
            pub storeLabel: ::protobuf::MessageField<shop_entrance_info::StoreLabel>,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.formatSoldCount)
            pub formatSoldCount: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.soldCount)
            pub soldCount: i64,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.expRatePercentile)
            pub expRatePercentile: i32,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.expRateTopDisplay)
            pub expRateTopDisplay: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.rateDisplayStyle)
            pub rateDisplayStyle: i32,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.showRateNotApplicable)
            pub showRateNotApplicable: bool,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ShopEntranceInfo {
            fn default() -> &'a ShopEntranceInfo {
                <ShopEntranceInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl ShopEntranceInfo {
            pub fn new() -> ShopEntranceInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(10);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "shopId",
                    |m: &ShopEntranceInfo| { &m.shopId },
                    |m: &mut ShopEntranceInfo| { &mut m.shopId },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "shopName",
                    |m: &ShopEntranceInfo| { &m.shopName },
                    |m: &mut ShopEntranceInfo| { &mut m.shopName },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "shopRating",
                    |m: &ShopEntranceInfo| { &m.shopRating },
                    |m: &mut ShopEntranceInfo| { &mut m.shopRating },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, shop_entrance_info::StoreLabel>(
                    "storeLabel",
                    |m: &ShopEntranceInfo| { &m.storeLabel },
                    |m: &mut ShopEntranceInfo| { &mut m.storeLabel },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "formatSoldCount",
                    |m: &ShopEntranceInfo| { &m.formatSoldCount },
                    |m: &mut ShopEntranceInfo| { &mut m.formatSoldCount },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "soldCount",
                    |m: &ShopEntranceInfo| { &m.soldCount },
                    |m: &mut ShopEntranceInfo| { &mut m.soldCount },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "expRatePercentile",
                    |m: &ShopEntranceInfo| { &m.expRatePercentile },
                    |m: &mut ShopEntranceInfo| { &mut m.expRatePercentile },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "expRateTopDisplay",
                    |m: &ShopEntranceInfo| { &m.expRateTopDisplay },
                    |m: &mut ShopEntranceInfo| { &mut m.expRateTopDisplay },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "rateDisplayStyle",
                    |m: &ShopEntranceInfo| { &m.rateDisplayStyle },
                    |m: &mut ShopEntranceInfo| { &mut m.rateDisplayStyle },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "showRateNotApplicable",
                    |m: &ShopEntranceInfo| { &m.showRateNotApplicable },
                    |m: &mut ShopEntranceInfo| { &mut m.showRateNotApplicable },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShopEntranceInfo>(
                    "User.EcommerceEntrance.ShopEntranceInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ShopEntranceInfo {
            const NAME: &'static str = "ShopEntranceInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.shopId = is.read_string()?;
                        },
                        18 => {
                            self.shopName = is.read_string()?;
                        },
                        26 => {
                            self.shopRating = is.read_string()?;
                        },
                        34 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.storeLabel)?;
                        },
                        42 => {
                            self.formatSoldCount = is.read_string()?;
                        },
                        48 => {
                            self.soldCount = is.read_int64()?;
                        },
                        56 => {
                            self.expRatePercentile = is.read_int32()?;
                        },
                        66 => {
                            self.expRateTopDisplay = is.read_string()?;
                        },
                        72 => {
                            self.rateDisplayStyle = is.read_int32()?;
                        },
                        80 => {
                            self.showRateNotApplicable = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.shopId.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.shopId);
                }
                if !self.shopName.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.shopName);
                }
                if !self.shopRating.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.shopRating);
                }
                if let Some(v) = self.storeLabel.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if !self.formatSoldCount.is_empty() {
                    my_size += ::protobuf::rt::string_size(5, &self.formatSoldCount);
                }
                if self.soldCount != 0 {
                    my_size += ::protobuf::rt::int64_size(6, self.soldCount);
                }
                if self.expRatePercentile != 0 {
                    my_size += ::protobuf::rt::int32_size(7, self.expRatePercentile);
                }
                if !self.expRateTopDisplay.is_empty() {
                    my_size += ::protobuf::rt::string_size(8, &self.expRateTopDisplay);
                }
                if self.rateDisplayStyle != 0 {
                    my_size += ::protobuf::rt::int32_size(9, self.rateDisplayStyle);
                }
                if self.showRateNotApplicable != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.shopId.is_empty() {
                    os.write_string(1, &self.shopId)?;
                }
                if !self.shopName.is_empty() {
                    os.write_string(2, &self.shopName)?;
                }
                if !self.shopRating.is_empty() {
                    os.write_string(3, &self.shopRating)?;
                }
                if let Some(v) = self.storeLabel.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                }
                if !self.formatSoldCount.is_empty() {
                    os.write_string(5, &self.formatSoldCount)?;
                }
                if self.soldCount != 0 {
                    os.write_int64(6, self.soldCount)?;
                }
                if self.expRatePercentile != 0 {
                    os.write_int32(7, self.expRatePercentile)?;
                }
                if !self.expRateTopDisplay.is_empty() {
                    os.write_string(8, &self.expRateTopDisplay)?;
                }
                if self.rateDisplayStyle != 0 {
                    os.write_int32(9, self.rateDisplayStyle)?;
                }
                if self.showRateNotApplicable != false {
                    os.write_bool(10, self.showRateNotApplicable)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ShopEntranceInfo {
                ShopEntranceInfo::new()
            }

            fn clear(&mut self) {
                self.shopId.clear();
                self.shopName.clear();
                self.shopRating.clear();
                self.storeLabel.clear();
                self.formatSoldCount.clear();
                self.soldCount = 0;
                self.expRatePercentile = 0;
                self.expRateTopDisplay.clear();
                self.rateDisplayStyle = 0;
                self.showRateNotApplicable = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ShopEntranceInfo {
                static instance: ShopEntranceInfo = ShopEntranceInfo {
                    shopId: ::std::string::String::new(),
                    shopName: ::std::string::String::new(),
                    shopRating: ::std::string::String::new(),
                    storeLabel: ::protobuf::MessageField::none(),
                    formatSoldCount: ::std::string::String::new(),
                    soldCount: 0,
                    expRatePercentile: 0,
                    expRateTopDisplay: ::std::string::String::new(),
                    rateDisplayStyle: 0,
                    showRateNotApplicable: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ShopEntranceInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("User.EcommerceEntrance.ShopEntranceInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ShopEntranceInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ShopEntranceInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ShopEntranceInfo`
        pub mod shop_entrance_info {
            // @@protoc_insertion_point(message:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct StoreLabel {
                // message fields
                // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.officialLabel)
                pub officialLabel: ::protobuf::MessageField<store_label::StoreOfficialLabel>,
                // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.isBytemall)
                pub isBytemall: bool,
                // special fields
                // @@protoc_insertion_point(special_field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a StoreLabel {
                fn default() -> &'a StoreLabel {
                    <StoreLabel as ::protobuf::Message>::default_instance()
                }
            }

            impl StoreLabel {
                pub fn new() -> StoreLabel {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(2);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, store_label::StoreOfficialLabel>(
                        "officialLabel",
                        |m: &StoreLabel| { &m.officialLabel },
                        |m: &mut StoreLabel| { &mut m.officialLabel },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "isBytemall",
                        |m: &StoreLabel| { &m.isBytemall },
                        |m: &mut StoreLabel| { &mut m.isBytemall },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StoreLabel>(
                        "User.EcommerceEntrance.ShopEntranceInfo.StoreLabel",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for StoreLabel {
                const NAME: &'static str = "StoreLabel";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                ::protobuf::rt::read_singular_message_into_field(is, &mut self.officialLabel)?;
                            },
                            16 => {
                                self.isBytemall = is.read_bool()?;
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.officialLabel.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    if self.isBytemall != false {
                        my_size += 1 + 1;
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.officialLabel.as_ref() {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    }
                    if self.isBytemall != false {
                        os.write_bool(2, self.isBytemall)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> StoreLabel {
                    StoreLabel::new()
                }

                fn clear(&mut self) {
                    self.officialLabel.clear();
                    self.isBytemall = false;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static StoreLabel {
                    static instance: StoreLabel = StoreLabel {
                        officialLabel: ::protobuf::MessageField::none(),
                        isBytemall: false,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for StoreLabel {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("User.EcommerceEntrance.ShopEntranceInfo.StoreLabel").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for StoreLabel {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for StoreLabel {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `StoreLabel`
            pub mod store_label {
                // @@protoc_insertion_point(message:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct StoreOfficialLabel {
                    // message fields
                    // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.labelImageLight)
                    pub labelImageLight: ::protobuf::MessageField<store_official_label::ShopLabelImage>,
                    // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.labelImageDark)
                    pub labelImageDark: ::protobuf::MessageField<store_official_label::ShopLabelImage>,
                    // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.labelType)
                    pub labelType: i64,
                    // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.labelTypeStr)
                    pub labelTypeStr: ::std::string::String,
                    // special fields
                    // @@protoc_insertion_point(special_field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.special_fields)
                    pub special_fields: ::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a StoreOfficialLabel {
                    fn default() -> &'a StoreOfficialLabel {
                        <StoreOfficialLabel as ::protobuf::Message>::default_instance()
                    }
                }

                impl StoreOfficialLabel {
                    pub fn new() -> StoreOfficialLabel {
                        ::std::default::Default::default()
                    }

                    pub(in super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                        let mut fields = ::std::vec::Vec::with_capacity(4);
                        let mut oneofs = ::std::vec::Vec::with_capacity(0);
                        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, store_official_label::ShopLabelImage>(
                            "labelImageLight",
                            |m: &StoreOfficialLabel| { &m.labelImageLight },
                            |m: &mut StoreOfficialLabel| { &mut m.labelImageLight },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, store_official_label::ShopLabelImage>(
                            "labelImageDark",
                            |m: &StoreOfficialLabel| { &m.labelImageDark },
                            |m: &mut StoreOfficialLabel| { &mut m.labelImageDark },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                            "labelType",
                            |m: &StoreOfficialLabel| { &m.labelType },
                            |m: &mut StoreOfficialLabel| { &mut m.labelType },
                        ));
                        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                            "labelTypeStr",
                            |m: &StoreOfficialLabel| { &m.labelTypeStr },
                            |m: &mut StoreOfficialLabel| { &mut m.labelTypeStr },
                        ));
                        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StoreOfficialLabel>(
                            "User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel",
                            fields,
                            oneofs,
                        )
                    }
                }

                impl ::protobuf::Message for StoreOfficialLabel {
                    const NAME: &'static str = "StoreOfficialLabel";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => {
                                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelImageLight)?;
                                },
                                18 => {
                                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelImageDark)?;
                                },
                                24 => {
                                    self.labelType = is.read_int64()?;
                                },
                                34 => {
                                    self.labelTypeStr = is.read_string()?;
                                },
                                tag => {
                                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let Some(v) = self.labelImageLight.as_ref() {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        }
                        if let Some(v) = self.labelImageDark.as_ref() {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        }
                        if self.labelType != 0 {
                            my_size += ::protobuf::rt::int64_size(3, self.labelType);
                        }
                        if !self.labelTypeStr.is_empty() {
                            my_size += ::protobuf::rt::string_size(4, &self.labelTypeStr);
                        }
                        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                        if let Some(v) = self.labelImageLight.as_ref() {
                            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                        }
                        if let Some(v) = self.labelImageDark.as_ref() {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        }
                        if self.labelType != 0 {
                            os.write_int64(3, self.labelType)?;
                        }
                        if !self.labelTypeStr.is_empty() {
                            os.write_string(4, &self.labelTypeStr)?;
                        }
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> StoreOfficialLabel {
                        StoreOfficialLabel::new()
                    }

                    fn clear(&mut self) {
                        self.labelImageLight.clear();
                        self.labelImageDark.clear();
                        self.labelType = 0;
                        self.labelTypeStr.clear();
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static StoreOfficialLabel {
                        static instance: StoreOfficialLabel = StoreOfficialLabel {
                            labelImageLight: ::protobuf::MessageField::none(),
                            labelImageDark: ::protobuf::MessageField::none(),
                            labelType: 0,
                            labelTypeStr: ::std::string::String::new(),
                            special_fields: ::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                impl ::protobuf::MessageFull for StoreOfficialLabel {
                    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().message_by_package_relative_name("User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel").unwrap()).clone()
                    }
                }

                impl ::std::fmt::Display for StoreOfficialLabel {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                        ::protobuf::text_format::fmt(self, f)
                    }
                }

                impl ::protobuf::reflect::ProtobufValue for StoreOfficialLabel {
                    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                }

                /// Nested message and enums of message `StoreOfficialLabel`
                pub mod store_official_label {
                    // @@protoc_insertion_point(message:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage)
                    #[derive(PartialEq,Clone,Default,Debug)]
                    pub struct ShopLabelImage {
                        // message fields
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.height)
                        pub height: i32,
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.width)
                        pub width: i32,
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.minetype)
                        pub minetype: ::std::string::String,
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.thumbUri)
                        pub thumbUri: ::std::string::String,
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.thumbUriList)
                        pub thumbUriList: ::std::vec::Vec<::std::string::String>,
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.uri)
                        pub uri: ::std::string::String,
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.urlList)
                        pub urlList: ::std::vec::Vec<::std::string::String>,
                        // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.color)
                        pub color: ::std::string::String,
                        // special fields
                        // @@protoc_insertion_point(special_field:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage.special_fields)
                        pub special_fields: ::protobuf::SpecialFields,
                    }

                    impl<'a> ::std::default::Default for &'a ShopLabelImage {
                        fn default() -> &'a ShopLabelImage {
                            <ShopLabelImage as ::protobuf::Message>::default_instance()
                        }
                    }

                    impl ShopLabelImage {
                        pub fn new() -> ShopLabelImage {
                            ::std::default::Default::default()
                        }

                        pub(in super::super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                            let mut fields = ::std::vec::Vec::with_capacity(8);
                            let mut oneofs = ::std::vec::Vec::with_capacity(0);
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "height",
                                |m: &ShopLabelImage| { &m.height },
                                |m: &mut ShopLabelImage| { &mut m.height },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "width",
                                |m: &ShopLabelImage| { &m.width },
                                |m: &mut ShopLabelImage| { &mut m.width },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "minetype",
                                |m: &ShopLabelImage| { &m.minetype },
                                |m: &mut ShopLabelImage| { &mut m.minetype },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "thumbUri",
                                |m: &ShopLabelImage| { &m.thumbUri },
                                |m: &mut ShopLabelImage| { &mut m.thumbUri },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                                "thumbUriList",
                                |m: &ShopLabelImage| { &m.thumbUriList },
                                |m: &mut ShopLabelImage| { &mut m.thumbUriList },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "uri",
                                |m: &ShopLabelImage| { &m.uri },
                                |m: &mut ShopLabelImage| { &mut m.uri },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                                "urlList",
                                |m: &ShopLabelImage| { &m.urlList },
                                |m: &mut ShopLabelImage| { &mut m.urlList },
                            ));
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "color",
                                |m: &ShopLabelImage| { &m.color },
                                |m: &mut ShopLabelImage| { &mut m.color },
                            ));
                            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShopLabelImage>(
                                "User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage",
                                fields,
                                oneofs,
                            )
                        }
                    }

                    impl ::protobuf::Message for ShopLabelImage {
                        const NAME: &'static str = "ShopLabelImage";

                        fn is_initialized(&self) -> bool {
                            true
                        }

                        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    8 => {
                                        self.height = is.read_int32()?;
                                    },
                                    16 => {
                                        self.width = is.read_int32()?;
                                    },
                                    26 => {
                                        self.minetype = is.read_string()?;
                                    },
                                    34 => {
                                        self.thumbUri = is.read_string()?;
                                    },
                                    42 => {
                                        self.thumbUriList.push(is.read_string()?);
                                    },
                                    50 => {
                                        self.uri = is.read_string()?;
                                    },
                                    58 => {
                                        self.urlList.push(is.read_string()?);
                                    },
                                    66 => {
                                        self.color = is.read_string()?;
                                    },
                                    tag => {
                                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                    },
                                };
                            }
                            ::std::result::Result::Ok(())
                        }

                        // Compute sizes of nested messages
                        #[allow(unused_variables)]
                        fn compute_size(&self) -> u64 {
                            let mut my_size = 0;
                            if self.height != 0 {
                                my_size += ::protobuf::rt::int32_size(1, self.height);
                            }
                            if self.width != 0 {
                                my_size += ::protobuf::rt::int32_size(2, self.width);
                            }
                            if !self.minetype.is_empty() {
                                my_size += ::protobuf::rt::string_size(3, &self.minetype);
                            }
                            if !self.thumbUri.is_empty() {
                                my_size += ::protobuf::rt::string_size(4, &self.thumbUri);
                            }
                            for value in &self.thumbUriList {
                                my_size += ::protobuf::rt::string_size(5, &value);
                            };
                            if !self.uri.is_empty() {
                                my_size += ::protobuf::rt::string_size(6, &self.uri);
                            }
                            for value in &self.urlList {
                                my_size += ::protobuf::rt::string_size(7, &value);
                            };
                            if !self.color.is_empty() {
                                my_size += ::protobuf::rt::string_size(8, &self.color);
                            }
                            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                            self.special_fields.cached_size().set(my_size as u32);
                            my_size
                        }

                        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                            if self.height != 0 {
                                os.write_int32(1, self.height)?;
                            }
                            if self.width != 0 {
                                os.write_int32(2, self.width)?;
                            }
                            if !self.minetype.is_empty() {
                                os.write_string(3, &self.minetype)?;
                            }
                            if !self.thumbUri.is_empty() {
                                os.write_string(4, &self.thumbUri)?;
                            }
                            for v in &self.thumbUriList {
                                os.write_string(5, &v)?;
                            };
                            if !self.uri.is_empty() {
                                os.write_string(6, &self.uri)?;
                            }
                            for v in &self.urlList {
                                os.write_string(7, &v)?;
                            };
                            if !self.color.is_empty() {
                                os.write_string(8, &self.color)?;
                            }
                            os.write_unknown_fields(self.special_fields.unknown_fields())?;
                            ::std::result::Result::Ok(())
                        }

                        fn special_fields(&self) -> &::protobuf::SpecialFields {
                            &self.special_fields
                        }

                        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                            &mut self.special_fields
                        }

                        fn new() -> ShopLabelImage {
                            ShopLabelImage::new()
                        }

                        fn clear(&mut self) {
                            self.height = 0;
                            self.width = 0;
                            self.minetype.clear();
                            self.thumbUri.clear();
                            self.thumbUriList.clear();
                            self.uri.clear();
                            self.urlList.clear();
                            self.color.clear();
                            self.special_fields.clear();
                        }

                        fn default_instance() -> &'static ShopLabelImage {
                            static instance: ShopLabelImage = ShopLabelImage {
                                height: 0,
                                width: 0,
                                minetype: ::std::string::String::new(),
                                thumbUri: ::std::string::String::new(),
                                thumbUriList: ::std::vec::Vec::new(),
                                uri: ::std::string::String::new(),
                                urlList: ::std::vec::Vec::new(),
                                color: ::std::string::String::new(),
                                special_fields: ::protobuf::SpecialFields::new(),
                            };
                            &instance
                        }
                    }

                    impl ::protobuf::MessageFull for ShopLabelImage {
                        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                            descriptor.get(|| super::super::super::super::super::file_descriptor().message_by_package_relative_name("User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel.ShopLabelImage").unwrap()).clone()
                        }
                    }

                    impl ::std::fmt::Display for ShopLabelImage {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            ::protobuf::text_format::fmt(self, f)
                        }
                    }

                    impl ::protobuf::reflect::ProtobufValue for ShopLabelImage {
                        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                    }
                }

                #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
                // @@protoc_insertion_point(enum:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType)
                pub enum StoreBrandLabelType {
                    // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType.NONE)
                    NONE = 0,
                    // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType.OFFICIAL)
                    OFFICIAL = 1,
                    // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType.AUTHORIZED)
                    AUTHORIZED = 2,
                    // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType.STORE_BRAND_LABEL_TYPE_BLUE_V)
                    STORE_BRAND_LABEL_TYPE_BLUE_V = 3,
                    // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType.STORE_BRAND_LABEL_TYPE_TOP_CHOICE)
                    STORE_BRAND_LABEL_TYPE_TOP_CHOICE = 4,
                }

                impl ::protobuf::Enum for StoreBrandLabelType {
                    const NAME: &'static str = "StoreBrandLabelType";

                    fn value(&self) -> i32 {
                        *self as i32
                    }

                    fn from_i32(value: i32) -> ::std::option::Option<StoreBrandLabelType> {
                        match value {
                            0 => ::std::option::Option::Some(StoreBrandLabelType::NONE),
                            1 => ::std::option::Option::Some(StoreBrandLabelType::OFFICIAL),
                            2 => ::std::option::Option::Some(StoreBrandLabelType::AUTHORIZED),
                            3 => ::std::option::Option::Some(StoreBrandLabelType::STORE_BRAND_LABEL_TYPE_BLUE_V),
                            4 => ::std::option::Option::Some(StoreBrandLabelType::STORE_BRAND_LABEL_TYPE_TOP_CHOICE),
                            _ => ::std::option::Option::None
                        }
                    }

                    fn from_str(str: &str) -> ::std::option::Option<StoreBrandLabelType> {
                        match str {
                            "NONE" => ::std::option::Option::Some(StoreBrandLabelType::NONE),
                            "OFFICIAL" => ::std::option::Option::Some(StoreBrandLabelType::OFFICIAL),
                            "AUTHORIZED" => ::std::option::Option::Some(StoreBrandLabelType::AUTHORIZED),
                            "STORE_BRAND_LABEL_TYPE_BLUE_V" => ::std::option::Option::Some(StoreBrandLabelType::STORE_BRAND_LABEL_TYPE_BLUE_V),
                            "STORE_BRAND_LABEL_TYPE_TOP_CHOICE" => ::std::option::Option::Some(StoreBrandLabelType::STORE_BRAND_LABEL_TYPE_TOP_CHOICE),
                            _ => ::std::option::Option::None
                        }
                    }

                    const VALUES: &'static [StoreBrandLabelType] = &[
                        StoreBrandLabelType::NONE,
                        StoreBrandLabelType::OFFICIAL,
                        StoreBrandLabelType::AUTHORIZED,
                        StoreBrandLabelType::STORE_BRAND_LABEL_TYPE_BLUE_V,
                        StoreBrandLabelType::STORE_BRAND_LABEL_TYPE_TOP_CHOICE,
                    ];
                }

                impl ::protobuf::EnumFull for StoreBrandLabelType {
                    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().enum_by_package_relative_name("User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType").unwrap()).clone()
                    }

                    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                        let index = *self as usize;
                        Self::enum_descriptor().value_by_index(index)
                    }
                }

                impl ::std::default::Default for StoreBrandLabelType {
                    fn default() -> Self {
                        StoreBrandLabelType::NONE
                    }
                }

                impl StoreBrandLabelType {
                    pub(in super::super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StoreBrandLabelType>("User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreBrandLabelType")
                    }
                }
            }
        }

        // @@protoc_insertion_point(message:TikTok.User.EcommerceEntrance.ShowcaseEntranceInfo)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ShowcaseEntranceInfo {
            // message fields
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShowcaseEntranceInfo.formatSoldCount)
            pub formatSoldCount: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.EcommerceEntrance.ShowcaseEntranceInfo.soldCount)
            pub soldCount: i64,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.User.EcommerceEntrance.ShowcaseEntranceInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ShowcaseEntranceInfo {
            fn default() -> &'a ShowcaseEntranceInfo {
                <ShowcaseEntranceInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl ShowcaseEntranceInfo {
            pub fn new() -> ShowcaseEntranceInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "formatSoldCount",
                    |m: &ShowcaseEntranceInfo| { &m.formatSoldCount },
                    |m: &mut ShowcaseEntranceInfo| { &mut m.formatSoldCount },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "soldCount",
                    |m: &ShowcaseEntranceInfo| { &m.soldCount },
                    |m: &mut ShowcaseEntranceInfo| { &mut m.soldCount },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShowcaseEntranceInfo>(
                    "User.EcommerceEntrance.ShowcaseEntranceInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ShowcaseEntranceInfo {
            const NAME: &'static str = "ShowcaseEntranceInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.formatSoldCount = is.read_string()?;
                        },
                        16 => {
                            self.soldCount = is.read_int64()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.formatSoldCount.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.formatSoldCount);
                }
                if self.soldCount != 0 {
                    my_size += ::protobuf::rt::int64_size(2, self.soldCount);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.formatSoldCount.is_empty() {
                    os.write_string(1, &self.formatSoldCount)?;
                }
                if self.soldCount != 0 {
                    os.write_int64(2, self.soldCount)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ShowcaseEntranceInfo {
                ShowcaseEntranceInfo::new()
            }

            fn clear(&mut self) {
                self.formatSoldCount.clear();
                self.soldCount = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ShowcaseEntranceInfo {
                static instance: ShowcaseEntranceInfo = ShowcaseEntranceInfo {
                    formatSoldCount: ::std::string::String::new(),
                    soldCount: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ShowcaseEntranceInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("User.EcommerceEntrance.ShowcaseEntranceInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ShowcaseEntranceInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ShowcaseEntranceInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:TikTok.User.EcommerceEntrance.CreatorType)
        pub enum CreatorType {
            // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.CreatorType.UNDEFINED)
            UNDEFINED = 0,
            // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.CreatorType.OFFICIAL)
            OFFICIAL = 1,
            // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.CreatorType.MARKET)
            MARKET = 2,
            // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.CreatorType.NORMAL)
            NORMAL = 3,
        }

        impl ::protobuf::Enum for CreatorType {
            const NAME: &'static str = "CreatorType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<CreatorType> {
                match value {
                    0 => ::std::option::Option::Some(CreatorType::UNDEFINED),
                    1 => ::std::option::Option::Some(CreatorType::OFFICIAL),
                    2 => ::std::option::Option::Some(CreatorType::MARKET),
                    3 => ::std::option::Option::Some(CreatorType::NORMAL),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<CreatorType> {
                match str {
                    "UNDEFINED" => ::std::option::Option::Some(CreatorType::UNDEFINED),
                    "OFFICIAL" => ::std::option::Option::Some(CreatorType::OFFICIAL),
                    "MARKET" => ::std::option::Option::Some(CreatorType::MARKET),
                    "NORMAL" => ::std::option::Option::Some(CreatorType::NORMAL),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [CreatorType] = &[
                CreatorType::UNDEFINED,
                CreatorType::OFFICIAL,
                CreatorType::MARKET,
                CreatorType::NORMAL,
            ];
        }

        impl ::protobuf::EnumFull for CreatorType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("User.EcommerceEntrance.CreatorType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for CreatorType {
            fn default() -> Self {
                CreatorType::UNDEFINED
            }
        }

        impl CreatorType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CreatorType>("User.EcommerceEntrance.CreatorType")
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:TikTok.User.EcommerceEntrance.EntranceType)
        pub enum EntranceType {
            // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.EntranceType.PROFILE)
            PROFILE = 0,
            // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.EntranceType.SHOWCASE)
            SHOWCASE = 1,
            // @@protoc_insertion_point(enum_value:TikTok.User.EcommerceEntrance.EntranceType.SHOP)
            SHOP = 2,
        }

        impl ::protobuf::Enum for EntranceType {
            const NAME: &'static str = "EntranceType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EntranceType> {
                match value {
                    0 => ::std::option::Option::Some(EntranceType::PROFILE),
                    1 => ::std::option::Option::Some(EntranceType::SHOWCASE),
                    2 => ::std::option::Option::Some(EntranceType::SHOP),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EntranceType> {
                match str {
                    "PROFILE" => ::std::option::Option::Some(EntranceType::PROFILE),
                    "SHOWCASE" => ::std::option::Option::Some(EntranceType::SHOWCASE),
                    "SHOP" => ::std::option::Option::Some(EntranceType::SHOP),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EntranceType] = &[
                EntranceType::PROFILE,
                EntranceType::SHOWCASE,
                EntranceType::SHOP,
            ];
        }

        impl ::protobuf::EnumFull for EntranceType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("User.EcommerceEntrance.EntranceType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for EntranceType {
            fn default() -> Self {
                EntranceType::PROFILE
            }
        }

        impl EntranceType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EntranceType>("User.EcommerceEntrance.EntranceType")
            }
        }
    }

    // @@protoc_insertion_point(message:TikTok.User.FansClub)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FansClub {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.FansClub.data)
        pub data: ::protobuf::MessageField<fans_club::FansClubData>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.FansClub.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FansClub {
        fn default() -> &'a FansClub {
            <FansClub as ::protobuf::Message>::default_instance()
        }
    }

    impl FansClub {
        pub fn new() -> FansClub {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, fans_club::FansClubData>(
                "data",
                |m: &FansClub| { &m.data },
                |m: &mut FansClub| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FansClub>(
                "User.FansClub",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FansClub {
        const NAME: &'static str = "FansClub";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FansClub {
            FansClub::new()
        }

        fn clear(&mut self) {
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FansClub {
            static instance: FansClub = FansClub {
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FansClub {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.FansClub").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FansClub {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FansClub {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `FansClub`
    pub mod fans_club {
        // @@protoc_insertion_point(message:TikTok.User.FansClub.FansClubData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FansClubData {
            // message fields
            // @@protoc_insertion_point(field:TikTok.User.FansClub.FansClubData.clubName)
            pub clubName: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.User.FansClub.FansClubData.level)
            pub level: i32,
            // @@protoc_insertion_point(field:TikTok.User.FansClub.FansClubData.userFansClubStatus)
            pub userFansClubStatus: ::protobuf::EnumOrUnknown<fans_club_data::UserFansClubStatus>,
            // @@protoc_insertion_point(field:TikTok.User.FansClub.FansClubData.availableGiftIdsList)
            pub availableGiftIdsList: ::std::vec::Vec<i64>,
            // @@protoc_insertion_point(field:TikTok.User.FansClub.FansClubData.anchorId)
            pub anchorId: i64,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.User.FansClub.FansClubData.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FansClubData {
            fn default() -> &'a FansClubData {
                <FansClubData as ::protobuf::Message>::default_instance()
            }
        }

        impl FansClubData {
            pub fn new() -> FansClubData {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "clubName",
                    |m: &FansClubData| { &m.clubName },
                    |m: &mut FansClubData| { &mut m.clubName },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "level",
                    |m: &FansClubData| { &m.level },
                    |m: &mut FansClubData| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "userFansClubStatus",
                    |m: &FansClubData| { &m.userFansClubStatus },
                    |m: &mut FansClubData| { &mut m.userFansClubStatus },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "availableGiftIdsList",
                    |m: &FansClubData| { &m.availableGiftIdsList },
                    |m: &mut FansClubData| { &mut m.availableGiftIdsList },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "anchorId",
                    |m: &FansClubData| { &m.anchorId },
                    |m: &mut FansClubData| { &mut m.anchorId },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FansClubData>(
                    "User.FansClub.FansClubData",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for FansClubData {
            const NAME: &'static str = "FansClubData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.clubName = is.read_string()?;
                        },
                        16 => {
                            self.level = is.read_int32()?;
                        },
                        24 => {
                            self.userFansClubStatus = is.read_enum_or_unknown()?;
                        },
                        42 => {
                            is.read_repeated_packed_int64_into(&mut self.availableGiftIdsList)?;
                        },
                        40 => {
                            self.availableGiftIdsList.push(is.read_int64()?);
                        },
                        48 => {
                            self.anchorId = is.read_int64()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.clubName.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.clubName);
                }
                if self.level != 0 {
                    my_size += ::protobuf::rt::int32_size(2, self.level);
                }
                if self.userFansClubStatus != ::protobuf::EnumOrUnknown::new(fans_club_data::UserFansClubStatus::NOTJOINED) {
                    my_size += ::protobuf::rt::int32_size(3, self.userFansClubStatus.value());
                }
                for value in &self.availableGiftIdsList {
                    my_size += ::protobuf::rt::int64_size(5, *value);
                };
                if self.anchorId != 0 {
                    my_size += ::protobuf::rt::int64_size(6, self.anchorId);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.clubName.is_empty() {
                    os.write_string(1, &self.clubName)?;
                }
                if self.level != 0 {
                    os.write_int32(2, self.level)?;
                }
                if self.userFansClubStatus != ::protobuf::EnumOrUnknown::new(fans_club_data::UserFansClubStatus::NOTJOINED) {
                    os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.userFansClubStatus))?;
                }
                for v in &self.availableGiftIdsList {
                    os.write_int64(5, *v)?;
                };
                if self.anchorId != 0 {
                    os.write_int64(6, self.anchorId)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FansClubData {
                FansClubData::new()
            }

            fn clear(&mut self) {
                self.clubName.clear();
                self.level = 0;
                self.userFansClubStatus = ::protobuf::EnumOrUnknown::new(fans_club_data::UserFansClubStatus::NOTJOINED);
                self.availableGiftIdsList.clear();
                self.anchorId = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FansClubData {
                static instance: FansClubData = FansClubData {
                    clubName: ::std::string::String::new(),
                    level: 0,
                    userFansClubStatus: ::protobuf::EnumOrUnknown::from_i32(0),
                    availableGiftIdsList: ::std::vec::Vec::new(),
                    anchorId: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for FansClubData {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("User.FansClub.FansClubData").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for FansClubData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for FansClubData {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `FansClubData`
        pub mod fans_club_data {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:TikTok.User.FansClub.FansClubData.BadgeIcon)
            pub enum BadgeIcon {
                // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.FansClubData.BadgeIcon.UNKNOWN)
                UNKNOWN = 0,
                // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.FansClubData.BadgeIcon.ICON)
                ICON = 1,
                // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.FansClubData.BadgeIcon.SMALLICON)
                SMALLICON = 2,
            }

            impl ::protobuf::Enum for BadgeIcon {
                const NAME: &'static str = "BadgeIcon";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<BadgeIcon> {
                    match value {
                        0 => ::std::option::Option::Some(BadgeIcon::UNKNOWN),
                        1 => ::std::option::Option::Some(BadgeIcon::ICON),
                        2 => ::std::option::Option::Some(BadgeIcon::SMALLICON),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<BadgeIcon> {
                    match str {
                        "UNKNOWN" => ::std::option::Option::Some(BadgeIcon::UNKNOWN),
                        "ICON" => ::std::option::Option::Some(BadgeIcon::ICON),
                        "SMALLICON" => ::std::option::Option::Some(BadgeIcon::SMALLICON),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [BadgeIcon] = &[
                    BadgeIcon::UNKNOWN,
                    BadgeIcon::ICON,
                    BadgeIcon::SMALLICON,
                ];
            }

            impl ::protobuf::EnumFull for BadgeIcon {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("User.FansClub.FansClubData.BadgeIcon").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for BadgeIcon {
                fn default() -> Self {
                    BadgeIcon::UNKNOWN
                }
            }

            impl BadgeIcon {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BadgeIcon>("User.FansClub.FansClubData.BadgeIcon")
                }
            }

            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:TikTok.User.FansClub.FansClubData.UserFansClubStatus)
            pub enum UserFansClubStatus {
                // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.FansClubData.UserFansClubStatus.NOTJOINED)
                NOTJOINED = 0,
                // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.FansClubData.UserFansClubStatus.ACTIVE)
                ACTIVE = 1,
                // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.FansClubData.UserFansClubStatus.INACTIVE)
                INACTIVE = 2,
            }

            impl ::protobuf::Enum for UserFansClubStatus {
                const NAME: &'static str = "UserFansClubStatus";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<UserFansClubStatus> {
                    match value {
                        0 => ::std::option::Option::Some(UserFansClubStatus::NOTJOINED),
                        1 => ::std::option::Option::Some(UserFansClubStatus::ACTIVE),
                        2 => ::std::option::Option::Some(UserFansClubStatus::INACTIVE),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<UserFansClubStatus> {
                    match str {
                        "NOTJOINED" => ::std::option::Option::Some(UserFansClubStatus::NOTJOINED),
                        "ACTIVE" => ::std::option::Option::Some(UserFansClubStatus::ACTIVE),
                        "INACTIVE" => ::std::option::Option::Some(UserFansClubStatus::INACTIVE),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [UserFansClubStatus] = &[
                    UserFansClubStatus::NOTJOINED,
                    UserFansClubStatus::ACTIVE,
                    UserFansClubStatus::INACTIVE,
                ];
            }

            impl ::protobuf::EnumFull for UserFansClubStatus {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("User.FansClub.FansClubData.UserFansClubStatus").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for UserFansClubStatus {
                fn default() -> Self {
                    UserFansClubStatus::NOTJOINED
                }
            }

            impl UserFansClubStatus {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UserFansClubStatus>("User.FansClub.FansClubData.UserFansClubStatus")
                }
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:TikTok.User.FansClub.PreferntialType)
        pub enum PreferntialType {
            // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.PreferntialType.PRESONALPROFILE)
            PRESONALPROFILE = 0,
            // @@protoc_insertion_point(enum_value:TikTok.User.FansClub.PreferntialType.OTHERROOM)
            OTHERROOM = 1,
        }

        impl ::protobuf::Enum for PreferntialType {
            const NAME: &'static str = "PreferntialType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<PreferntialType> {
                match value {
                    0 => ::std::option::Option::Some(PreferntialType::PRESONALPROFILE),
                    1 => ::std::option::Option::Some(PreferntialType::OTHERROOM),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<PreferntialType> {
                match str {
                    "PRESONALPROFILE" => ::std::option::Option::Some(PreferntialType::PRESONALPROFILE),
                    "OTHERROOM" => ::std::option::Option::Some(PreferntialType::OTHERROOM),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [PreferntialType] = &[
                PreferntialType::PRESONALPROFILE,
                PreferntialType::OTHERROOM,
            ];
        }

        impl ::protobuf::EnumFull for PreferntialType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("User.FansClub.PreferntialType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for PreferntialType {
            fn default() -> Self {
                PreferntialType::PRESONALPROFILE
            }
        }

        impl PreferntialType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PreferntialType>("User.FansClub.PreferntialType")
            }
        }
    }

    // @@protoc_insertion_point(message:TikTok.User.FansClubInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FansClubInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.FansClubInfo.isSleeping)
        pub isSleeping: bool,
        // @@protoc_insertion_point(field:TikTok.User.FansClubInfo.fansLevel)
        pub fansLevel: i64,
        // @@protoc_insertion_point(field:TikTok.User.FansClubInfo.fansScore)
        pub fansScore: i64,
        // @@protoc_insertion_point(field:TikTok.User.FansClubInfo.badge)
        pub badge: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.FansClubInfo.fansCount)
        pub fansCount: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.FansClubInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FansClubInfo {
        fn default() -> &'a FansClubInfo {
            <FansClubInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl FansClubInfo {
        pub fn new() -> FansClubInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isSleeping",
                |m: &FansClubInfo| { &m.isSleeping },
                |m: &mut FansClubInfo| { &mut m.isSleeping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fansLevel",
                |m: &FansClubInfo| { &m.fansLevel },
                |m: &mut FansClubInfo| { &mut m.fansLevel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fansScore",
                |m: &FansClubInfo| { &m.fansScore },
                |m: &mut FansClubInfo| { &mut m.fansScore },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "badge",
                |m: &FansClubInfo| { &m.badge },
                |m: &mut FansClubInfo| { &mut m.badge },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fansCount",
                |m: &FansClubInfo| { &m.fansCount },
                |m: &mut FansClubInfo| { &mut m.fansCount },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FansClubInfo>(
                "User.FansClubInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FansClubInfo {
        const NAME: &'static str = "FansClubInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.isSleeping = is.read_bool()?;
                    },
                    16 => {
                        self.fansLevel = is.read_int64()?;
                    },
                    24 => {
                        self.fansScore = is.read_int64()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.badge)?;
                    },
                    40 => {
                        self.fansCount = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.isSleeping != false {
                my_size += 1 + 1;
            }
            if self.fansLevel != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.fansLevel);
            }
            if self.fansScore != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.fansScore);
            }
            if let Some(v) = self.badge.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.fansCount != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.fansCount);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.isSleeping != false {
                os.write_bool(1, self.isSleeping)?;
            }
            if self.fansLevel != 0 {
                os.write_int64(2, self.fansLevel)?;
            }
            if self.fansScore != 0 {
                os.write_int64(3, self.fansScore)?;
            }
            if let Some(v) = self.badge.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if self.fansCount != 0 {
                os.write_int64(5, self.fansCount)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FansClubInfo {
            FansClubInfo::new()
        }

        fn clear(&mut self) {
            self.isSleeping = false;
            self.fansLevel = 0;
            self.fansScore = 0;
            self.badge.clear();
            self.fansCount = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FansClubInfo {
            static instance: FansClubInfo = FansClubInfo {
                isSleeping: false,
                fansLevel: 0,
                fansScore: 0,
                badge: ::protobuf::MessageField::none(),
                fansCount: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FansClubInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.FansClubInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FansClubInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FansClubInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.FollowInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FollowInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.FollowInfo.followingCount)
        pub followingCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.FollowInfo.followerCount)
        pub followerCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.FollowInfo.followStatus)
        pub followStatus: i64,
        // @@protoc_insertion_point(field:TikTok.User.FollowInfo.pushStatus)
        pub pushStatus: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.FollowInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FollowInfo {
        fn default() -> &'a FollowInfo {
            <FollowInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl FollowInfo {
        pub fn new() -> FollowInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "followingCount",
                |m: &FollowInfo| { &m.followingCount },
                |m: &mut FollowInfo| { &mut m.followingCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "followerCount",
                |m: &FollowInfo| { &m.followerCount },
                |m: &mut FollowInfo| { &mut m.followerCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "followStatus",
                |m: &FollowInfo| { &m.followStatus },
                |m: &mut FollowInfo| { &mut m.followStatus },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "pushStatus",
                |m: &FollowInfo| { &m.pushStatus },
                |m: &mut FollowInfo| { &mut m.pushStatus },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FollowInfo>(
                "User.FollowInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FollowInfo {
        const NAME: &'static str = "FollowInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.followingCount = is.read_int64()?;
                    },
                    16 => {
                        self.followerCount = is.read_int64()?;
                    },
                    24 => {
                        self.followStatus = is.read_int64()?;
                    },
                    32 => {
                        self.pushStatus = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.followingCount != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.followingCount);
            }
            if self.followerCount != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.followerCount);
            }
            if self.followStatus != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.followStatus);
            }
            if self.pushStatus != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.pushStatus);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.followingCount != 0 {
                os.write_int64(1, self.followingCount)?;
            }
            if self.followerCount != 0 {
                os.write_int64(2, self.followerCount)?;
            }
            if self.followStatus != 0 {
                os.write_int64(3, self.followStatus)?;
            }
            if self.pushStatus != 0 {
                os.write_int64(4, self.pushStatus)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FollowInfo {
            FollowInfo::new()
        }

        fn clear(&mut self) {
            self.followingCount = 0;
            self.followerCount = 0;
            self.followStatus = 0;
            self.pushStatus = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FollowInfo {
            static instance: FollowInfo = FollowInfo {
                followingCount: 0,
                followerCount: 0,
                followStatus: 0,
                pushStatus: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FollowInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.FollowInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FollowInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FollowInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.OwnRoom)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OwnRoom {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.OwnRoom.roomIdsList)
        pub roomIdsList: ::std::vec::Vec<i64>,
        // @@protoc_insertion_point(field:TikTok.User.OwnRoom.roomIdsStrList)
        pub roomIdsStrList: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.OwnRoom.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OwnRoom {
        fn default() -> &'a OwnRoom {
            <OwnRoom as ::protobuf::Message>::default_instance()
        }
    }

    impl OwnRoom {
        pub fn new() -> OwnRoom {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "roomIdsList",
                |m: &OwnRoom| { &m.roomIdsList },
                |m: &mut OwnRoom| { &mut m.roomIdsList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "roomIdsStrList",
                |m: &OwnRoom| { &m.roomIdsStrList },
                |m: &mut OwnRoom| { &mut m.roomIdsStrList },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OwnRoom>(
                "User.OwnRoom",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OwnRoom {
        const NAME: &'static str = "OwnRoom";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int64_into(&mut self.roomIdsList)?;
                    },
                    8 => {
                        self.roomIdsList.push(is.read_int64()?);
                    },
                    18 => {
                        self.roomIdsStrList.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.roomIdsList {
                my_size += ::protobuf::rt::int64_size(1, *value);
            };
            for value in &self.roomIdsStrList {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.roomIdsList {
                os.write_int64(1, *v)?;
            };
            for v in &self.roomIdsStrList {
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OwnRoom {
            OwnRoom::new()
        }

        fn clear(&mut self) {
            self.roomIdsList.clear();
            self.roomIdsStrList.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OwnRoom {
            static instance: OwnRoom = OwnRoom {
                roomIdsList: ::std::vec::Vec::new(),
                roomIdsStrList: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OwnRoom {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.OwnRoom").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OwnRoom {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OwnRoom {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.PayGrade)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PayGrade {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.diamondIcon)
        pub diamondIcon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.icon)
        pub icon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.nextName)
        pub nextName: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.level)
        pub level: i64,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.nextIcon)
        pub nextIcon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.gradeDescribe)
        pub gradeDescribe: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.gradeIconList)
        pub gradeIconList: ::std::vec::Vec<pay_grade::GradeIcon>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.screenChatType)
        pub screenChatType: i64,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.imIcon)
        pub imIcon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.imIconWithLevel)
        pub imIconWithLevel: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.liveIcon)
        pub liveIcon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.newImIconWithLevel)
        pub newImIconWithLevel: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.newLiveIcon)
        pub newLiveIcon: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.upgradeNeedConsume)
        pub upgradeNeedConsume: i64,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.nextPrivileges)
        pub nextPrivileges: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.background)
        pub background: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.backgroundBack)
        pub backgroundBack: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.score)
        pub score: i64,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.gradeBanner)
        pub gradeBanner: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.profileDialogBg)
        pub profileDialogBg: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.PayGrade.profileDialogBgBack)
        pub profileDialogBgBack: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.PayGrade.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PayGrade {
        fn default() -> &'a PayGrade {
            <PayGrade as ::protobuf::Message>::default_instance()
        }
    }

    impl PayGrade {
        pub fn new() -> PayGrade {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(22);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "diamondIcon",
                |m: &PayGrade| { &m.diamondIcon },
                |m: &mut PayGrade| { &mut m.diamondIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &PayGrade| { &m.name },
                |m: &mut PayGrade| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "icon",
                |m: &PayGrade| { &m.icon },
                |m: &mut PayGrade| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "nextName",
                |m: &PayGrade| { &m.nextName },
                |m: &mut PayGrade| { &mut m.nextName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "level",
                |m: &PayGrade| { &m.level },
                |m: &mut PayGrade| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "nextIcon",
                |m: &PayGrade| { &m.nextIcon },
                |m: &mut PayGrade| { &mut m.nextIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "gradeDescribe",
                |m: &PayGrade| { &m.gradeDescribe },
                |m: &mut PayGrade| { &mut m.gradeDescribe },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "gradeIconList",
                |m: &PayGrade| { &m.gradeIconList },
                |m: &mut PayGrade| { &mut m.gradeIconList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "screenChatType",
                |m: &PayGrade| { &m.screenChatType },
                |m: &mut PayGrade| { &mut m.screenChatType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "imIcon",
                |m: &PayGrade| { &m.imIcon },
                |m: &mut PayGrade| { &mut m.imIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "imIconWithLevel",
                |m: &PayGrade| { &m.imIconWithLevel },
                |m: &mut PayGrade| { &mut m.imIconWithLevel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "liveIcon",
                |m: &PayGrade| { &m.liveIcon },
                |m: &mut PayGrade| { &mut m.liveIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "newImIconWithLevel",
                |m: &PayGrade| { &m.newImIconWithLevel },
                |m: &mut PayGrade| { &mut m.newImIconWithLevel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "newLiveIcon",
                |m: &PayGrade| { &m.newLiveIcon },
                |m: &mut PayGrade| { &mut m.newLiveIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "upgradeNeedConsume",
                |m: &PayGrade| { &m.upgradeNeedConsume },
                |m: &mut PayGrade| { &mut m.upgradeNeedConsume },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "nextPrivileges",
                |m: &PayGrade| { &m.nextPrivileges },
                |m: &mut PayGrade| { &mut m.nextPrivileges },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "background",
                |m: &PayGrade| { &m.background },
                |m: &mut PayGrade| { &mut m.background },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "backgroundBack",
                |m: &PayGrade| { &m.backgroundBack },
                |m: &mut PayGrade| { &mut m.backgroundBack },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "score",
                |m: &PayGrade| { &m.score },
                |m: &mut PayGrade| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "gradeBanner",
                |m: &PayGrade| { &m.gradeBanner },
                |m: &mut PayGrade| { &mut m.gradeBanner },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "profileDialogBg",
                |m: &PayGrade| { &m.profileDialogBg },
                |m: &mut PayGrade| { &mut m.profileDialogBg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "profileDialogBgBack",
                |m: &PayGrade| { &m.profileDialogBgBack },
                |m: &mut PayGrade| { &mut m.profileDialogBgBack },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PayGrade>(
                "User.PayGrade",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PayGrade {
        const NAME: &'static str = "PayGrade";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.diamondIcon)?;
                    },
                    26 => {
                        self.name = is.read_string()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                    },
                    42 => {
                        self.nextName = is.read_string()?;
                    },
                    48 => {
                        self.level = is.read_int64()?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.nextIcon)?;
                    },
                    106 => {
                        self.gradeDescribe = is.read_string()?;
                    },
                    114 => {
                        self.gradeIconList.push(is.read_message()?);
                    },
                    120 => {
                        self.screenChatType = is.read_int64()?;
                    },
                    130 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.imIcon)?;
                    },
                    138 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.imIconWithLevel)?;
                    },
                    146 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.liveIcon)?;
                    },
                    154 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.newImIconWithLevel)?;
                    },
                    162 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.newLiveIcon)?;
                    },
                    168 => {
                        self.upgradeNeedConsume = is.read_int64()?;
                    },
                    178 => {
                        self.nextPrivileges = is.read_string()?;
                    },
                    186 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                    },
                    194 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.backgroundBack)?;
                    },
                    200 => {
                        self.score = is.read_int64()?;
                    },
                    8010 => {
                        self.gradeBanner = is.read_string()?;
                    },
                    8018 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profileDialogBg)?;
                    },
                    8026 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profileDialogBgBack)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.diamondIcon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.name);
            }
            if let Some(v) = self.icon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.nextName.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.nextName);
            }
            if self.level != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.level);
            }
            if let Some(v) = self.nextIcon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.gradeDescribe.is_empty() {
                my_size += ::protobuf::rt::string_size(13, &self.gradeDescribe);
            }
            for value in &self.gradeIconList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.screenChatType != 0 {
                my_size += ::protobuf::rt::int64_size(15, self.screenChatType);
            }
            if let Some(v) = self.imIcon.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.imIconWithLevel.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.liveIcon.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.newImIconWithLevel.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.newLiveIcon.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.upgradeNeedConsume != 0 {
                my_size += ::protobuf::rt::int64_size(21, self.upgradeNeedConsume);
            }
            if !self.nextPrivileges.is_empty() {
                my_size += ::protobuf::rt::string_size(22, &self.nextPrivileges);
            }
            if let Some(v) = self.background.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.backgroundBack.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.score != 0 {
                my_size += ::protobuf::rt::int64_size(25, self.score);
            }
            if !self.gradeBanner.is_empty() {
                my_size += ::protobuf::rt::string_size(1001, &self.gradeBanner);
            }
            if let Some(v) = self.profileDialogBg.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.profileDialogBgBack.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.diamondIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if !self.name.is_empty() {
                os.write_string(3, &self.name)?;
            }
            if let Some(v) = self.icon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if !self.nextName.is_empty() {
                os.write_string(5, &self.nextName)?;
            }
            if self.level != 0 {
                os.write_int64(6, self.level)?;
            }
            if let Some(v) = self.nextIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if !self.gradeDescribe.is_empty() {
                os.write_string(13, &self.gradeDescribe)?;
            }
            for v in &self.gradeIconList {
                ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
            };
            if self.screenChatType != 0 {
                os.write_int64(15, self.screenChatType)?;
            }
            if let Some(v) = self.imIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
            }
            if let Some(v) = self.imIconWithLevel.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
            }
            if let Some(v) = self.liveIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
            }
            if let Some(v) = self.newImIconWithLevel.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
            }
            if let Some(v) = self.newLiveIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
            }
            if self.upgradeNeedConsume != 0 {
                os.write_int64(21, self.upgradeNeedConsume)?;
            }
            if !self.nextPrivileges.is_empty() {
                os.write_string(22, &self.nextPrivileges)?;
            }
            if let Some(v) = self.background.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
            }
            if let Some(v) = self.backgroundBack.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
            }
            if self.score != 0 {
                os.write_int64(25, self.score)?;
            }
            if !self.gradeBanner.is_empty() {
                os.write_string(1001, &self.gradeBanner)?;
            }
            if let Some(v) = self.profileDialogBg.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1002, v, os)?;
            }
            if let Some(v) = self.profileDialogBgBack.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1003, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PayGrade {
            PayGrade::new()
        }

        fn clear(&mut self) {
            self.diamondIcon.clear();
            self.name.clear();
            self.icon.clear();
            self.nextName.clear();
            self.level = 0;
            self.nextIcon.clear();
            self.gradeDescribe.clear();
            self.gradeIconList.clear();
            self.screenChatType = 0;
            self.imIcon.clear();
            self.imIconWithLevel.clear();
            self.liveIcon.clear();
            self.newImIconWithLevel.clear();
            self.newLiveIcon.clear();
            self.upgradeNeedConsume = 0;
            self.nextPrivileges.clear();
            self.background.clear();
            self.backgroundBack.clear();
            self.score = 0;
            self.gradeBanner.clear();
            self.profileDialogBg.clear();
            self.profileDialogBgBack.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PayGrade {
            static instance: PayGrade = PayGrade {
                diamondIcon: ::protobuf::MessageField::none(),
                name: ::std::string::String::new(),
                icon: ::protobuf::MessageField::none(),
                nextName: ::std::string::String::new(),
                level: 0,
                nextIcon: ::protobuf::MessageField::none(),
                gradeDescribe: ::std::string::String::new(),
                gradeIconList: ::std::vec::Vec::new(),
                screenChatType: 0,
                imIcon: ::protobuf::MessageField::none(),
                imIconWithLevel: ::protobuf::MessageField::none(),
                liveIcon: ::protobuf::MessageField::none(),
                newImIconWithLevel: ::protobuf::MessageField::none(),
                newLiveIcon: ::protobuf::MessageField::none(),
                upgradeNeedConsume: 0,
                nextPrivileges: ::std::string::String::new(),
                background: ::protobuf::MessageField::none(),
                backgroundBack: ::protobuf::MessageField::none(),
                score: 0,
                gradeBanner: ::std::string::String::new(),
                profileDialogBg: ::protobuf::MessageField::none(),
                profileDialogBgBack: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PayGrade {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.PayGrade").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PayGrade {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PayGrade {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `PayGrade`
    pub mod pay_grade {
        // @@protoc_insertion_point(message:TikTok.User.PayGrade.GradeIcon)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct GradeIcon {
            // message fields
            // @@protoc_insertion_point(field:TikTok.User.PayGrade.GradeIcon.icon)
            pub icon: ::protobuf::MessageField<super::super::Image>,
            // @@protoc_insertion_point(field:TikTok.User.PayGrade.GradeIcon.iconDiamond)
            pub iconDiamond: i64,
            // @@protoc_insertion_point(field:TikTok.User.PayGrade.GradeIcon.level)
            pub level: i64,
            // @@protoc_insertion_point(field:TikTok.User.PayGrade.GradeIcon.levelStr)
            pub levelStr: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.User.PayGrade.GradeIcon.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a GradeIcon {
            fn default() -> &'a GradeIcon {
                <GradeIcon as ::protobuf::Message>::default_instance()
            }
        }

        impl GradeIcon {
            pub fn new() -> GradeIcon {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::Image>(
                    "icon",
                    |m: &GradeIcon| { &m.icon },
                    |m: &mut GradeIcon| { &mut m.icon },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "iconDiamond",
                    |m: &GradeIcon| { &m.iconDiamond },
                    |m: &mut GradeIcon| { &mut m.iconDiamond },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "level",
                    |m: &GradeIcon| { &m.level },
                    |m: &mut GradeIcon| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "levelStr",
                    |m: &GradeIcon| { &m.levelStr },
                    |m: &mut GradeIcon| { &mut m.levelStr },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GradeIcon>(
                    "User.PayGrade.GradeIcon",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for GradeIcon {
            const NAME: &'static str = "GradeIcon";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                        },
                        16 => {
                            self.iconDiamond = is.read_int64()?;
                        },
                        24 => {
                            self.level = is.read_int64()?;
                        },
                        34 => {
                            self.levelStr = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.icon.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if self.iconDiamond != 0 {
                    my_size += ::protobuf::rt::int64_size(2, self.iconDiamond);
                }
                if self.level != 0 {
                    my_size += ::protobuf::rt::int64_size(3, self.level);
                }
                if !self.levelStr.is_empty() {
                    my_size += ::protobuf::rt::string_size(4, &self.levelStr);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.icon.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                }
                if self.iconDiamond != 0 {
                    os.write_int64(2, self.iconDiamond)?;
                }
                if self.level != 0 {
                    os.write_int64(3, self.level)?;
                }
                if !self.levelStr.is_empty() {
                    os.write_string(4, &self.levelStr)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> GradeIcon {
                GradeIcon::new()
            }

            fn clear(&mut self) {
                self.icon.clear();
                self.iconDiamond = 0;
                self.level = 0;
                self.levelStr.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static GradeIcon {
                static instance: GradeIcon = GradeIcon {
                    icon: ::protobuf::MessageField::none(),
                    iconDiamond: 0,
                    level: 0,
                    levelStr: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for GradeIcon {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("User.PayGrade.GradeIcon").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for GradeIcon {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for GradeIcon {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:TikTok.User.SubscribeBadge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubscribeBadge {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.SubscribeBadge.originImg)
        pub originImg: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeBadge.previewImg)
        pub previewImg: ::protobuf::MessageField<super::Image>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.SubscribeBadge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubscribeBadge {
        fn default() -> &'a SubscribeBadge {
            <SubscribeBadge as ::protobuf::Message>::default_instance()
        }
    }

    impl SubscribeBadge {
        pub fn new() -> SubscribeBadge {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "originImg",
                |m: &SubscribeBadge| { &m.originImg },
                |m: &mut SubscribeBadge| { &mut m.originImg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "previewImg",
                |m: &SubscribeBadge| { &m.previewImg },
                |m: &mut SubscribeBadge| { &mut m.previewImg },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeBadge>(
                "User.SubscribeBadge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SubscribeBadge {
        const NAME: &'static str = "SubscribeBadge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.originImg)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.previewImg)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.originImg.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.previewImg.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.originImg.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.previewImg.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubscribeBadge {
            SubscribeBadge::new()
        }

        fn clear(&mut self) {
            self.originImg.clear();
            self.previewImg.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubscribeBadge {
            static instance: SubscribeBadge = SubscribeBadge {
                originImg: ::protobuf::MessageField::none(),
                previewImg: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SubscribeBadge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.SubscribeBadge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SubscribeBadge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SubscribeBadge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.SubscribeInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubscribeInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.qualification)
        pub qualification: bool,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.isSubscribe)
        pub isSubscribe: bool,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.badge)
        pub badge: ::protobuf::MessageField<SubscribeBadge>,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.enableSubscription)
        pub enableSubscription: bool,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.subscriberCount)
        pub subscriberCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.isInGracePeriod)
        pub isInGracePeriod: bool,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.isSubscribedToAnchor)
        pub isSubscribedToAnchor: bool,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.userGiftSubAuth)
        pub userGiftSubAuth: bool,
        // @@protoc_insertion_point(field:TikTok.User.SubscribeInfo.anchorGiftSubAuth)
        pub anchorGiftSubAuth: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.SubscribeInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubscribeInfo {
        fn default() -> &'a SubscribeInfo {
            <SubscribeInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl SubscribeInfo {
        pub fn new() -> SubscribeInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "qualification",
                |m: &SubscribeInfo| { &m.qualification },
                |m: &mut SubscribeInfo| { &mut m.qualification },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isSubscribe",
                |m: &SubscribeInfo| { &m.isSubscribe },
                |m: &mut SubscribeInfo| { &mut m.isSubscribe },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubscribeBadge>(
                "badge",
                |m: &SubscribeInfo| { &m.badge },
                |m: &mut SubscribeInfo| { &mut m.badge },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "enableSubscription",
                |m: &SubscribeInfo| { &m.enableSubscription },
                |m: &mut SubscribeInfo| { &mut m.enableSubscription },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "subscriberCount",
                |m: &SubscribeInfo| { &m.subscriberCount },
                |m: &mut SubscribeInfo| { &mut m.subscriberCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isInGracePeriod",
                |m: &SubscribeInfo| { &m.isInGracePeriod },
                |m: &mut SubscribeInfo| { &mut m.isInGracePeriod },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isSubscribedToAnchor",
                |m: &SubscribeInfo| { &m.isSubscribedToAnchor },
                |m: &mut SubscribeInfo| { &mut m.isSubscribedToAnchor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userGiftSubAuth",
                |m: &SubscribeInfo| { &m.userGiftSubAuth },
                |m: &mut SubscribeInfo| { &mut m.userGiftSubAuth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "anchorGiftSubAuth",
                |m: &SubscribeInfo| { &m.anchorGiftSubAuth },
                |m: &mut SubscribeInfo| { &mut m.anchorGiftSubAuth },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeInfo>(
                "User.SubscribeInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SubscribeInfo {
        const NAME: &'static str = "SubscribeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.qualification = is.read_bool()?;
                    },
                    16 => {
                        self.isSubscribe = is.read_bool()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.badge)?;
                    },
                    32 => {
                        self.enableSubscription = is.read_bool()?;
                    },
                    40 => {
                        self.subscriberCount = is.read_int64()?;
                    },
                    48 => {
                        self.isInGracePeriod = is.read_bool()?;
                    },
                    56 => {
                        self.isSubscribedToAnchor = is.read_bool()?;
                    },
                    72 => {
                        self.userGiftSubAuth = is.read_bool()?;
                    },
                    80 => {
                        self.anchorGiftSubAuth = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.qualification != false {
                my_size += 1 + 1;
            }
            if self.isSubscribe != false {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.enableSubscription != false {
                my_size += 1 + 1;
            }
            if self.subscriberCount != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.subscriberCount);
            }
            if self.isInGracePeriod != false {
                my_size += 1 + 1;
            }
            if self.isSubscribedToAnchor != false {
                my_size += 1 + 1;
            }
            if self.userGiftSubAuth != false {
                my_size += 1 + 1;
            }
            if self.anchorGiftSubAuth != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.qualification != false {
                os.write_bool(1, self.qualification)?;
            }
            if self.isSubscribe != false {
                os.write_bool(2, self.isSubscribe)?;
            }
            if let Some(v) = self.badge.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.enableSubscription != false {
                os.write_bool(4, self.enableSubscription)?;
            }
            if self.subscriberCount != 0 {
                os.write_int64(5, self.subscriberCount)?;
            }
            if self.isInGracePeriod != false {
                os.write_bool(6, self.isInGracePeriod)?;
            }
            if self.isSubscribedToAnchor != false {
                os.write_bool(7, self.isSubscribedToAnchor)?;
            }
            if self.userGiftSubAuth != false {
                os.write_bool(9, self.userGiftSubAuth)?;
            }
            if self.anchorGiftSubAuth != false {
                os.write_bool(10, self.anchorGiftSubAuth)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubscribeInfo {
            SubscribeInfo::new()
        }

        fn clear(&mut self) {
            self.qualification = false;
            self.isSubscribe = false;
            self.badge.clear();
            self.enableSubscription = false;
            self.subscriberCount = 0;
            self.isInGracePeriod = false;
            self.isSubscribedToAnchor = false;
            self.userGiftSubAuth = false;
            self.anchorGiftSubAuth = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubscribeInfo {
            static instance: SubscribeInfo = SubscribeInfo {
                qualification: false,
                isSubscribe: false,
                badge: ::protobuf::MessageField::none(),
                enableSubscription: false,
                subscriberCount: 0,
                isInGracePeriod: false,
                isSubscribedToAnchor: false,
                userGiftSubAuth: false,
                anchorGiftSubAuth: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SubscribeInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.SubscribeInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SubscribeInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SubscribeInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.UserAttr)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserAttr {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.UserAttr.isMuted)
        pub isMuted: bool,
        // @@protoc_insertion_point(field:TikTok.User.UserAttr.isAdmin)
        pub isAdmin: bool,
        // @@protoc_insertion_point(field:TikTok.User.UserAttr.isSuperAdmin)
        pub isSuperAdmin: bool,
        // @@protoc_insertion_point(field:TikTok.User.UserAttr.muteDuration)
        pub muteDuration: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.UserAttr.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserAttr {
        fn default() -> &'a UserAttr {
            <UserAttr as ::protobuf::Message>::default_instance()
        }
    }

    impl UserAttr {
        pub fn new() -> UserAttr {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isMuted",
                |m: &UserAttr| { &m.isMuted },
                |m: &mut UserAttr| { &mut m.isMuted },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isAdmin",
                |m: &UserAttr| { &m.isAdmin },
                |m: &mut UserAttr| { &mut m.isAdmin },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isSuperAdmin",
                |m: &UserAttr| { &m.isSuperAdmin },
                |m: &mut UserAttr| { &mut m.isSuperAdmin },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "muteDuration",
                |m: &UserAttr| { &m.muteDuration },
                |m: &mut UserAttr| { &mut m.muteDuration },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAttr>(
                "User.UserAttr",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserAttr {
        const NAME: &'static str = "UserAttr";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.isMuted = is.read_bool()?;
                    },
                    16 => {
                        self.isAdmin = is.read_bool()?;
                    },
                    24 => {
                        self.isSuperAdmin = is.read_bool()?;
                    },
                    32 => {
                        self.muteDuration = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.isMuted != false {
                my_size += 1 + 1;
            }
            if self.isAdmin != false {
                my_size += 1 + 1;
            }
            if self.isSuperAdmin != false {
                my_size += 1 + 1;
            }
            if self.muteDuration != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.muteDuration);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.isMuted != false {
                os.write_bool(1, self.isMuted)?;
            }
            if self.isAdmin != false {
                os.write_bool(2, self.isAdmin)?;
            }
            if self.isSuperAdmin != false {
                os.write_bool(3, self.isSuperAdmin)?;
            }
            if self.muteDuration != 0 {
                os.write_int64(4, self.muteDuration)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserAttr {
            UserAttr::new()
        }

        fn clear(&mut self) {
            self.isMuted = false;
            self.isAdmin = false;
            self.isSuperAdmin = false;
            self.muteDuration = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserAttr {
            static instance: UserAttr = UserAttr {
                isMuted: false,
                isAdmin: false,
                isSuperAdmin: false,
                muteDuration: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserAttr {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.UserAttr").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserAttr {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserAttr {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.User.UserStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserStats {
        // message fields
        // @@protoc_insertion_point(field:TikTok.User.UserStats.id)
        pub id: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.idStr)
        pub idStr: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.followingCount)
        pub followingCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.followerCount)
        pub followerCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.recordCount)
        pub recordCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.totalDuration)
        pub totalDuration: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.dailyFanTicketCount)
        pub dailyFanTicketCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.dailyIncome)
        pub dailyIncome: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.itemCount)
        pub itemCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.favoriteItemCount)
        pub favoriteItemCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.diamondConsumedCount)
        pub diamondConsumedCount: i64,
        // @@protoc_insertion_point(field:TikTok.User.UserStats.tuwenItemCount)
        pub tuwenItemCount: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.User.UserStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserStats {
        fn default() -> &'a UserStats {
            <UserStats as ::protobuf::Message>::default_instance()
        }
    }

    impl UserStats {
        pub fn new() -> UserStats {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(12);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &UserStats| { &m.id },
                |m: &mut UserStats| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "idStr",
                |m: &UserStats| { &m.idStr },
                |m: &mut UserStats| { &mut m.idStr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "followingCount",
                |m: &UserStats| { &m.followingCount },
                |m: &mut UserStats| { &mut m.followingCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "followerCount",
                |m: &UserStats| { &m.followerCount },
                |m: &mut UserStats| { &mut m.followerCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "recordCount",
                |m: &UserStats| { &m.recordCount },
                |m: &mut UserStats| { &mut m.recordCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "totalDuration",
                |m: &UserStats| { &m.totalDuration },
                |m: &mut UserStats| { &mut m.totalDuration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "dailyFanTicketCount",
                |m: &UserStats| { &m.dailyFanTicketCount },
                |m: &mut UserStats| { &mut m.dailyFanTicketCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "dailyIncome",
                |m: &UserStats| { &m.dailyIncome },
                |m: &mut UserStats| { &mut m.dailyIncome },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "itemCount",
                |m: &UserStats| { &m.itemCount },
                |m: &mut UserStats| { &mut m.itemCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "favoriteItemCount",
                |m: &UserStats| { &m.favoriteItemCount },
                |m: &mut UserStats| { &mut m.favoriteItemCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "diamondConsumedCount",
                |m: &UserStats| { &m.diamondConsumedCount },
                |m: &mut UserStats| { &mut m.diamondConsumedCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tuwenItemCount",
                |m: &UserStats| { &m.tuwenItemCount },
                |m: &mut UserStats| { &mut m.tuwenItemCount },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserStats>(
                "User.UserStats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserStats {
        const NAME: &'static str = "UserStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_int64()?;
                    },
                    18 => {
                        self.idStr = is.read_string()?;
                    },
                    24 => {
                        self.followingCount = is.read_int64()?;
                    },
                    32 => {
                        self.followerCount = is.read_int64()?;
                    },
                    40 => {
                        self.recordCount = is.read_int64()?;
                    },
                    48 => {
                        self.totalDuration = is.read_int64()?;
                    },
                    56 => {
                        self.dailyFanTicketCount = is.read_int64()?;
                    },
                    64 => {
                        self.dailyIncome = is.read_int64()?;
                    },
                    72 => {
                        self.itemCount = is.read_int64()?;
                    },
                    80 => {
                        self.favoriteItemCount = is.read_int64()?;
                    },
                    96 => {
                        self.diamondConsumedCount = is.read_int64()?;
                    },
                    104 => {
                        self.tuwenItemCount = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.id);
            }
            if !self.idStr.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.idStr);
            }
            if self.followingCount != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.followingCount);
            }
            if self.followerCount != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.followerCount);
            }
            if self.recordCount != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.recordCount);
            }
            if self.totalDuration != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.totalDuration);
            }
            if self.dailyFanTicketCount != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.dailyFanTicketCount);
            }
            if self.dailyIncome != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.dailyIncome);
            }
            if self.itemCount != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.itemCount);
            }
            if self.favoriteItemCount != 0 {
                my_size += ::protobuf::rt::int64_size(10, self.favoriteItemCount);
            }
            if self.diamondConsumedCount != 0 {
                my_size += ::protobuf::rt::int64_size(12, self.diamondConsumedCount);
            }
            if self.tuwenItemCount != 0 {
                my_size += ::protobuf::rt::int64_size(13, self.tuwenItemCount);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_int64(1, self.id)?;
            }
            if !self.idStr.is_empty() {
                os.write_string(2, &self.idStr)?;
            }
            if self.followingCount != 0 {
                os.write_int64(3, self.followingCount)?;
            }
            if self.followerCount != 0 {
                os.write_int64(4, self.followerCount)?;
            }
            if self.recordCount != 0 {
                os.write_int64(5, self.recordCount)?;
            }
            if self.totalDuration != 0 {
                os.write_int64(6, self.totalDuration)?;
            }
            if self.dailyFanTicketCount != 0 {
                os.write_int64(7, self.dailyFanTicketCount)?;
            }
            if self.dailyIncome != 0 {
                os.write_int64(8, self.dailyIncome)?;
            }
            if self.itemCount != 0 {
                os.write_int64(9, self.itemCount)?;
            }
            if self.favoriteItemCount != 0 {
                os.write_int64(10, self.favoriteItemCount)?;
            }
            if self.diamondConsumedCount != 0 {
                os.write_int64(12, self.diamondConsumedCount)?;
            }
            if self.tuwenItemCount != 0 {
                os.write_int64(13, self.tuwenItemCount)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserStats {
            UserStats::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.idStr.clear();
            self.followingCount = 0;
            self.followerCount = 0;
            self.recordCount = 0;
            self.totalDuration = 0;
            self.dailyFanTicketCount = 0;
            self.dailyIncome = 0;
            self.itemCount = 0;
            self.favoriteItemCount = 0;
            self.diamondConsumedCount = 0;
            self.tuwenItemCount = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserStats {
            static instance: UserStats = UserStats {
                id: 0,
                idStr: ::std::string::String::new(),
                followingCount: 0,
                followerCount: 0,
                recordCount: 0,
                totalDuration: 0,
                dailyFanTicketCount: 0,
                dailyIncome: 0,
                itemCount: 0,
                favoriteItemCount: 0,
                diamondConsumedCount: 0,
                tuwenItemCount: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserStats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("User.UserStats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserStats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.Emote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Emote {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Emote.emoteId)
    pub emoteId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Emote.image)
    pub image: ::protobuf::MessageField<Image>,
    // @@protoc_insertion_point(field:TikTok.Emote.auditStatus)
    pub auditStatus: ::protobuf::EnumOrUnknown<super::enums::AuditStatus>,
    // @@protoc_insertion_point(field:TikTok.Emote.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Emote.emoteType)
    pub emoteType: ::protobuf::EnumOrUnknown<super::enums::EmoteType>,
    // @@protoc_insertion_point(field:TikTok.Emote.contentSource)
    pub contentSource: ::protobuf::EnumOrUnknown<super::enums::ContentSource>,
    // @@protoc_insertion_point(field:TikTok.Emote.emotePrivateType)
    pub emotePrivateType: ::protobuf::EnumOrUnknown<super::enums::EmotePrivateType>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Emote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Emote {
    fn default() -> &'a Emote {
        <Emote as ::protobuf::Message>::default_instance()
    }
}

impl Emote {
    pub fn new() -> Emote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emoteId",
            |m: &Emote| { &m.emoteId },
            |m: &mut Emote| { &mut m.emoteId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &Emote| { &m.image },
            |m: &mut Emote| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auditStatus",
            |m: &Emote| { &m.auditStatus },
            |m: &mut Emote| { &mut m.auditStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &Emote| { &m.uuid },
            |m: &mut Emote| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emoteType",
            |m: &Emote| { &m.emoteType },
            |m: &mut Emote| { &mut m.emoteType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contentSource",
            |m: &Emote| { &m.contentSource },
            |m: &mut Emote| { &mut m.contentSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emotePrivateType",
            |m: &Emote| { &m.emotePrivateType },
            |m: &mut Emote| { &mut m.emotePrivateType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Emote>(
            "Emote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Emote {
    const NAME: &'static str = "Emote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.emoteId = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                24 => {
                    self.auditStatus = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.uuid = is.read_string()?;
                },
                40 => {
                    self.emoteType = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.contentSource = is.read_enum_or_unknown()?;
                },
                56 => {
                    self.emotePrivateType = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.emoteId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.emoteId);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.auditStatus != ::protobuf::EnumOrUnknown::new(super::enums::AuditStatus::AUDITSTATUSUNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.auditStatus.value());
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.uuid);
        }
        if self.emoteType != ::protobuf::EnumOrUnknown::new(super::enums::EmoteType::EMOTETYPENORMAL) {
            my_size += ::protobuf::rt::int32_size(5, self.emoteType.value());
        }
        if self.contentSource != ::protobuf::EnumOrUnknown::new(super::enums::ContentSource::CONTENTSOURCEUNKNOWN) {
            my_size += ::protobuf::rt::int32_size(6, self.contentSource.value());
        }
        if self.emotePrivateType != ::protobuf::EnumOrUnknown::new(super::enums::EmotePrivateType::EMOTE_PRIVATE_TYPE_NORMAL) {
            my_size += ::protobuf::rt::int32_size(7, self.emotePrivateType.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.emoteId.is_empty() {
            os.write_string(1, &self.emoteId)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.auditStatus != ::protobuf::EnumOrUnknown::new(super::enums::AuditStatus::AUDITSTATUSUNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.auditStatus))?;
        }
        if !self.uuid.is_empty() {
            os.write_string(4, &self.uuid)?;
        }
        if self.emoteType != ::protobuf::EnumOrUnknown::new(super::enums::EmoteType::EMOTETYPENORMAL) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.emoteType))?;
        }
        if self.contentSource != ::protobuf::EnumOrUnknown::new(super::enums::ContentSource::CONTENTSOURCEUNKNOWN) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.contentSource))?;
        }
        if self.emotePrivateType != ::protobuf::EnumOrUnknown::new(super::enums::EmotePrivateType::EMOTE_PRIVATE_TYPE_NORMAL) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.emotePrivateType))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Emote {
        Emote::new()
    }

    fn clear(&mut self) {
        self.emoteId.clear();
        self.image.clear();
        self.auditStatus = ::protobuf::EnumOrUnknown::new(super::enums::AuditStatus::AUDITSTATUSUNKNOWN);
        self.uuid.clear();
        self.emoteType = ::protobuf::EnumOrUnknown::new(super::enums::EmoteType::EMOTETYPENORMAL);
        self.contentSource = ::protobuf::EnumOrUnknown::new(super::enums::ContentSource::CONTENTSOURCEUNKNOWN);
        self.emotePrivateType = ::protobuf::EnumOrUnknown::new(super::enums::EmotePrivateType::EMOTE_PRIVATE_TYPE_NORMAL);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Emote {
        static instance: Emote = Emote {
            emoteId: ::std::string::String::new(),
            image: ::protobuf::MessageField::none(),
            auditStatus: ::protobuf::EnumOrUnknown::from_i32(0),
            uuid: ::std::string::String::new(),
            emoteType: ::protobuf::EnumOrUnknown::from_i32(0),
            contentSource: ::protobuf::EnumOrUnknown::from_i32(0),
            emotePrivateType: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Emote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Emote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Emote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Emote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.PunishEventInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PunishEventInfo {
    // message fields
    // @@protoc_insertion_point(field:TikTok.PunishEventInfo.punishType)
    pub punishType: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.PunishEventInfo.punishReason)
    pub punishReason: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.PunishEventInfo.punishId)
    pub punishId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.PunishEventInfo.violationUid)
    pub violationUid: i64,
    // @@protoc_insertion_point(field:TikTok.PunishEventInfo.punishTypeId)
    pub punishTypeId: i32,
    // @@protoc_insertion_point(field:TikTok.PunishEventInfo.duration)
    pub duration: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.PunishEventInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PunishEventInfo {
    fn default() -> &'a PunishEventInfo {
        <PunishEventInfo as ::protobuf::Message>::default_instance()
    }
}

impl PunishEventInfo {
    pub fn new() -> PunishEventInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "punishType",
            |m: &PunishEventInfo| { &m.punishType },
            |m: &mut PunishEventInfo| { &mut m.punishType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "punishReason",
            |m: &PunishEventInfo| { &m.punishReason },
            |m: &mut PunishEventInfo| { &mut m.punishReason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "punishId",
            |m: &PunishEventInfo| { &m.punishId },
            |m: &mut PunishEventInfo| { &mut m.punishId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "violationUid",
            |m: &PunishEventInfo| { &m.violationUid },
            |m: &mut PunishEventInfo| { &mut m.violationUid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "punishTypeId",
            |m: &PunishEventInfo| { &m.punishTypeId },
            |m: &mut PunishEventInfo| { &mut m.punishTypeId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &PunishEventInfo| { &m.duration },
            |m: &mut PunishEventInfo| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PunishEventInfo>(
            "PunishEventInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PunishEventInfo {
    const NAME: &'static str = "PunishEventInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.punishType = is.read_string()?;
                },
                18 => {
                    self.punishReason = is.read_string()?;
                },
                26 => {
                    self.punishId = is.read_string()?;
                },
                32 => {
                    self.violationUid = is.read_int64()?;
                },
                40 => {
                    self.punishTypeId = is.read_int32()?;
                },
                48 => {
                    self.duration = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.punishType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.punishType);
        }
        if !self.punishReason.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.punishReason);
        }
        if !self.punishId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.punishId);
        }
        if self.violationUid != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.violationUid);
        }
        if self.punishTypeId != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.punishTypeId);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.duration);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.punishType.is_empty() {
            os.write_string(1, &self.punishType)?;
        }
        if !self.punishReason.is_empty() {
            os.write_string(2, &self.punishReason)?;
        }
        if !self.punishId.is_empty() {
            os.write_string(3, &self.punishId)?;
        }
        if self.violationUid != 0 {
            os.write_int64(4, self.violationUid)?;
        }
        if self.punishTypeId != 0 {
            os.write_int32(5, self.punishTypeId)?;
        }
        if self.duration != 0 {
            os.write_int64(6, self.duration)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PunishEventInfo {
        PunishEventInfo::new()
    }

    fn clear(&mut self) {
        self.punishType.clear();
        self.punishReason.clear();
        self.punishId.clear();
        self.violationUid = 0;
        self.punishTypeId = 0;
        self.duration = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PunishEventInfo {
        static instance: PunishEventInfo = PunishEventInfo {
            punishType: ::std::string::String::new(),
            punishReason: ::std::string::String::new(),
            punishId: ::std::string::String::new(),
            violationUid: 0,
            punishTypeId: 0,
            duration: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PunishEventInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PunishEventInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PunishEventInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PunishEventInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.MsgFilter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgFilter {
    // message fields
    // @@protoc_insertion_point(field:TikTok.MsgFilter.isGifter)
    pub isGifter: bool,
    // @@protoc_insertion_point(field:TikTok.MsgFilter.isSubscribedToAnchor)
    pub isSubscribedToAnchor: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.MsgFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgFilter {
    fn default() -> &'a MsgFilter {
        <MsgFilter as ::protobuf::Message>::default_instance()
    }
}

impl MsgFilter {
    pub fn new() -> MsgFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isGifter",
            |m: &MsgFilter| { &m.isGifter },
            |m: &mut MsgFilter| { &mut m.isGifter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isSubscribedToAnchor",
            |m: &MsgFilter| { &m.isSubscribedToAnchor },
            |m: &mut MsgFilter| { &mut m.isSubscribedToAnchor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgFilter>(
            "MsgFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgFilter {
    const NAME: &'static str = "MsgFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.isGifter = is.read_bool()?;
                },
                16 => {
                    self.isSubscribedToAnchor = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.isGifter != false {
            my_size += 1 + 1;
        }
        if self.isSubscribedToAnchor != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.isGifter != false {
            os.write_bool(1, self.isGifter)?;
        }
        if self.isSubscribedToAnchor != false {
            os.write_bool(2, self.isSubscribedToAnchor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgFilter {
        MsgFilter::new()
    }

    fn clear(&mut self) {
        self.isGifter = false;
        self.isSubscribedToAnchor = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgFilter {
        static instance: MsgFilter = MsgFilter {
            isGifter: false,
            isSubscribedToAnchor: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.UserIdentity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserIdentity {
    // message fields
    // @@protoc_insertion_point(field:TikTok.UserIdentity.isGiftGiverOfAnchor)
    pub isGiftGiverOfAnchor: bool,
    // @@protoc_insertion_point(field:TikTok.UserIdentity.isSubscriberOfAnchor)
    pub isSubscriberOfAnchor: bool,
    // @@protoc_insertion_point(field:TikTok.UserIdentity.isMutualFollowingWithAnchor)
    pub isMutualFollowingWithAnchor: bool,
    // @@protoc_insertion_point(field:TikTok.UserIdentity.isFollowerOfAnchor)
    pub isFollowerOfAnchor: bool,
    // @@protoc_insertion_point(field:TikTok.UserIdentity.isModeratorOfAnchor)
    pub isModeratorOfAnchor: bool,
    // @@protoc_insertion_point(field:TikTok.UserIdentity.isAnchor)
    pub isAnchor: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.UserIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserIdentity {
    fn default() -> &'a UserIdentity {
        <UserIdentity as ::protobuf::Message>::default_instance()
    }
}

impl UserIdentity {
    pub fn new() -> UserIdentity {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isGiftGiverOfAnchor",
            |m: &UserIdentity| { &m.isGiftGiverOfAnchor },
            |m: &mut UserIdentity| { &mut m.isGiftGiverOfAnchor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isSubscriberOfAnchor",
            |m: &UserIdentity| { &m.isSubscriberOfAnchor },
            |m: &mut UserIdentity| { &mut m.isSubscriberOfAnchor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isMutualFollowingWithAnchor",
            |m: &UserIdentity| { &m.isMutualFollowingWithAnchor },
            |m: &mut UserIdentity| { &mut m.isMutualFollowingWithAnchor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isFollowerOfAnchor",
            |m: &UserIdentity| { &m.isFollowerOfAnchor },
            |m: &mut UserIdentity| { &mut m.isFollowerOfAnchor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isModeratorOfAnchor",
            |m: &UserIdentity| { &m.isModeratorOfAnchor },
            |m: &mut UserIdentity| { &mut m.isModeratorOfAnchor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isAnchor",
            |m: &UserIdentity| { &m.isAnchor },
            |m: &mut UserIdentity| { &mut m.isAnchor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserIdentity>(
            "UserIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserIdentity {
    const NAME: &'static str = "UserIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.isGiftGiverOfAnchor = is.read_bool()?;
                },
                16 => {
                    self.isSubscriberOfAnchor = is.read_bool()?;
                },
                24 => {
                    self.isMutualFollowingWithAnchor = is.read_bool()?;
                },
                32 => {
                    self.isFollowerOfAnchor = is.read_bool()?;
                },
                40 => {
                    self.isModeratorOfAnchor = is.read_bool()?;
                },
                48 => {
                    self.isAnchor = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.isGiftGiverOfAnchor != false {
            my_size += 1 + 1;
        }
        if self.isSubscriberOfAnchor != false {
            my_size += 1 + 1;
        }
        if self.isMutualFollowingWithAnchor != false {
            my_size += 1 + 1;
        }
        if self.isFollowerOfAnchor != false {
            my_size += 1 + 1;
        }
        if self.isModeratorOfAnchor != false {
            my_size += 1 + 1;
        }
        if self.isAnchor != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.isGiftGiverOfAnchor != false {
            os.write_bool(1, self.isGiftGiverOfAnchor)?;
        }
        if self.isSubscriberOfAnchor != false {
            os.write_bool(2, self.isSubscriberOfAnchor)?;
        }
        if self.isMutualFollowingWithAnchor != false {
            os.write_bool(3, self.isMutualFollowingWithAnchor)?;
        }
        if self.isFollowerOfAnchor != false {
            os.write_bool(4, self.isFollowerOfAnchor)?;
        }
        if self.isModeratorOfAnchor != false {
            os.write_bool(5, self.isModeratorOfAnchor)?;
        }
        if self.isAnchor != false {
            os.write_bool(6, self.isAnchor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserIdentity {
        UserIdentity::new()
    }

    fn clear(&mut self) {
        self.isGiftGiverOfAnchor = false;
        self.isSubscriberOfAnchor = false;
        self.isMutualFollowingWithAnchor = false;
        self.isFollowerOfAnchor = false;
        self.isModeratorOfAnchor = false;
        self.isAnchor = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserIdentity {
        static instance: UserIdentity = UserIdentity {
            isGiftGiverOfAnchor: false,
            isSubscriberOfAnchor: false,
            isMutualFollowingWithAnchor: false,
            isFollowerOfAnchor: false,
            isModeratorOfAnchor: false,
            isAnchor: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.Goal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Goal {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Goal.id)
    pub id: i64,
    // @@protoc_insertion_point(field:TikTok.Goal.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Goal.auditStatus)
    pub auditStatus: i32,
    // @@protoc_insertion_point(field:TikTok.Goal.startTime)
    pub startTime: i64,
    // @@protoc_insertion_point(field:TikTok.Goal.expireTime)
    pub expireTime: i64,
    // @@protoc_insertion_point(field:TikTok.Goal.realFinishTime)
    pub realFinishTime: i64,
    // @@protoc_insertion_point(field:TikTok.Goal.contributorsList)
    pub contributorsList: ::std::vec::Vec<goal::GoalContributor>,
    // @@protoc_insertion_point(field:TikTok.Goal.contributorsLength)
    pub contributorsLength: i32,
    // @@protoc_insertion_point(field:TikTok.Goal.idStr)
    pub idStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Goal.auditDescription)
    pub auditDescription: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Goal.stats)
    pub stats: ::protobuf::MessageField<goal::GoalStats>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Goal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Goal {
    fn default() -> &'a Goal {
        <Goal as ::protobuf::Message>::default_instance()
    }
}

impl Goal {
    pub fn new() -> Goal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Goal| { &m.id },
            |m: &mut Goal| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Goal| { &m.description },
            |m: &mut Goal| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auditStatus",
            |m: &Goal| { &m.auditStatus },
            |m: &mut Goal| { &mut m.auditStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "startTime",
            |m: &Goal| { &m.startTime },
            |m: &mut Goal| { &mut m.startTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expireTime",
            |m: &Goal| { &m.expireTime },
            |m: &mut Goal| { &mut m.expireTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realFinishTime",
            |m: &Goal| { &m.realFinishTime },
            |m: &mut Goal| { &mut m.realFinishTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contributorsList",
            |m: &Goal| { &m.contributorsList },
            |m: &mut Goal| { &mut m.contributorsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contributorsLength",
            |m: &Goal| { &m.contributorsLength },
            |m: &mut Goal| { &mut m.contributorsLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "idStr",
            |m: &Goal| { &m.idStr },
            |m: &mut Goal| { &mut m.idStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auditDescription",
            |m: &Goal| { &m.auditDescription },
            |m: &mut Goal| { &mut m.auditDescription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, goal::GoalStats>(
            "stats",
            |m: &Goal| { &m.stats },
            |m: &mut Goal| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Goal>(
            "Goal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Goal {
    const NAME: &'static str = "Goal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                42 => {
                    self.description = is.read_string()?;
                },
                48 => {
                    self.auditStatus = is.read_int32()?;
                },
                64 => {
                    self.startTime = is.read_int64()?;
                },
                72 => {
                    self.expireTime = is.read_int64()?;
                },
                80 => {
                    self.realFinishTime = is.read_int64()?;
                },
                90 => {
                    self.contributorsList.push(is.read_message()?);
                },
                96 => {
                    self.contributorsLength = is.read_int32()?;
                },
                106 => {
                    self.idStr = is.read_string()?;
                },
                114 => {
                    self.auditDescription = is.read_string()?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.description);
        }
        if self.auditStatus != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.auditStatus);
        }
        if self.startTime != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.startTime);
        }
        if self.expireTime != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.expireTime);
        }
        if self.realFinishTime != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.realFinishTime);
        }
        for value in &self.contributorsList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.contributorsLength != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.contributorsLength);
        }
        if !self.idStr.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.idStr);
        }
        if !self.auditDescription.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.auditDescription);
        }
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(5, &self.description)?;
        }
        if self.auditStatus != 0 {
            os.write_int32(6, self.auditStatus)?;
        }
        if self.startTime != 0 {
            os.write_int64(8, self.startTime)?;
        }
        if self.expireTime != 0 {
            os.write_int64(9, self.expireTime)?;
        }
        if self.realFinishTime != 0 {
            os.write_int64(10, self.realFinishTime)?;
        }
        for v in &self.contributorsList {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if self.contributorsLength != 0 {
            os.write_int32(12, self.contributorsLength)?;
        }
        if !self.idStr.is_empty() {
            os.write_string(13, &self.idStr)?;
        }
        if !self.auditDescription.is_empty() {
            os.write_string(14, &self.auditDescription)?;
        }
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Goal {
        Goal::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.description.clear();
        self.auditStatus = 0;
        self.startTime = 0;
        self.expireTime = 0;
        self.realFinishTime = 0;
        self.contributorsList.clear();
        self.contributorsLength = 0;
        self.idStr.clear();
        self.auditDescription.clear();
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Goal {
        static instance: Goal = Goal {
            id: 0,
            description: ::std::string::String::new(),
            auditStatus: 0,
            startTime: 0,
            expireTime: 0,
            realFinishTime: 0,
            contributorsList: ::std::vec::Vec::new(),
            contributorsLength: 0,
            idStr: ::std::string::String::new(),
            auditDescription: ::std::string::String::new(),
            stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Goal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Goal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Goal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Goal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Goal`
pub mod goal {
    // @@protoc_insertion_point(message:TikTok.Goal.GoalStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GoalStats {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Goal.GoalStats.totalCoins)
        pub totalCoins: i64,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalStats.totalContributor)
        pub totalContributor: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Goal.GoalStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GoalStats {
        fn default() -> &'a GoalStats {
            <GoalStats as ::protobuf::Message>::default_instance()
        }
    }

    impl GoalStats {
        pub fn new() -> GoalStats {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "totalCoins",
                |m: &GoalStats| { &m.totalCoins },
                |m: &mut GoalStats| { &mut m.totalCoins },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "totalContributor",
                |m: &GoalStats| { &m.totalContributor },
                |m: &mut GoalStats| { &mut m.totalContributor },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoalStats>(
                "Goal.GoalStats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GoalStats {
        const NAME: &'static str = "GoalStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.totalCoins = is.read_int64()?;
                    },
                    16 => {
                        self.totalContributor = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.totalCoins != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.totalCoins);
            }
            if self.totalContributor != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.totalContributor);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.totalCoins != 0 {
                os.write_int64(1, self.totalCoins)?;
            }
            if self.totalContributor != 0 {
                os.write_int64(2, self.totalContributor)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GoalStats {
            GoalStats::new()
        }

        fn clear(&mut self) {
            self.totalCoins = 0;
            self.totalContributor = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GoalStats {
            static instance: GoalStats = GoalStats {
                totalCoins: 0,
                totalContributor: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GoalStats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Goal.GoalStats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GoalStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GoalStats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.Goal.GoalContributor)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GoalContributor {
        // message fields
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.userId)
        pub userId: i64,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.avatar)
        pub avatar: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.displayId)
        pub displayId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.score)
        pub score: i64,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.userIdStr)
        pub userIdStr: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.inRoom)
        pub inRoom: bool,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.isFriend)
        pub isFriend: bool,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.badgeList)
        pub badgeList: ::std::vec::Vec<super::BadgeStruct>,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.followByOwner)
        pub followByOwner: bool,
        // @@protoc_insertion_point(field:TikTok.Goal.GoalContributor.isFistContribute)
        pub isFistContribute: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.Goal.GoalContributor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GoalContributor {
        fn default() -> &'a GoalContributor {
            <GoalContributor as ::protobuf::Message>::default_instance()
        }
    }

    impl GoalContributor {
        pub fn new() -> GoalContributor {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userId",
                |m: &GoalContributor| { &m.userId },
                |m: &mut GoalContributor| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "avatar",
                |m: &GoalContributor| { &m.avatar },
                |m: &mut GoalContributor| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "displayId",
                |m: &GoalContributor| { &m.displayId },
                |m: &mut GoalContributor| { &mut m.displayId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "score",
                |m: &GoalContributor| { &m.score },
                |m: &mut GoalContributor| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userIdStr",
                |m: &GoalContributor| { &m.userIdStr },
                |m: &mut GoalContributor| { &mut m.userIdStr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "inRoom",
                |m: &GoalContributor| { &m.inRoom },
                |m: &mut GoalContributor| { &mut m.inRoom },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isFriend",
                |m: &GoalContributor| { &m.isFriend },
                |m: &mut GoalContributor| { &mut m.isFriend },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "badgeList",
                |m: &GoalContributor| { &m.badgeList },
                |m: &mut GoalContributor| { &mut m.badgeList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "followByOwner",
                |m: &GoalContributor| { &m.followByOwner },
                |m: &mut GoalContributor| { &mut m.followByOwner },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isFistContribute",
                |m: &GoalContributor| { &m.isFistContribute },
                |m: &mut GoalContributor| { &mut m.isFistContribute },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoalContributor>(
                "Goal.GoalContributor",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GoalContributor {
        const NAME: &'static str = "GoalContributor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.userId = is.read_int64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatar)?;
                    },
                    26 => {
                        self.displayId = is.read_string()?;
                    },
                    32 => {
                        self.score = is.read_int64()?;
                    },
                    42 => {
                        self.userIdStr = is.read_string()?;
                    },
                    48 => {
                        self.inRoom = is.read_bool()?;
                    },
                    56 => {
                        self.isFriend = is.read_bool()?;
                    },
                    66 => {
                        self.badgeList.push(is.read_message()?);
                    },
                    72 => {
                        self.followByOwner = is.read_bool()?;
                    },
                    80 => {
                        self.isFistContribute = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.userId != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.userId);
            }
            if let Some(v) = self.avatar.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.displayId.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.displayId);
            }
            if self.score != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.score);
            }
            if !self.userIdStr.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.userIdStr);
            }
            if self.inRoom != false {
                my_size += 1 + 1;
            }
            if self.isFriend != false {
                my_size += 1 + 1;
            }
            for value in &self.badgeList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.followByOwner != false {
                my_size += 1 + 1;
            }
            if self.isFistContribute != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.userId != 0 {
                os.write_int64(1, self.userId)?;
            }
            if let Some(v) = self.avatar.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if !self.displayId.is_empty() {
                os.write_string(3, &self.displayId)?;
            }
            if self.score != 0 {
                os.write_int64(4, self.score)?;
            }
            if !self.userIdStr.is_empty() {
                os.write_string(5, &self.userIdStr)?;
            }
            if self.inRoom != false {
                os.write_bool(6, self.inRoom)?;
            }
            if self.isFriend != false {
                os.write_bool(7, self.isFriend)?;
            }
            for v in &self.badgeList {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if self.followByOwner != false {
                os.write_bool(9, self.followByOwner)?;
            }
            if self.isFistContribute != false {
                os.write_bool(10, self.isFistContribute)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GoalContributor {
            GoalContributor::new()
        }

        fn clear(&mut self) {
            self.userId = 0;
            self.avatar.clear();
            self.displayId.clear();
            self.score = 0;
            self.userIdStr.clear();
            self.inRoom = false;
            self.isFriend = false;
            self.badgeList.clear();
            self.followByOwner = false;
            self.isFistContribute = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GoalContributor {
            static instance: GoalContributor = GoalContributor {
                userId: 0,
                avatar: ::protobuf::MessageField::none(),
                displayId: ::std::string::String::new(),
                score: 0,
                userIdStr: ::std::string::String::new(),
                inRoom: false,
                isFriend: false,
                badgeList: ::std::vec::Vec::new(),
                followByOwner: false,
                isFistContribute: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GoalContributor {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Goal.GoalContributor").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GoalContributor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GoalContributor {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.Indicator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Indicator {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Indicator.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Indicator.op)
    pub op: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Indicator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Indicator {
    fn default() -> &'a Indicator {
        <Indicator as ::protobuf::Message>::default_instance()
    }
}

impl Indicator {
    pub fn new() -> Indicator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Indicator| { &m.key },
            |m: &mut Indicator| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "op",
            |m: &Indicator| { &m.op },
            |m: &mut Indicator| { &mut m.op },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Indicator>(
            "Indicator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Indicator {
    const NAME: &'static str = "Indicator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                16 => {
                    self.op = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.op != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.op);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.op != 0 {
            os.write_int64(2, self.op)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Indicator {
        Indicator::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.op = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Indicator {
        static instance: Indicator = Indicator {
            key: ::std::string::String::new(),
            op: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Indicator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Indicator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Indicator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Indicator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.Ranking)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ranking {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Ranking.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Ranking.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.Ranking.color)
    pub color: ::protobuf::MessageField<TikTokColor>,
    // @@protoc_insertion_point(field:TikTok.Ranking.details)
    pub details: ::std::vec::Vec<ValueLabel>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Ranking.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ranking {
    fn default() -> &'a Ranking {
        <Ranking as ::protobuf::Message>::default_instance()
    }
}

impl Ranking {
    pub fn new() -> Ranking {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Ranking| { &m.type_ },
            |m: &mut Ranking| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &Ranking| { &m.label },
            |m: &mut Ranking| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TikTokColor>(
            "color",
            |m: &Ranking| { &m.color },
            |m: &mut Ranking| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "details",
            |m: &Ranking| { &m.details },
            |m: &mut Ranking| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ranking>(
            "Ranking",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ranking {
    const NAME: &'static str = "Ranking";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                34 => {
                    self.details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.details {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ranking {
        Ranking::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.label.clear();
        self.color.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ranking {
        static instance: Ranking = Ranking {
            type_: ::std::string::String::new(),
            label: ::std::string::String::new(),
            color: ::protobuf::MessageField::none(),
            details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ranking {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ranking").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ranking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ranking {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.TikTokColor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TikTokColor {
    // message fields
    // @@protoc_insertion_point(field:TikTok.TikTokColor.color)
    pub color: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.TikTokColor.id)
    pub id: u64,
    // @@protoc_insertion_point(field:TikTok.TikTokColor.data1)
    pub data1: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.TikTokColor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TikTokColor {
    fn default() -> &'a TikTokColor {
        <TikTokColor as ::protobuf::Message>::default_instance()
    }
}

impl TikTokColor {
    pub fn new() -> TikTokColor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color",
            |m: &TikTokColor| { &m.color },
            |m: &mut TikTokColor| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TikTokColor| { &m.id },
            |m: &mut TikTokColor| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data1",
            |m: &TikTokColor| { &m.data1 },
            |m: &mut TikTokColor| { &mut m.data1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TikTokColor>(
            "TikTokColor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TikTokColor {
    const NAME: &'static str = "TikTokColor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.color = is.read_string()?;
                },
                32 => {
                    self.id = is.read_uint64()?;
                },
                48 => {
                    self.data1 = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.color);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.id);
        }
        if self.data1 != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.data1);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.color.is_empty() {
            os.write_string(1, &self.color)?;
        }
        if self.id != 0 {
            os.write_uint64(4, self.id)?;
        }
        if self.data1 != 0 {
            os.write_uint32(6, self.data1)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TikTokColor {
        TikTokColor::new()
    }

    fn clear(&mut self) {
        self.color.clear();
        self.id = 0;
        self.data1 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TikTokColor {
        static instance: TikTokColor = TikTokColor {
            color: ::std::string::String::new(),
            id: 0,
            data1: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TikTokColor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TikTokColor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TikTokColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TikTokColor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.ValueLabel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValueLabel {
    // message fields
    // @@protoc_insertion_point(field:TikTok.ValueLabel.data)
    pub data: u32,
    // @@protoc_insertion_point(field:TikTok.ValueLabel.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.ValueLabel.label2)
    pub label2: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.ValueLabel.label3)
    pub label3: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.ValueLabel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValueLabel {
    fn default() -> &'a ValueLabel {
        <ValueLabel as ::protobuf::Message>::default_instance()
    }
}

impl ValueLabel {
    pub fn new() -> ValueLabel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ValueLabel| { &m.data },
            |m: &mut ValueLabel| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &ValueLabel| { &m.label },
            |m: &mut ValueLabel| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label2",
            |m: &ValueLabel| { &m.label2 },
            |m: &mut ValueLabel| { &mut m.label2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label3",
            |m: &ValueLabel| { &m.label3 },
            |m: &mut ValueLabel| { &mut m.label3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueLabel>(
            "ValueLabel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValueLabel {
    const NAME: &'static str = "ValueLabel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data = is.read_uint32()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                26 => {
                    self.label2 = is.read_string()?;
                },
                90 => {
                    self.label3 = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.data != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.data);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if !self.label2.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.label2);
        }
        if !self.label3.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.label3);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.data != 0 {
            os.write_uint32(1, self.data)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if !self.label2.is_empty() {
            os.write_string(3, &self.label2)?;
        }
        if !self.label3.is_empty() {
            os.write_string(11, &self.label3)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValueLabel {
        ValueLabel::new()
    }

    fn clear(&mut self) {
        self.data = 0;
        self.label.clear();
        self.label2.clear();
        self.label3.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValueLabel {
        static instance: ValueLabel = ValueLabel {
            data: 0,
            label: ::std::string::String::new(),
            label2: ::std::string::String::new(),
            label3: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValueLabel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValueLabel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValueLabel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueLabel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.MessageDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageDetails {
    // message fields
    // @@protoc_insertion_point(field:TikTok.MessageDetails.data1)
    pub data1: u32,
    // @@protoc_insertion_point(field:TikTok.MessageDetails.color)
    pub color: ::protobuf::MessageField<TikTokColor>,
    // @@protoc_insertion_point(field:TikTok.MessageDetails.category)
    pub category: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.MessageDetails.user)
    pub user: ::protobuf::MessageField<UserContainer>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.MessageDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageDetails {
    fn default() -> &'a MessageDetails {
        <MessageDetails as ::protobuf::Message>::default_instance()
    }
}

impl MessageDetails {
    pub fn new() -> MessageDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data1",
            |m: &MessageDetails| { &m.data1 },
            |m: &mut MessageDetails| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TikTokColor>(
            "color",
            |m: &MessageDetails| { &m.color },
            |m: &mut MessageDetails| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "category",
            |m: &MessageDetails| { &m.category },
            |m: &mut MessageDetails| { &mut m.category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserContainer>(
            "user",
            |m: &MessageDetails| { &m.user },
            |m: &mut MessageDetails| { &mut m.user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageDetails>(
            "MessageDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageDetails {
    const NAME: &'static str = "MessageDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data1 = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                90 => {
                    self.category = is.read_string()?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.data1 != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.data1);
        }
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.category.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.category);
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.data1 != 0 {
            os.write_uint32(1, self.data1)?;
        }
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.category.is_empty() {
            os.write_string(11, &self.category)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageDetails {
        MessageDetails::new()
    }

    fn clear(&mut self) {
        self.data1 = 0;
        self.color.clear();
        self.category.clear();
        self.user.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageDetails {
        static instance: MessageDetails = MessageDetails {
            data1: 0,
            color: ::protobuf::MessageField::none(),
            category: ::std::string::String::new(),
            user: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.UserContainer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserContainer {
    // message fields
    // @@protoc_insertion_point(field:TikTok.UserContainer.user)
    pub user: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.UserContainer.data1)
    pub data1: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.UserContainer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserContainer {
    fn default() -> &'a UserContainer {
        <UserContainer as ::protobuf::Message>::default_instance()
    }
}

impl UserContainer {
    pub fn new() -> UserContainer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "user",
            |m: &UserContainer| { &m.user },
            |m: &mut UserContainer| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data1",
            |m: &UserContainer| { &m.data1 },
            |m: &mut UserContainer| { &mut m.data1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserContainer>(
            "UserContainer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserContainer {
    const NAME: &'static str = "UserContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                16 => {
                    self.data1 = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.data1 != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.data1);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.data1 != 0 {
            os.write_uint32(2, self.data1)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserContainer {
        UserContainer::new()
    }

    fn clear(&mut self) {
        self.user.clear();
        self.data1 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserContainer {
        static instance: UserContainer = UserContainer {
            user: ::protobuf::MessageField::none(),
            data1: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserContainer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserContainer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserContainer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.DataContainer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DataContainer {
    // message fields
    // @@protoc_insertion_point(field:TikTok.DataContainer.data1)
    pub data1: u64,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data2)
    pub data2: u32,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data3)
    pub data3: u32,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data4)
    pub data4: u32,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data5)
    pub data5: u32,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data6)
    pub data6: u32,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data7)
    pub data7: u32,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data8)
    pub data8: u32,
    // @@protoc_insertion_point(field:TikTok.DataContainer.data9)
    pub data9: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.DataContainer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataContainer {
    fn default() -> &'a DataContainer {
        <DataContainer as ::protobuf::Message>::default_instance()
    }
}

impl DataContainer {
    pub fn new() -> DataContainer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data1",
            |m: &DataContainer| { &m.data1 },
            |m: &mut DataContainer| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data2",
            |m: &DataContainer| { &m.data2 },
            |m: &mut DataContainer| { &mut m.data2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data3",
            |m: &DataContainer| { &m.data3 },
            |m: &mut DataContainer| { &mut m.data3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data4",
            |m: &DataContainer| { &m.data4 },
            |m: &mut DataContainer| { &mut m.data4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data5",
            |m: &DataContainer| { &m.data5 },
            |m: &mut DataContainer| { &mut m.data5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data6",
            |m: &DataContainer| { &m.data6 },
            |m: &mut DataContainer| { &mut m.data6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data7",
            |m: &DataContainer| { &m.data7 },
            |m: &mut DataContainer| { &mut m.data7 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data8",
            |m: &DataContainer| { &m.data8 },
            |m: &mut DataContainer| { &mut m.data8 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data9",
            |m: &DataContainer| { &m.data9 },
            |m: &mut DataContainer| { &mut m.data9 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataContainer>(
            "DataContainer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataContainer {
    const NAME: &'static str = "DataContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data1 = is.read_uint64()?;
                },
                16 => {
                    self.data2 = is.read_uint32()?;
                },
                24 => {
                    self.data3 = is.read_uint32()?;
                },
                32 => {
                    self.data4 = is.read_uint32()?;
                },
                40 => {
                    self.data5 = is.read_uint32()?;
                },
                48 => {
                    self.data6 = is.read_uint32()?;
                },
                56 => {
                    self.data7 = is.read_uint32()?;
                },
                64 => {
                    self.data8 = is.read_uint32()?;
                },
                72 => {
                    self.data9 = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.data1 != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.data1);
        }
        if self.data2 != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.data2);
        }
        if self.data3 != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.data3);
        }
        if self.data4 != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.data4);
        }
        if self.data5 != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.data5);
        }
        if self.data6 != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.data6);
        }
        if self.data7 != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.data7);
        }
        if self.data8 != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.data8);
        }
        if self.data9 != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.data9);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.data1 != 0 {
            os.write_uint64(1, self.data1)?;
        }
        if self.data2 != 0 {
            os.write_uint32(2, self.data2)?;
        }
        if self.data3 != 0 {
            os.write_uint32(3, self.data3)?;
        }
        if self.data4 != 0 {
            os.write_uint32(4, self.data4)?;
        }
        if self.data5 != 0 {
            os.write_uint32(5, self.data5)?;
        }
        if self.data6 != 0 {
            os.write_uint32(6, self.data6)?;
        }
        if self.data7 != 0 {
            os.write_uint32(7, self.data7)?;
        }
        if self.data8 != 0 {
            os.write_uint32(8, self.data8)?;
        }
        if self.data9 != 0 {
            os.write_uint32(9, self.data9)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataContainer {
        DataContainer::new()
    }

    fn clear(&mut self) {
        self.data1 = 0;
        self.data2 = 0;
        self.data3 = 0;
        self.data4 = 0;
        self.data5 = 0;
        self.data6 = 0;
        self.data7 = 0;
        self.data8 = 0;
        self.data9 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataContainer {
        static instance: DataContainer = DataContainer {
            data1: 0,
            data2: 0,
            data3: 0,
            data4: 0,
            data5: 0,
            data6: 0,
            data7: 0,
            data8: 0,
            data9: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataContainer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataContainer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataContainer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.TimeStampContainer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TimeStampContainer {
    // message fields
    // @@protoc_insertion_point(field:TikTok.TimeStampContainer.timestamp1)
    pub timestamp1: u64,
    // @@protoc_insertion_point(field:TikTok.TimeStampContainer.timestamp2)
    pub timestamp2: u64,
    // @@protoc_insertion_point(field:TikTok.TimeStampContainer.timestamp3)
    pub timestamp3: u64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.TimeStampContainer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeStampContainer {
    fn default() -> &'a TimeStampContainer {
        <TimeStampContainer as ::protobuf::Message>::default_instance()
    }
}

impl TimeStampContainer {
    pub fn new() -> TimeStampContainer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp1",
            |m: &TimeStampContainer| { &m.timestamp1 },
            |m: &mut TimeStampContainer| { &mut m.timestamp1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp2",
            |m: &TimeStampContainer| { &m.timestamp2 },
            |m: &mut TimeStampContainer| { &mut m.timestamp2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp3",
            |m: &TimeStampContainer| { &m.timestamp3 },
            |m: &mut TimeStampContainer| { &mut m.timestamp3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeStampContainer>(
            "TimeStampContainer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeStampContainer {
    const NAME: &'static str = "TimeStampContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp1 = is.read_uint64()?;
                },
                16 => {
                    self.timestamp2 = is.read_uint64()?;
                },
                24 => {
                    self.timestamp3 = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp1 != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.timestamp1);
        }
        if self.timestamp2 != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.timestamp2);
        }
        if self.timestamp3 != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.timestamp3);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp1 != 0 {
            os.write_uint64(1, self.timestamp1)?;
        }
        if self.timestamp2 != 0 {
            os.write_uint64(2, self.timestamp2)?;
        }
        if self.timestamp3 != 0 {
            os.write_uint64(3, self.timestamp3)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeStampContainer {
        TimeStampContainer::new()
    }

    fn clear(&mut self) {
        self.timestamp1 = 0;
        self.timestamp2 = 0;
        self.timestamp3 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeStampContainer {
        static instance: TimeStampContainer = TimeStampContainer {
            timestamp1: 0,
            timestamp2: 0,
            timestamp3: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeStampContainer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeStampContainer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeStampContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStampContainer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.MemberMessageData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MemberMessageData {
    // message fields
    // @@protoc_insertion_point(field:TikTok.MemberMessageData.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.MemberMessageData.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.MemberMessageData.color)
    pub color: ::protobuf::MessageField<TikTokColor>,
    // @@protoc_insertion_point(field:TikTok.MemberMessageData.details)
    pub details: ::std::vec::Vec<MessageDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.MemberMessageData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemberMessageData {
    fn default() -> &'a MemberMessageData {
        <MemberMessageData as ::protobuf::Message>::default_instance()
    }
}

impl MemberMessageData {
    pub fn new() -> MemberMessageData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MemberMessageData| { &m.type_ },
            |m: &mut MemberMessageData| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &MemberMessageData| { &m.label },
            |m: &mut MemberMessageData| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TikTokColor>(
            "color",
            |m: &MemberMessageData| { &m.color },
            |m: &mut MemberMessageData| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "details",
            |m: &MemberMessageData| { &m.details },
            |m: &mut MemberMessageData| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemberMessageData>(
            "MemberMessageData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemberMessageData {
    const NAME: &'static str = "MemberMessageData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                34 => {
                    self.details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.details {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemberMessageData {
        MemberMessageData::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.label.clear();
        self.color.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemberMessageData {
        static instance: MemberMessageData = MemberMessageData {
            type_: ::std::string::String::new(),
            label: ::std::string::String::new(),
            color: ::protobuf::MessageField::none(),
            details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MemberMessageData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemberMessageData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemberMessageData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberMessageData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkMicArmiesItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkMicArmiesItems {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkMicArmiesItems.hostUserId)
    pub hostUserId: u64,
    // @@protoc_insertion_point(field:TikTok.LinkMicArmiesItems.battleGroups)
    pub battleGroups: ::std::vec::Vec<link_mic_armies_items::LinkMicArmiesGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkMicArmiesItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkMicArmiesItems {
    fn default() -> &'a LinkMicArmiesItems {
        <LinkMicArmiesItems as ::protobuf::Message>::default_instance()
    }
}

impl LinkMicArmiesItems {
    pub fn new() -> LinkMicArmiesItems {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hostUserId",
            |m: &LinkMicArmiesItems| { &m.hostUserId },
            |m: &mut LinkMicArmiesItems| { &mut m.hostUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "battleGroups",
            |m: &LinkMicArmiesItems| { &m.battleGroups },
            |m: &mut LinkMicArmiesItems| { &mut m.battleGroups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicArmiesItems>(
            "LinkMicArmiesItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkMicArmiesItems {
    const NAME: &'static str = "LinkMicArmiesItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hostUserId = is.read_uint64()?;
                },
                18 => {
                    self.battleGroups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.hostUserId != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.hostUserId);
        }
        for value in &self.battleGroups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.hostUserId != 0 {
            os.write_uint64(1, self.hostUserId)?;
        }
        for v in &self.battleGroups {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkMicArmiesItems {
        LinkMicArmiesItems::new()
    }

    fn clear(&mut self) {
        self.hostUserId = 0;
        self.battleGroups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkMicArmiesItems {
        static instance: LinkMicArmiesItems = LinkMicArmiesItems {
            hostUserId: 0,
            battleGroups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkMicArmiesItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkMicArmiesItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkMicArmiesItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkMicArmiesItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LinkMicArmiesItems`
pub mod link_mic_armies_items {
    // @@protoc_insertion_point(message:TikTok.LinkMicArmiesItems.LinkMicArmiesGroup)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkMicArmiesGroup {
        // message fields
        // @@protoc_insertion_point(field:TikTok.LinkMicArmiesItems.LinkMicArmiesGroup.users)
        pub users: ::std::vec::Vec<super::User>,
        // @@protoc_insertion_point(field:TikTok.LinkMicArmiesItems.LinkMicArmiesGroup.points)
        pub points: u32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.LinkMicArmiesItems.LinkMicArmiesGroup.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkMicArmiesGroup {
        fn default() -> &'a LinkMicArmiesGroup {
            <LinkMicArmiesGroup as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkMicArmiesGroup {
        pub fn new() -> LinkMicArmiesGroup {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "users",
                |m: &LinkMicArmiesGroup| { &m.users },
                |m: &mut LinkMicArmiesGroup| { &mut m.users },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "points",
                |m: &LinkMicArmiesGroup| { &m.points },
                |m: &mut LinkMicArmiesGroup| { &mut m.points },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicArmiesGroup>(
                "LinkMicArmiesItems.LinkMicArmiesGroup",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkMicArmiesGroup {
        const NAME: &'static str = "LinkMicArmiesGroup";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.users.push(is.read_message()?);
                    },
                    16 => {
                        self.points = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.users {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.points != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.points);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.users {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if self.points != 0 {
                os.write_uint32(2, self.points)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkMicArmiesGroup {
            LinkMicArmiesGroup::new()
        }

        fn clear(&mut self) {
            self.users.clear();
            self.points = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkMicArmiesGroup {
            static instance: LinkMicArmiesGroup = LinkMicArmiesGroup {
                users: ::std::vec::Vec::new(),
                points: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkMicArmiesGroup {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LinkMicArmiesItems.LinkMicArmiesGroup").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkMicArmiesGroup {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkMicArmiesGroup {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.PollStartContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PollStartContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.PollStartContent.StartTime)
    pub StartTime: i64,
    // @@protoc_insertion_point(field:TikTok.PollStartContent.EndTime)
    pub EndTime: i64,
    // @@protoc_insertion_point(field:TikTok.PollStartContent.OptionList)
    pub OptionList: ::std::vec::Vec<PollOptionInfo>,
    // @@protoc_insertion_point(field:TikTok.PollStartContent.Title)
    pub Title: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.PollStartContent.Operator)
    pub Operator: ::protobuf::MessageField<User>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.PollStartContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollStartContent {
    fn default() -> &'a PollStartContent {
        <PollStartContent as ::protobuf::Message>::default_instance()
    }
}

impl PollStartContent {
    pub fn new() -> PollStartContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "StartTime",
            |m: &PollStartContent| { &m.StartTime },
            |m: &mut PollStartContent| { &mut m.StartTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EndTime",
            |m: &PollStartContent| { &m.EndTime },
            |m: &mut PollStartContent| { &mut m.EndTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "OptionList",
            |m: &PollStartContent| { &m.OptionList },
            |m: &mut PollStartContent| { &mut m.OptionList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Title",
            |m: &PollStartContent| { &m.Title },
            |m: &mut PollStartContent| { &mut m.Title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "Operator",
            |m: &PollStartContent| { &m.Operator },
            |m: &mut PollStartContent| { &mut m.Operator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollStartContent>(
            "PollStartContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollStartContent {
    const NAME: &'static str = "PollStartContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.StartTime = is.read_int64()?;
                },
                16 => {
                    self.EndTime = is.read_int64()?;
                },
                26 => {
                    self.OptionList.push(is.read_message()?);
                },
                34 => {
                    self.Title = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Operator)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.StartTime != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.StartTime);
        }
        if self.EndTime != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.EndTime);
        }
        for value in &self.OptionList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.Title.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Title);
        }
        if let Some(v) = self.Operator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.StartTime != 0 {
            os.write_int64(1, self.StartTime)?;
        }
        if self.EndTime != 0 {
            os.write_int64(2, self.EndTime)?;
        }
        for v in &self.OptionList {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.Title.is_empty() {
            os.write_string(4, &self.Title)?;
        }
        if let Some(v) = self.Operator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollStartContent {
        PollStartContent::new()
    }

    fn clear(&mut self) {
        self.StartTime = 0;
        self.EndTime = 0;
        self.OptionList.clear();
        self.Title.clear();
        self.Operator.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollStartContent {
        static instance: PollStartContent = PollStartContent {
            StartTime: 0,
            EndTime: 0,
            OptionList: ::std::vec::Vec::new(),
            Title: ::std::string::String::new(),
            Operator: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollStartContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollStartContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollStartContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollStartContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.PollEndContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PollEndContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.PollEndContent.EndType)
    pub EndType: i32,
    // @@protoc_insertion_point(field:TikTok.PollEndContent.OptionList)
    pub OptionList: ::std::vec::Vec<PollOptionInfo>,
    // @@protoc_insertion_point(field:TikTok.PollEndContent.Operator)
    pub Operator: ::protobuf::MessageField<User>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.PollEndContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollEndContent {
    fn default() -> &'a PollEndContent {
        <PollEndContent as ::protobuf::Message>::default_instance()
    }
}

impl PollEndContent {
    pub fn new() -> PollEndContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EndType",
            |m: &PollEndContent| { &m.EndType },
            |m: &mut PollEndContent| { &mut m.EndType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "OptionList",
            |m: &PollEndContent| { &m.OptionList },
            |m: &mut PollEndContent| { &mut m.OptionList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "Operator",
            |m: &PollEndContent| { &m.Operator },
            |m: &mut PollEndContent| { &mut m.Operator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollEndContent>(
            "PollEndContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollEndContent {
    const NAME: &'static str = "PollEndContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.EndType = is.read_int32()?;
                },
                18 => {
                    self.OptionList.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Operator)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.EndType != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.EndType);
        }
        for value in &self.OptionList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.Operator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.EndType != 0 {
            os.write_int32(1, self.EndType)?;
        }
        for v in &self.OptionList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.Operator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollEndContent {
        PollEndContent::new()
    }

    fn clear(&mut self) {
        self.EndType = 0;
        self.OptionList.clear();
        self.Operator.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollEndContent {
        static instance: PollEndContent = PollEndContent {
            EndType: 0,
            OptionList: ::std::vec::Vec::new(),
            Operator: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollEndContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollEndContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollEndContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollEndContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.PollOptionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PollOptionInfo {
    // message fields
    // @@protoc_insertion_point(field:TikTok.PollOptionInfo.Votes)
    pub Votes: i32,
    // @@protoc_insertion_point(field:TikTok.PollOptionInfo.DisplayContent)
    pub DisplayContent: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.PollOptionInfo.OptionIdx)
    pub OptionIdx: i32,
    // @@protoc_insertion_point(field:TikTok.PollOptionInfo.VoteUserList)
    pub VoteUserList: ::std::vec::Vec<VoteUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.PollOptionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollOptionInfo {
    fn default() -> &'a PollOptionInfo {
        <PollOptionInfo as ::protobuf::Message>::default_instance()
    }
}

impl PollOptionInfo {
    pub fn new() -> PollOptionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Votes",
            |m: &PollOptionInfo| { &m.Votes },
            |m: &mut PollOptionInfo| { &mut m.Votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DisplayContent",
            |m: &PollOptionInfo| { &m.DisplayContent },
            |m: &mut PollOptionInfo| { &mut m.DisplayContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OptionIdx",
            |m: &PollOptionInfo| { &m.OptionIdx },
            |m: &mut PollOptionInfo| { &mut m.OptionIdx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "VoteUserList",
            |m: &PollOptionInfo| { &m.VoteUserList },
            |m: &mut PollOptionInfo| { &mut m.VoteUserList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollOptionInfo>(
            "PollOptionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollOptionInfo {
    const NAME: &'static str = "PollOptionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Votes = is.read_int32()?;
                },
                18 => {
                    self.DisplayContent = is.read_string()?;
                },
                24 => {
                    self.OptionIdx = is.read_int32()?;
                },
                34 => {
                    self.VoteUserList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Votes != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.Votes);
        }
        if !self.DisplayContent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.DisplayContent);
        }
        if self.OptionIdx != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.OptionIdx);
        }
        for value in &self.VoteUserList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Votes != 0 {
            os.write_int32(1, self.Votes)?;
        }
        if !self.DisplayContent.is_empty() {
            os.write_string(2, &self.DisplayContent)?;
        }
        if self.OptionIdx != 0 {
            os.write_int32(3, self.OptionIdx)?;
        }
        for v in &self.VoteUserList {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollOptionInfo {
        PollOptionInfo::new()
    }

    fn clear(&mut self) {
        self.Votes = 0;
        self.DisplayContent.clear();
        self.OptionIdx = 0;
        self.VoteUserList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollOptionInfo {
        static instance: PollOptionInfo = PollOptionInfo {
            Votes: 0,
            DisplayContent: ::std::string::String::new(),
            OptionIdx: 0,
            VoteUserList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollOptionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollOptionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollOptionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollOptionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.VoteUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoteUser {
    // message fields
    // @@protoc_insertion_point(field:TikTok.VoteUser.UserId)
    pub UserId: i64,
    // @@protoc_insertion_point(field:TikTok.VoteUser.NickName)
    pub NickName: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.VoteUser.AvatarThumb)
    pub AvatarThumb: ::protobuf::MessageField<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.VoteUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoteUser {
    fn default() -> &'a VoteUser {
        <VoteUser as ::protobuf::Message>::default_instance()
    }
}

impl VoteUser {
    pub fn new() -> VoteUser {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UserId",
            |m: &VoteUser| { &m.UserId },
            |m: &mut VoteUser| { &mut m.UserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NickName",
            |m: &VoteUser| { &m.NickName },
            |m: &mut VoteUser| { &mut m.NickName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "AvatarThumb",
            |m: &VoteUser| { &m.AvatarThumb },
            |m: &mut VoteUser| { &mut m.AvatarThumb },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoteUser>(
            "VoteUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoteUser {
    const NAME: &'static str = "VoteUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.UserId = is.read_int64()?;
                },
                18 => {
                    self.NickName = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.AvatarThumb)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.UserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.UserId);
        }
        if !self.NickName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.NickName);
        }
        if let Some(v) = self.AvatarThumb.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.UserId != 0 {
            os.write_int64(1, self.UserId)?;
        }
        if !self.NickName.is_empty() {
            os.write_string(2, &self.NickName)?;
        }
        if let Some(v) = self.AvatarThumb.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoteUser {
        VoteUser::new()
    }

    fn clear(&mut self) {
        self.UserId = 0;
        self.NickName.clear();
        self.AvatarThumb.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoteUser {
        static instance: VoteUser = VoteUser {
            UserId: 0,
            NickName: ::std::string::String::new(),
            AvatarThumb: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoteUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoteUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoteUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.PollUpdateVotesContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PollUpdateVotesContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.PollUpdateVotesContent.OptionList)
    pub OptionList: ::std::vec::Vec<PollOptionInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.PollUpdateVotesContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollUpdateVotesContent {
    fn default() -> &'a PollUpdateVotesContent {
        <PollUpdateVotesContent as ::protobuf::Message>::default_instance()
    }
}

impl PollUpdateVotesContent {
    pub fn new() -> PollUpdateVotesContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "OptionList",
            |m: &PollUpdateVotesContent| { &m.OptionList },
            |m: &mut PollUpdateVotesContent| { &mut m.OptionList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollUpdateVotesContent>(
            "PollUpdateVotesContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollUpdateVotesContent {
    const NAME: &'static str = "PollUpdateVotesContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.OptionList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.OptionList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.OptionList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollUpdateVotesContent {
        PollUpdateVotesContent::new()
    }

    fn clear(&mut self) {
        self.OptionList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollUpdateVotesContent {
        static instance: PollUpdateVotesContent = PollUpdateVotesContent {
            OptionList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollUpdateVotesContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollUpdateVotesContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollUpdateVotesContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollUpdateVotesContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.UserFanTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserFanTicket {
    // message fields
    // @@protoc_insertion_point(field:TikTok.UserFanTicket.UserId)
    pub UserId: i64,
    // @@protoc_insertion_point(field:TikTok.UserFanTicket.FanTicket)
    pub FanTicket: i64,
    // @@protoc_insertion_point(field:TikTok.UserFanTicket.MatchTotalScore)
    pub MatchTotalScore: i64,
    // @@protoc_insertion_point(field:TikTok.UserFanTicket.MatchRank)
    pub MatchRank: i32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.UserFanTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserFanTicket {
    fn default() -> &'a UserFanTicket {
        <UserFanTicket as ::protobuf::Message>::default_instance()
    }
}

impl UserFanTicket {
    pub fn new() -> UserFanTicket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UserId",
            |m: &UserFanTicket| { &m.UserId },
            |m: &mut UserFanTicket| { &mut m.UserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FanTicket",
            |m: &UserFanTicket| { &m.FanTicket },
            |m: &mut UserFanTicket| { &mut m.FanTicket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MatchTotalScore",
            |m: &UserFanTicket| { &m.MatchTotalScore },
            |m: &mut UserFanTicket| { &mut m.MatchTotalScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MatchRank",
            |m: &UserFanTicket| { &m.MatchRank },
            |m: &mut UserFanTicket| { &mut m.MatchRank },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserFanTicket>(
            "UserFanTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserFanTicket {
    const NAME: &'static str = "UserFanTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.UserId = is.read_int64()?;
                },
                16 => {
                    self.FanTicket = is.read_int64()?;
                },
                24 => {
                    self.MatchTotalScore = is.read_int64()?;
                },
                32 => {
                    self.MatchRank = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.UserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.UserId);
        }
        if self.FanTicket != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.FanTicket);
        }
        if self.MatchTotalScore != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.MatchTotalScore);
        }
        if self.MatchRank != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.MatchRank);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.UserId != 0 {
            os.write_int64(1, self.UserId)?;
        }
        if self.FanTicket != 0 {
            os.write_int64(2, self.FanTicket)?;
        }
        if self.MatchTotalScore != 0 {
            os.write_int64(3, self.MatchTotalScore)?;
        }
        if self.MatchRank != 0 {
            os.write_int32(4, self.MatchRank)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserFanTicket {
        UserFanTicket::new()
    }

    fn clear(&mut self) {
        self.UserId = 0;
        self.FanTicket = 0;
        self.MatchTotalScore = 0;
        self.MatchRank = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserFanTicket {
        static instance: UserFanTicket = UserFanTicket {
            UserId: 0,
            FanTicket: 0,
            MatchTotalScore: 0,
            MatchRank: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserFanTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserFanTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserFanTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserFanTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.FanTicketRoomNoticeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FanTicketRoomNoticeContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.FanTicketRoomNoticeContent.UserFanTicketList)
    pub UserFanTicketList: ::std::vec::Vec<UserFanTicket>,
    // @@protoc_insertion_point(field:TikTok.FanTicketRoomNoticeContent.TotalLinkMicFanTicket)
    pub TotalLinkMicFanTicket: i64,
    // @@protoc_insertion_point(field:TikTok.FanTicketRoomNoticeContent.MatchId)
    pub MatchId: i64,
    // @@protoc_insertion_point(field:TikTok.FanTicketRoomNoticeContent.EventTime)
    pub EventTime: i64,
    // @@protoc_insertion_point(field:TikTok.FanTicketRoomNoticeContent.FanTicketIconUrl)
    pub FanTicketIconUrl: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.FanTicketRoomNoticeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FanTicketRoomNoticeContent {
    fn default() -> &'a FanTicketRoomNoticeContent {
        <FanTicketRoomNoticeContent as ::protobuf::Message>::default_instance()
    }
}

impl FanTicketRoomNoticeContent {
    pub fn new() -> FanTicketRoomNoticeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "UserFanTicketList",
            |m: &FanTicketRoomNoticeContent| { &m.UserFanTicketList },
            |m: &mut FanTicketRoomNoticeContent| { &mut m.UserFanTicketList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TotalLinkMicFanTicket",
            |m: &FanTicketRoomNoticeContent| { &m.TotalLinkMicFanTicket },
            |m: &mut FanTicketRoomNoticeContent| { &mut m.TotalLinkMicFanTicket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MatchId",
            |m: &FanTicketRoomNoticeContent| { &m.MatchId },
            |m: &mut FanTicketRoomNoticeContent| { &mut m.MatchId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "EventTime",
            |m: &FanTicketRoomNoticeContent| { &m.EventTime },
            |m: &mut FanTicketRoomNoticeContent| { &mut m.EventTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FanTicketIconUrl",
            |m: &FanTicketRoomNoticeContent| { &m.FanTicketIconUrl },
            |m: &mut FanTicketRoomNoticeContent| { &mut m.FanTicketIconUrl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FanTicketRoomNoticeContent>(
            "FanTicketRoomNoticeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FanTicketRoomNoticeContent {
    const NAME: &'static str = "FanTicketRoomNoticeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.UserFanTicketList.push(is.read_message()?);
                },
                16 => {
                    self.TotalLinkMicFanTicket = is.read_int64()?;
                },
                24 => {
                    self.MatchId = is.read_int64()?;
                },
                32 => {
                    self.EventTime = is.read_int64()?;
                },
                42 => {
                    self.FanTicketIconUrl = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.UserFanTicketList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.TotalLinkMicFanTicket != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.TotalLinkMicFanTicket);
        }
        if self.MatchId != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.MatchId);
        }
        if self.EventTime != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.EventTime);
        }
        if !self.FanTicketIconUrl.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.FanTicketIconUrl);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.UserFanTicketList {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.TotalLinkMicFanTicket != 0 {
            os.write_int64(2, self.TotalLinkMicFanTicket)?;
        }
        if self.MatchId != 0 {
            os.write_int64(3, self.MatchId)?;
        }
        if self.EventTime != 0 {
            os.write_int64(4, self.EventTime)?;
        }
        if !self.FanTicketIconUrl.is_empty() {
            os.write_string(5, &self.FanTicketIconUrl)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FanTicketRoomNoticeContent {
        FanTicketRoomNoticeContent::new()
    }

    fn clear(&mut self) {
        self.UserFanTicketList.clear();
        self.TotalLinkMicFanTicket = 0;
        self.MatchId = 0;
        self.EventTime = 0;
        self.FanTicketIconUrl.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FanTicketRoomNoticeContent {
        static instance: FanTicketRoomNoticeContent = FanTicketRoomNoticeContent {
            UserFanTicketList: ::std::vec::Vec::new(),
            TotalLinkMicFanTicket: 0,
            MatchId: 0,
            EventTime: 0,
            FanTicketIconUrl: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FanTicketRoomNoticeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FanTicketRoomNoticeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FanTicketRoomNoticeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanTicketRoomNoticeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerAcceptNoticeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerAcceptNoticeContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerAcceptNoticeContent.fromUserId)
    pub fromUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerAcceptNoticeContent.fromRoomId)
    pub fromRoomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerAcceptNoticeContent.toUserId)
    pub toUserId: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerAcceptNoticeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerAcceptNoticeContent {
    fn default() -> &'a LinkerAcceptNoticeContent {
        <LinkerAcceptNoticeContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerAcceptNoticeContent {
    pub fn new() -> LinkerAcceptNoticeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromUserId",
            |m: &LinkerAcceptNoticeContent| { &m.fromUserId },
            |m: &mut LinkerAcceptNoticeContent| { &mut m.fromUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromRoomId",
            |m: &LinkerAcceptNoticeContent| { &m.fromRoomId },
            |m: &mut LinkerAcceptNoticeContent| { &mut m.fromRoomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toUserId",
            |m: &LinkerAcceptNoticeContent| { &m.toUserId },
            |m: &mut LinkerAcceptNoticeContent| { &mut m.toUserId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerAcceptNoticeContent>(
            "LinkerAcceptNoticeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerAcceptNoticeContent {
    const NAME: &'static str = "LinkerAcceptNoticeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fromUserId = is.read_int64()?;
                },
                16 => {
                    self.fromRoomId = is.read_int64()?;
                },
                24 => {
                    self.toUserId = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fromUserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.fromUserId);
        }
        if self.fromRoomId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.fromRoomId);
        }
        if self.toUserId != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.toUserId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fromUserId != 0 {
            os.write_int64(1, self.fromUserId)?;
        }
        if self.fromRoomId != 0 {
            os.write_int64(2, self.fromRoomId)?;
        }
        if self.toUserId != 0 {
            os.write_int64(3, self.toUserId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerAcceptNoticeContent {
        LinkerAcceptNoticeContent::new()
    }

    fn clear(&mut self) {
        self.fromUserId = 0;
        self.fromRoomId = 0;
        self.toUserId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerAcceptNoticeContent {
        static instance: LinkerAcceptNoticeContent = LinkerAcceptNoticeContent {
            fromUserId: 0,
            fromRoomId: 0,
            toUserId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerAcceptNoticeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerAcceptNoticeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerAcceptNoticeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerAcceptNoticeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerCancelContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerCancelContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerCancelContent.fromUserId)
    pub fromUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerCancelContent.toUserId)
    pub toUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerCancelContent.cancelType)
    pub cancelType: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerCancelContent.actionId)
    pub actionId: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerCancelContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerCancelContent {
    fn default() -> &'a LinkerCancelContent {
        <LinkerCancelContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerCancelContent {
    pub fn new() -> LinkerCancelContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromUserId",
            |m: &LinkerCancelContent| { &m.fromUserId },
            |m: &mut LinkerCancelContent| { &mut m.fromUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toUserId",
            |m: &LinkerCancelContent| { &m.toUserId },
            |m: &mut LinkerCancelContent| { &mut m.toUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cancelType",
            |m: &LinkerCancelContent| { &m.cancelType },
            |m: &mut LinkerCancelContent| { &mut m.cancelType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actionId",
            |m: &LinkerCancelContent| { &m.actionId },
            |m: &mut LinkerCancelContent| { &mut m.actionId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerCancelContent>(
            "LinkerCancelContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerCancelContent {
    const NAME: &'static str = "LinkerCancelContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fromUserId = is.read_int64()?;
                },
                16 => {
                    self.toUserId = is.read_int64()?;
                },
                24 => {
                    self.cancelType = is.read_int64()?;
                },
                32 => {
                    self.actionId = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fromUserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.fromUserId);
        }
        if self.toUserId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.toUserId);
        }
        if self.cancelType != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.cancelType);
        }
        if self.actionId != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.actionId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fromUserId != 0 {
            os.write_int64(1, self.fromUserId)?;
        }
        if self.toUserId != 0 {
            os.write_int64(2, self.toUserId)?;
        }
        if self.cancelType != 0 {
            os.write_int64(3, self.cancelType)?;
        }
        if self.actionId != 0 {
            os.write_int64(4, self.actionId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerCancelContent {
        LinkerCancelContent::new()
    }

    fn clear(&mut self) {
        self.fromUserId = 0;
        self.toUserId = 0;
        self.cancelType = 0;
        self.actionId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerCancelContent {
        static instance: LinkerCancelContent = LinkerCancelContent {
            fromUserId: 0,
            toUserId: 0,
            cancelType: 0,
            actionId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerCancelContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerCancelContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerCancelContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerCancelContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.ListUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListUser {
    // message fields
    // @@protoc_insertion_point(field:TikTok.ListUser.user)
    pub user: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.ListUser.linkmicId)
    pub linkmicId: i64,
    // @@protoc_insertion_point(field:TikTok.ListUser.linkmicIdStr)
    pub linkmicIdStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.ListUser.linkStatus)
    pub linkStatus: i64,
    // @@protoc_insertion_point(field:TikTok.ListUser.linkType)
    pub linkType: ::protobuf::EnumOrUnknown<list_user::LinkType>,
    // @@protoc_insertion_point(field:TikTok.ListUser.userPosition)
    pub userPosition: i32,
    // @@protoc_insertion_point(field:TikTok.ListUser.silenceStatus)
    pub silenceStatus: i32,
    // @@protoc_insertion_point(field:TikTok.ListUser.modifyTime)
    pub modifyTime: i64,
    // @@protoc_insertion_point(field:TikTok.ListUser.linkerId)
    pub linkerId: i64,
    // @@protoc_insertion_point(field:TikTok.ListUser.roleType)
    pub roleType: i32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.ListUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListUser {
    fn default() -> &'a ListUser {
        <ListUser as ::protobuf::Message>::default_instance()
    }
}

impl ListUser {
    pub fn new() -> ListUser {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "user",
            |m: &ListUser| { &m.user },
            |m: &mut ListUser| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkmicId",
            |m: &ListUser| { &m.linkmicId },
            |m: &mut ListUser| { &mut m.linkmicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkmicIdStr",
            |m: &ListUser| { &m.linkmicIdStr },
            |m: &mut ListUser| { &mut m.linkmicIdStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkStatus",
            |m: &ListUser| { &m.linkStatus },
            |m: &mut ListUser| { &mut m.linkStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkType",
            |m: &ListUser| { &m.linkType },
            |m: &mut ListUser| { &mut m.linkType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userPosition",
            |m: &ListUser| { &m.userPosition },
            |m: &mut ListUser| { &mut m.userPosition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "silenceStatus",
            |m: &ListUser| { &m.silenceStatus },
            |m: &mut ListUser| { &mut m.silenceStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modifyTime",
            |m: &ListUser| { &m.modifyTime },
            |m: &mut ListUser| { &mut m.modifyTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkerId",
            |m: &ListUser| { &m.linkerId },
            |m: &mut ListUser| { &mut m.linkerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roleType",
            |m: &ListUser| { &m.roleType },
            |m: &mut ListUser| { &mut m.roleType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListUser>(
            "ListUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListUser {
    const NAME: &'static str = "ListUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                16 => {
                    self.linkmicId = is.read_int64()?;
                },
                26 => {
                    self.linkmicIdStr = is.read_string()?;
                },
                32 => {
                    self.linkStatus = is.read_int64()?;
                },
                40 => {
                    self.linkType = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.userPosition = is.read_int32()?;
                },
                56 => {
                    self.silenceStatus = is.read_int32()?;
                },
                64 => {
                    self.modifyTime = is.read_int64()?;
                },
                72 => {
                    self.linkerId = is.read_int64()?;
                },
                80 => {
                    self.roleType = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.linkmicId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.linkmicId);
        }
        if !self.linkmicIdStr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.linkmicIdStr);
        }
        if self.linkStatus != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.linkStatus);
        }
        if self.linkType != ::protobuf::EnumOrUnknown::new(list_user::LinkType::LINK_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(5, self.linkType.value());
        }
        if self.userPosition != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.userPosition);
        }
        if self.silenceStatus != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.silenceStatus);
        }
        if self.modifyTime != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.modifyTime);
        }
        if self.linkerId != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.linkerId);
        }
        if self.roleType != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.roleType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.linkmicId != 0 {
            os.write_int64(2, self.linkmicId)?;
        }
        if !self.linkmicIdStr.is_empty() {
            os.write_string(3, &self.linkmicIdStr)?;
        }
        if self.linkStatus != 0 {
            os.write_int64(4, self.linkStatus)?;
        }
        if self.linkType != ::protobuf::EnumOrUnknown::new(list_user::LinkType::LINK_UNKNOWN) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.linkType))?;
        }
        if self.userPosition != 0 {
            os.write_int32(6, self.userPosition)?;
        }
        if self.silenceStatus != 0 {
            os.write_int32(7, self.silenceStatus)?;
        }
        if self.modifyTime != 0 {
            os.write_int64(8, self.modifyTime)?;
        }
        if self.linkerId != 0 {
            os.write_int64(9, self.linkerId)?;
        }
        if self.roleType != 0 {
            os.write_int32(10, self.roleType)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListUser {
        ListUser::new()
    }

    fn clear(&mut self) {
        self.user.clear();
        self.linkmicId = 0;
        self.linkmicIdStr.clear();
        self.linkStatus = 0;
        self.linkType = ::protobuf::EnumOrUnknown::new(list_user::LinkType::LINK_UNKNOWN);
        self.userPosition = 0;
        self.silenceStatus = 0;
        self.modifyTime = 0;
        self.linkerId = 0;
        self.roleType = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListUser {
        static instance: ListUser = ListUser {
            user: ::protobuf::MessageField::none(),
            linkmicId: 0,
            linkmicIdStr: ::std::string::String::new(),
            linkStatus: 0,
            linkType: ::protobuf::EnumOrUnknown::from_i32(0),
            userPosition: 0,
            silenceStatus: 0,
            modifyTime: 0,
            linkerId: 0,
            roleType: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListUser`
pub mod list_user {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TikTok.ListUser.LinkType)
    pub enum LinkType {
        // @@protoc_insertion_point(enum_value:TikTok.ListUser.LinkType.LINK_UNKNOWN)
        LINK_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:TikTok.ListUser.LinkType.AUDIO)
        AUDIO = 1,
        // @@protoc_insertion_point(enum_value:TikTok.ListUser.LinkType.VIDEO)
        VIDEO = 2,
    }

    impl ::protobuf::Enum for LinkType {
        const NAME: &'static str = "LinkType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LinkType> {
            match value {
                0 => ::std::option::Option::Some(LinkType::LINK_UNKNOWN),
                1 => ::std::option::Option::Some(LinkType::AUDIO),
                2 => ::std::option::Option::Some(LinkType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<LinkType> {
            match str {
                "LINK_UNKNOWN" => ::std::option::Option::Some(LinkType::LINK_UNKNOWN),
                "AUDIO" => ::std::option::Option::Some(LinkType::AUDIO),
                "VIDEO" => ::std::option::Option::Some(LinkType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [LinkType] = &[
            LinkType::LINK_UNKNOWN,
            LinkType::AUDIO,
            LinkType::VIDEO,
        ];
    }

    impl ::protobuf::EnumFull for LinkType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ListUser.LinkType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for LinkType {
        fn default() -> Self {
            LinkType::LINK_UNKNOWN
        }
    }

    impl LinkType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LinkType>("ListUser.LinkType")
        }
    }
}

// @@protoc_insertion_point(message:TikTok.LinkerCloseContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerCloseContent {
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerCloseContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerCloseContent {
    fn default() -> &'a LinkerCloseContent {
        <LinkerCloseContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerCloseContent {
    pub fn new() -> LinkerCloseContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerCloseContent>(
            "LinkerCloseContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerCloseContent {
    const NAME: &'static str = "LinkerCloseContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerCloseContent {
        LinkerCloseContent::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerCloseContent {
        static instance: LinkerCloseContent = LinkerCloseContent {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerCloseContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerCloseContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerCloseContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerCloseContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerCreateContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerCreateContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerCreateContent.ownerId)
    pub ownerId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerCreateContent.ownerRoomId)
    pub ownerRoomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerCreateContent.linkType)
    pub linkType: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerCreateContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerCreateContent {
    fn default() -> &'a LinkerCreateContent {
        <LinkerCreateContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerCreateContent {
    pub fn new() -> LinkerCreateContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ownerId",
            |m: &LinkerCreateContent| { &m.ownerId },
            |m: &mut LinkerCreateContent| { &mut m.ownerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ownerRoomId",
            |m: &LinkerCreateContent| { &m.ownerRoomId },
            |m: &mut LinkerCreateContent| { &mut m.ownerRoomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkType",
            |m: &LinkerCreateContent| { &m.linkType },
            |m: &mut LinkerCreateContent| { &mut m.linkType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerCreateContent>(
            "LinkerCreateContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerCreateContent {
    const NAME: &'static str = "LinkerCreateContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ownerId = is.read_int64()?;
                },
                16 => {
                    self.ownerRoomId = is.read_int64()?;
                },
                24 => {
                    self.linkType = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ownerId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.ownerId);
        }
        if self.ownerRoomId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.ownerRoomId);
        }
        if self.linkType != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.linkType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ownerId != 0 {
            os.write_int64(1, self.ownerId)?;
        }
        if self.ownerRoomId != 0 {
            os.write_int64(2, self.ownerRoomId)?;
        }
        if self.linkType != 0 {
            os.write_int64(3, self.linkType)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerCreateContent {
        LinkerCreateContent::new()
    }

    fn clear(&mut self) {
        self.ownerId = 0;
        self.ownerRoomId = 0;
        self.linkType = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerCreateContent {
        static instance: LinkerCreateContent = LinkerCreateContent {
            ownerId: 0,
            ownerRoomId: 0,
            linkType: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerCreateContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerCreateContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerCreateContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerCreateContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerEnterContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerEnterContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerEnterContent.linkedUsersList)
    pub linkedUsersList: ::std::vec::Vec<ListUser>,
    // @@protoc_insertion_point(field:TikTok.LinkerEnterContent.anchorMultiLiveEnum)
    pub anchorMultiLiveEnum: i32,
    // @@protoc_insertion_point(field:TikTok.LinkerEnterContent.anchorSettingInfo)
    pub anchorSettingInfo: ::protobuf::MessageField<LinkmicUserSettingInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerEnterContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerEnterContent {
    fn default() -> &'a LinkerEnterContent {
        <LinkerEnterContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerEnterContent {
    pub fn new() -> LinkerEnterContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "linkedUsersList",
            |m: &LinkerEnterContent| { &m.linkedUsersList },
            |m: &mut LinkerEnterContent| { &mut m.linkedUsersList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "anchorMultiLiveEnum",
            |m: &LinkerEnterContent| { &m.anchorMultiLiveEnum },
            |m: &mut LinkerEnterContent| { &mut m.anchorMultiLiveEnum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkmicUserSettingInfo>(
            "anchorSettingInfo",
            |m: &LinkerEnterContent| { &m.anchorSettingInfo },
            |m: &mut LinkerEnterContent| { &mut m.anchorSettingInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerEnterContent>(
            "LinkerEnterContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerEnterContent {
    const NAME: &'static str = "LinkerEnterContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.linkedUsersList.push(is.read_message()?);
                },
                16 => {
                    self.anchorMultiLiveEnum = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.anchorSettingInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.linkedUsersList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.anchorMultiLiveEnum != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.anchorMultiLiveEnum);
        }
        if let Some(v) = self.anchorSettingInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.linkedUsersList {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.anchorMultiLiveEnum != 0 {
            os.write_int32(2, self.anchorMultiLiveEnum)?;
        }
        if let Some(v) = self.anchorSettingInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerEnterContent {
        LinkerEnterContent::new()
    }

    fn clear(&mut self) {
        self.linkedUsersList.clear();
        self.anchorMultiLiveEnum = 0;
        self.anchorSettingInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerEnterContent {
        static instance: LinkerEnterContent = LinkerEnterContent {
            linkedUsersList: ::std::vec::Vec::new(),
            anchorMultiLiveEnum: 0,
            anchorSettingInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerEnterContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerEnterContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerEnterContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerEnterContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerInviteContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerInviteContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.fromUserId)
    pub fromUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.fromRoomId)
    pub fromRoomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.toRtcExtInfo)
    pub toRtcExtInfo: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.rtcJoinChannel)
    pub rtcJoinChannel: bool,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.vendor)
    pub vendor: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.secFromUserId)
    pub secFromUserId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.toLinkmicIdStr)
    pub toLinkmicIdStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.fromUser)
    pub fromUser: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.LinkerInviteContent.requiredMicIdx)
    pub requiredMicIdx: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerInviteContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerInviteContent {
    fn default() -> &'a LinkerInviteContent {
        <LinkerInviteContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerInviteContent {
    pub fn new() -> LinkerInviteContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromUserId",
            |m: &LinkerInviteContent| { &m.fromUserId },
            |m: &mut LinkerInviteContent| { &mut m.fromUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromRoomId",
            |m: &LinkerInviteContent| { &m.fromRoomId },
            |m: &mut LinkerInviteContent| { &mut m.fromRoomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toRtcExtInfo",
            |m: &LinkerInviteContent| { &m.toRtcExtInfo },
            |m: &mut LinkerInviteContent| { &mut m.toRtcExtInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rtcJoinChannel",
            |m: &LinkerInviteContent| { &m.rtcJoinChannel },
            |m: &mut LinkerInviteContent| { &mut m.rtcJoinChannel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vendor",
            |m: &LinkerInviteContent| { &m.vendor },
            |m: &mut LinkerInviteContent| { &mut m.vendor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "secFromUserId",
            |m: &LinkerInviteContent| { &m.secFromUserId },
            |m: &mut LinkerInviteContent| { &mut m.secFromUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toLinkmicIdStr",
            |m: &LinkerInviteContent| { &m.toLinkmicIdStr },
            |m: &mut LinkerInviteContent| { &mut m.toLinkmicIdStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "fromUser",
            |m: &LinkerInviteContent| { &m.fromUser },
            |m: &mut LinkerInviteContent| { &mut m.fromUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requiredMicIdx",
            |m: &LinkerInviteContent| { &m.requiredMicIdx },
            |m: &mut LinkerInviteContent| { &mut m.requiredMicIdx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerInviteContent>(
            "LinkerInviteContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerInviteContent {
    const NAME: &'static str = "LinkerInviteContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fromUserId = is.read_int64()?;
                },
                16 => {
                    self.fromRoomId = is.read_int64()?;
                },
                26 => {
                    self.toRtcExtInfo = is.read_string()?;
                },
                32 => {
                    self.rtcJoinChannel = is.read_bool()?;
                },
                40 => {
                    self.vendor = is.read_int64()?;
                },
                50 => {
                    self.secFromUserId = is.read_string()?;
                },
                58 => {
                    self.toLinkmicIdStr = is.read_string()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fromUser)?;
                },
                72 => {
                    self.requiredMicIdx = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fromUserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.fromUserId);
        }
        if self.fromRoomId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.fromRoomId);
        }
        if !self.toRtcExtInfo.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.toRtcExtInfo);
        }
        if self.rtcJoinChannel != false {
            my_size += 1 + 1;
        }
        if self.vendor != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.vendor);
        }
        if !self.secFromUserId.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.secFromUserId);
        }
        if !self.toLinkmicIdStr.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.toLinkmicIdStr);
        }
        if let Some(v) = self.fromUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.requiredMicIdx != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.requiredMicIdx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fromUserId != 0 {
            os.write_int64(1, self.fromUserId)?;
        }
        if self.fromRoomId != 0 {
            os.write_int64(2, self.fromRoomId)?;
        }
        if !self.toRtcExtInfo.is_empty() {
            os.write_string(3, &self.toRtcExtInfo)?;
        }
        if self.rtcJoinChannel != false {
            os.write_bool(4, self.rtcJoinChannel)?;
        }
        if self.vendor != 0 {
            os.write_int64(5, self.vendor)?;
        }
        if !self.secFromUserId.is_empty() {
            os.write_string(6, &self.secFromUserId)?;
        }
        if !self.toLinkmicIdStr.is_empty() {
            os.write_string(7, &self.toLinkmicIdStr)?;
        }
        if let Some(v) = self.fromUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.requiredMicIdx != 0 {
            os.write_int64(9, self.requiredMicIdx)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerInviteContent {
        LinkerInviteContent::new()
    }

    fn clear(&mut self) {
        self.fromUserId = 0;
        self.fromRoomId = 0;
        self.toRtcExtInfo.clear();
        self.rtcJoinChannel = false;
        self.vendor = 0;
        self.secFromUserId.clear();
        self.toLinkmicIdStr.clear();
        self.fromUser.clear();
        self.requiredMicIdx = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerInviteContent {
        static instance: LinkerInviteContent = LinkerInviteContent {
            fromUserId: 0,
            fromRoomId: 0,
            toRtcExtInfo: ::std::string::String::new(),
            rtcJoinChannel: false,
            vendor: 0,
            secFromUserId: ::std::string::String::new(),
            toLinkmicIdStr: ::std::string::String::new(),
            fromUser: ::protobuf::MessageField::none(),
            requiredMicIdx: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerInviteContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerInviteContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerInviteContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerInviteContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerKickOutContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerKickOutContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerKickOutContent.fromUserId)
    pub fromUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerKickOutContent.kickoutReason)
    pub kickoutReason: ::protobuf::EnumOrUnknown<super::enums::KickoutReason>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerKickOutContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerKickOutContent {
    fn default() -> &'a LinkerKickOutContent {
        <LinkerKickOutContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerKickOutContent {
    pub fn new() -> LinkerKickOutContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromUserId",
            |m: &LinkerKickOutContent| { &m.fromUserId },
            |m: &mut LinkerKickOutContent| { &mut m.fromUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kickoutReason",
            |m: &LinkerKickOutContent| { &m.kickoutReason },
            |m: &mut LinkerKickOutContent| { &mut m.kickoutReason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerKickOutContent>(
            "LinkerKickOutContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerKickOutContent {
    const NAME: &'static str = "LinkerKickOutContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fromUserId = is.read_int64()?;
                },
                16 => {
                    self.kickoutReason = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fromUserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.fromUserId);
        }
        if self.kickoutReason != ::protobuf::EnumOrUnknown::new(super::enums::KickoutReason::KICKOUT_REASON_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.kickoutReason.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fromUserId != 0 {
            os.write_int64(1, self.fromUserId)?;
        }
        if self.kickoutReason != ::protobuf::EnumOrUnknown::new(super::enums::KickoutReason::KICKOUT_REASON_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.kickoutReason))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerKickOutContent {
        LinkerKickOutContent::new()
    }

    fn clear(&mut self) {
        self.fromUserId = 0;
        self.kickoutReason = ::protobuf::EnumOrUnknown::new(super::enums::KickoutReason::KICKOUT_REASON_UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerKickOutContent {
        static instance: LinkerKickOutContent = LinkerKickOutContent {
            fromUserId: 0,
            kickoutReason: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerKickOutContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerKickOutContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerKickOutContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerKickOutContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerLeaveContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerLeaveContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerLeaveContent.userId)
    pub userId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerLeaveContent.linkmicIdStr)
    pub linkmicIdStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.LinkerLeaveContent.sendLeaveUid)
    pub sendLeaveUid: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerLeaveContent.leaveReason)
    pub leaveReason: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerLeaveContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerLeaveContent {
    fn default() -> &'a LinkerLeaveContent {
        <LinkerLeaveContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerLeaveContent {
    pub fn new() -> LinkerLeaveContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &LinkerLeaveContent| { &m.userId },
            |m: &mut LinkerLeaveContent| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkmicIdStr",
            |m: &LinkerLeaveContent| { &m.linkmicIdStr },
            |m: &mut LinkerLeaveContent| { &mut m.linkmicIdStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sendLeaveUid",
            |m: &LinkerLeaveContent| { &m.sendLeaveUid },
            |m: &mut LinkerLeaveContent| { &mut m.sendLeaveUid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "leaveReason",
            |m: &LinkerLeaveContent| { &m.leaveReason },
            |m: &mut LinkerLeaveContent| { &mut m.leaveReason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerLeaveContent>(
            "LinkerLeaveContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerLeaveContent {
    const NAME: &'static str = "LinkerLeaveContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.userId = is.read_int64()?;
                },
                18 => {
                    self.linkmicIdStr = is.read_string()?;
                },
                24 => {
                    self.sendLeaveUid = is.read_int64()?;
                },
                32 => {
                    self.leaveReason = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.userId);
        }
        if !self.linkmicIdStr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.linkmicIdStr);
        }
        if self.sendLeaveUid != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.sendLeaveUid);
        }
        if self.leaveReason != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.leaveReason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.userId != 0 {
            os.write_int64(1, self.userId)?;
        }
        if !self.linkmicIdStr.is_empty() {
            os.write_string(2, &self.linkmicIdStr)?;
        }
        if self.sendLeaveUid != 0 {
            os.write_int64(3, self.sendLeaveUid)?;
        }
        if self.leaveReason != 0 {
            os.write_int64(4, self.leaveReason)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerLeaveContent {
        LinkerLeaveContent::new()
    }

    fn clear(&mut self) {
        self.userId = 0;
        self.linkmicIdStr.clear();
        self.sendLeaveUid = 0;
        self.leaveReason = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerLeaveContent {
        static instance: LinkerLeaveContent = LinkerLeaveContent {
            userId: 0,
            linkmicIdStr: ::std::string::String::new(),
            sendLeaveUid: 0,
            leaveReason: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerLeaveContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerLeaveContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerLeaveContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerLeaveContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerLinkedListChangeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerLinkedListChangeContent {
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerLinkedListChangeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerLinkedListChangeContent {
    fn default() -> &'a LinkerLinkedListChangeContent {
        <LinkerLinkedListChangeContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerLinkedListChangeContent {
    pub fn new() -> LinkerLinkedListChangeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerLinkedListChangeContent>(
            "LinkerLinkedListChangeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerLinkedListChangeContent {
    const NAME: &'static str = "LinkerLinkedListChangeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerLinkedListChangeContent {
        LinkerLinkedListChangeContent::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerLinkedListChangeContent {
        static instance: LinkerLinkedListChangeContent = LinkerLinkedListChangeContent {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerLinkedListChangeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerLinkedListChangeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerLinkedListChangeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerLinkedListChangeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.CohostListChangeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CohostListChangeContent {
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.CohostListChangeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CohostListChangeContent {
    fn default() -> &'a CohostListChangeContent {
        <CohostListChangeContent as ::protobuf::Message>::default_instance()
    }
}

impl CohostListChangeContent {
    pub fn new() -> CohostListChangeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CohostListChangeContent>(
            "CohostListChangeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CohostListChangeContent {
    const NAME: &'static str = "CohostListChangeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CohostListChangeContent {
        CohostListChangeContent::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CohostListChangeContent {
        static instance: CohostListChangeContent = CohostListChangeContent {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CohostListChangeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CohostListChangeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CohostListChangeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CohostListChangeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerListChangeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerListChangeContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerListChangeContent.linkedUsersList)
    pub linkedUsersList: ::std::vec::Vec<ListUser>,
    // @@protoc_insertion_point(field:TikTok.LinkerListChangeContent.appliedUsersList)
    pub appliedUsersList: ::std::vec::Vec<ListUser>,
    // @@protoc_insertion_point(field:TikTok.LinkerListChangeContent.connectingUsersList)
    pub connectingUsersList: ::std::vec::Vec<ListUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerListChangeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerListChangeContent {
    fn default() -> &'a LinkerListChangeContent {
        <LinkerListChangeContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerListChangeContent {
    pub fn new() -> LinkerListChangeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "linkedUsersList",
            |m: &LinkerListChangeContent| { &m.linkedUsersList },
            |m: &mut LinkerListChangeContent| { &mut m.linkedUsersList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appliedUsersList",
            |m: &LinkerListChangeContent| { &m.appliedUsersList },
            |m: &mut LinkerListChangeContent| { &mut m.appliedUsersList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connectingUsersList",
            |m: &LinkerListChangeContent| { &m.connectingUsersList },
            |m: &mut LinkerListChangeContent| { &mut m.connectingUsersList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerListChangeContent>(
            "LinkerListChangeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerListChangeContent {
    const NAME: &'static str = "LinkerListChangeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.linkedUsersList.push(is.read_message()?);
                },
                18 => {
                    self.appliedUsersList.push(is.read_message()?);
                },
                26 => {
                    self.connectingUsersList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.linkedUsersList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.appliedUsersList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.connectingUsersList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.linkedUsersList {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.appliedUsersList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.connectingUsersList {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerListChangeContent {
        LinkerListChangeContent::new()
    }

    fn clear(&mut self) {
        self.linkedUsersList.clear();
        self.appliedUsersList.clear();
        self.connectingUsersList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerListChangeContent {
        static instance: LinkerListChangeContent = LinkerListChangeContent {
            linkedUsersList: ::std::vec::Vec::new(),
            appliedUsersList: ::std::vec::Vec::new(),
            connectingUsersList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerListChangeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerListChangeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerListChangeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerListChangeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerMediaChangeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerMediaChangeContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerMediaChangeContent.op)
    pub op: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerMediaChangeContent.toUserId)
    pub toUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerMediaChangeContent.anchorId)
    pub anchorId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerMediaChangeContent.roomId)
    pub roomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerMediaChangeContent.changeScene)
    pub changeScene: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerMediaChangeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerMediaChangeContent {
    fn default() -> &'a LinkerMediaChangeContent {
        <LinkerMediaChangeContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerMediaChangeContent {
    pub fn new() -> LinkerMediaChangeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "op",
            |m: &LinkerMediaChangeContent| { &m.op },
            |m: &mut LinkerMediaChangeContent| { &mut m.op },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toUserId",
            |m: &LinkerMediaChangeContent| { &m.toUserId },
            |m: &mut LinkerMediaChangeContent| { &mut m.toUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "anchorId",
            |m: &LinkerMediaChangeContent| { &m.anchorId },
            |m: &mut LinkerMediaChangeContent| { &mut m.anchorId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomId",
            |m: &LinkerMediaChangeContent| { &m.roomId },
            |m: &mut LinkerMediaChangeContent| { &mut m.roomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "changeScene",
            |m: &LinkerMediaChangeContent| { &m.changeScene },
            |m: &mut LinkerMediaChangeContent| { &mut m.changeScene },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerMediaChangeContent>(
            "LinkerMediaChangeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerMediaChangeContent {
    const NAME: &'static str = "LinkerMediaChangeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.op = is.read_int64()?;
                },
                16 => {
                    self.toUserId = is.read_int64()?;
                },
                24 => {
                    self.anchorId = is.read_int64()?;
                },
                32 => {
                    self.roomId = is.read_int64()?;
                },
                40 => {
                    self.changeScene = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.op != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.op);
        }
        if self.toUserId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.toUserId);
        }
        if self.anchorId != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.anchorId);
        }
        if self.roomId != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.roomId);
        }
        if self.changeScene != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.changeScene);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.op != 0 {
            os.write_int64(1, self.op)?;
        }
        if self.toUserId != 0 {
            os.write_int64(2, self.toUserId)?;
        }
        if self.anchorId != 0 {
            os.write_int64(3, self.anchorId)?;
        }
        if self.roomId != 0 {
            os.write_int64(4, self.roomId)?;
        }
        if self.changeScene != 0 {
            os.write_int64(5, self.changeScene)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerMediaChangeContent {
        LinkerMediaChangeContent::new()
    }

    fn clear(&mut self) {
        self.op = 0;
        self.toUserId = 0;
        self.anchorId = 0;
        self.roomId = 0;
        self.changeScene = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerMediaChangeContent {
        static instance: LinkerMediaChangeContent = LinkerMediaChangeContent {
            op: 0,
            toUserId: 0,
            anchorId: 0,
            roomId: 0,
            changeScene: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerMediaChangeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerMediaChangeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerMediaChangeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerMediaChangeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerMicIdxUpdateContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerMicIdxUpdateContent {
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerMicIdxUpdateContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerMicIdxUpdateContent {
    fn default() -> &'a LinkerMicIdxUpdateContent {
        <LinkerMicIdxUpdateContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerMicIdxUpdateContent {
    pub fn new() -> LinkerMicIdxUpdateContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerMicIdxUpdateContent>(
            "LinkerMicIdxUpdateContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerMicIdxUpdateContent {
    const NAME: &'static str = "LinkerMicIdxUpdateContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerMicIdxUpdateContent {
        LinkerMicIdxUpdateContent::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerMicIdxUpdateContent {
        static instance: LinkerMicIdxUpdateContent = LinkerMicIdxUpdateContent {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerMicIdxUpdateContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerMicIdxUpdateContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerMicIdxUpdateContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerMicIdxUpdateContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerMuteContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerMuteContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerMuteContent.userId)
    pub userId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerMuteContent.status)
    pub status: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerMuteContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerMuteContent {
    fn default() -> &'a LinkerMuteContent {
        <LinkerMuteContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerMuteContent {
    pub fn new() -> LinkerMuteContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &LinkerMuteContent| { &m.userId },
            |m: &mut LinkerMuteContent| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &LinkerMuteContent| { &m.status },
            |m: &mut LinkerMuteContent| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerMuteContent>(
            "LinkerMuteContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerMuteContent {
    const NAME: &'static str = "LinkerMuteContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.userId = is.read_int64()?;
                },
                16 => {
                    self.status = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.userId);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.userId != 0 {
            os.write_int64(1, self.userId)?;
        }
        if self.status != 0 {
            os.write_int64(2, self.status)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerMuteContent {
        LinkerMuteContent::new()
    }

    fn clear(&mut self) {
        self.userId = 0;
        self.status = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerMuteContent {
        static instance: LinkerMuteContent = LinkerMuteContent {
            userId: 0,
            status: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerMuteContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerMuteContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerMuteContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerMuteContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerRandomMatchContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerRandomMatchContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerRandomMatchContent.user)
    pub user: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.LinkerRandomMatchContent.roomId)
    pub roomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerRandomMatchContent.inviteType)
    pub inviteType: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerRandomMatchContent.matchId)
    pub matchId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.LinkerRandomMatchContent.innerChannelId)
    pub innerChannelId: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerRandomMatchContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerRandomMatchContent {
    fn default() -> &'a LinkerRandomMatchContent {
        <LinkerRandomMatchContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerRandomMatchContent {
    pub fn new() -> LinkerRandomMatchContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "user",
            |m: &LinkerRandomMatchContent| { &m.user },
            |m: &mut LinkerRandomMatchContent| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomId",
            |m: &LinkerRandomMatchContent| { &m.roomId },
            |m: &mut LinkerRandomMatchContent| { &mut m.roomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inviteType",
            |m: &LinkerRandomMatchContent| { &m.inviteType },
            |m: &mut LinkerRandomMatchContent| { &mut m.inviteType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "matchId",
            |m: &LinkerRandomMatchContent| { &m.matchId },
            |m: &mut LinkerRandomMatchContent| { &mut m.matchId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "innerChannelId",
            |m: &LinkerRandomMatchContent| { &m.innerChannelId },
            |m: &mut LinkerRandomMatchContent| { &mut m.innerChannelId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerRandomMatchContent>(
            "LinkerRandomMatchContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerRandomMatchContent {
    const NAME: &'static str = "LinkerRandomMatchContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                16 => {
                    self.roomId = is.read_int64()?;
                },
                24 => {
                    self.inviteType = is.read_int64()?;
                },
                34 => {
                    self.matchId = is.read_string()?;
                },
                40 => {
                    self.innerChannelId = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.roomId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.roomId);
        }
        if self.inviteType != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.inviteType);
        }
        if !self.matchId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.matchId);
        }
        if self.innerChannelId != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.innerChannelId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.roomId != 0 {
            os.write_int64(2, self.roomId)?;
        }
        if self.inviteType != 0 {
            os.write_int64(3, self.inviteType)?;
        }
        if !self.matchId.is_empty() {
            os.write_string(4, &self.matchId)?;
        }
        if self.innerChannelId != 0 {
            os.write_int64(5, self.innerChannelId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerRandomMatchContent {
        LinkerRandomMatchContent::new()
    }

    fn clear(&mut self) {
        self.user.clear();
        self.roomId = 0;
        self.inviteType = 0;
        self.matchId.clear();
        self.innerChannelId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerRandomMatchContent {
        static instance: LinkerRandomMatchContent = LinkerRandomMatchContent {
            user: ::protobuf::MessageField::none(),
            roomId: 0,
            inviteType: 0,
            matchId: ::std::string::String::new(),
            innerChannelId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerRandomMatchContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerRandomMatchContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerRandomMatchContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerRandomMatchContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerReplyContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerReplyContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.fromUserId)
    pub fromUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.fromRoomId)
    pub fromRoomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.fromUserLinkmicInfo)
    pub fromUserLinkmicInfo: ::protobuf::MessageField<linker_reply_content::LinkmicInfo>,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.toUserId)
    pub toUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.toUserLinkmicInfo)
    pub toUserLinkmicInfo: ::protobuf::MessageField<linker_reply_content::LinkmicInfo>,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.linkType)
    pub linkType: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.replyStatus)
    pub replyStatus: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.linkerSetting)
    pub linkerSetting: ::protobuf::MessageField<LinkerSetting>,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.fromUser)
    pub fromUser: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.toUser)
    pub toUser: ::protobuf::MessageField<User>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerReplyContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerReplyContent {
    fn default() -> &'a LinkerReplyContent {
        <LinkerReplyContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerReplyContent {
    pub fn new() -> LinkerReplyContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromUserId",
            |m: &LinkerReplyContent| { &m.fromUserId },
            |m: &mut LinkerReplyContent| { &mut m.fromUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromRoomId",
            |m: &LinkerReplyContent| { &m.fromRoomId },
            |m: &mut LinkerReplyContent| { &mut m.fromRoomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, linker_reply_content::LinkmicInfo>(
            "fromUserLinkmicInfo",
            |m: &LinkerReplyContent| { &m.fromUserLinkmicInfo },
            |m: &mut LinkerReplyContent| { &mut m.fromUserLinkmicInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toUserId",
            |m: &LinkerReplyContent| { &m.toUserId },
            |m: &mut LinkerReplyContent| { &mut m.toUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, linker_reply_content::LinkmicInfo>(
            "toUserLinkmicInfo",
            |m: &LinkerReplyContent| { &m.toUserLinkmicInfo },
            |m: &mut LinkerReplyContent| { &mut m.toUserLinkmicInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkType",
            |m: &LinkerReplyContent| { &m.linkType },
            |m: &mut LinkerReplyContent| { &mut m.linkType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replyStatus",
            |m: &LinkerReplyContent| { &m.replyStatus },
            |m: &mut LinkerReplyContent| { &mut m.replyStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkerSetting>(
            "linkerSetting",
            |m: &LinkerReplyContent| { &m.linkerSetting },
            |m: &mut LinkerReplyContent| { &mut m.linkerSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "fromUser",
            |m: &LinkerReplyContent| { &m.fromUser },
            |m: &mut LinkerReplyContent| { &mut m.fromUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "toUser",
            |m: &LinkerReplyContent| { &m.toUser },
            |m: &mut LinkerReplyContent| { &mut m.toUser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerReplyContent>(
            "LinkerReplyContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerReplyContent {
    const NAME: &'static str = "LinkerReplyContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fromUserId = is.read_int64()?;
                },
                16 => {
                    self.fromRoomId = is.read_int64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fromUserLinkmicInfo)?;
                },
                32 => {
                    self.toUserId = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.toUserLinkmicInfo)?;
                },
                48 => {
                    self.linkType = is.read_int64()?;
                },
                56 => {
                    self.replyStatus = is.read_int64()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.linkerSetting)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fromUser)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.toUser)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fromUserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.fromUserId);
        }
        if self.fromRoomId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.fromRoomId);
        }
        if let Some(v) = self.fromUserLinkmicInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.toUserId != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.toUserId);
        }
        if let Some(v) = self.toUserLinkmicInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.linkType != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.linkType);
        }
        if self.replyStatus != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.replyStatus);
        }
        if let Some(v) = self.linkerSetting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fromUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.toUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fromUserId != 0 {
            os.write_int64(1, self.fromUserId)?;
        }
        if self.fromRoomId != 0 {
            os.write_int64(2, self.fromRoomId)?;
        }
        if let Some(v) = self.fromUserLinkmicInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.toUserId != 0 {
            os.write_int64(4, self.toUserId)?;
        }
        if let Some(v) = self.toUserLinkmicInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.linkType != 0 {
            os.write_int64(6, self.linkType)?;
        }
        if self.replyStatus != 0 {
            os.write_int64(7, self.replyStatus)?;
        }
        if let Some(v) = self.linkerSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.fromUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.toUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerReplyContent {
        LinkerReplyContent::new()
    }

    fn clear(&mut self) {
        self.fromUserId = 0;
        self.fromRoomId = 0;
        self.fromUserLinkmicInfo.clear();
        self.toUserId = 0;
        self.toUserLinkmicInfo.clear();
        self.linkType = 0;
        self.replyStatus = 0;
        self.linkerSetting.clear();
        self.fromUser.clear();
        self.toUser.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerReplyContent {
        static instance: LinkerReplyContent = LinkerReplyContent {
            fromUserId: 0,
            fromRoomId: 0,
            fromUserLinkmicInfo: ::protobuf::MessageField::none(),
            toUserId: 0,
            toUserLinkmicInfo: ::protobuf::MessageField::none(),
            linkType: 0,
            replyStatus: 0,
            linkerSetting: ::protobuf::MessageField::none(),
            fromUser: ::protobuf::MessageField::none(),
            toUser: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerReplyContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerReplyContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerReplyContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerReplyContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LinkerReplyContent`
pub mod linker_reply_content {
    // @@protoc_insertion_point(message:TikTok.LinkerReplyContent.LinkmicInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkmicInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.accessKey)
        pub accessKey: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.linkMicId)
        pub linkMicId: i64,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.joinable)
        pub joinable: bool,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.confluenceType)
        pub confluenceType: i32,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.rtcExtInfo)
        pub rtcExtInfo: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.rtcAppId)
        pub rtcAppId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.rtcAppSign)
        pub rtcAppSign: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.linkmicIdStr)
        pub linkmicIdStr: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.LinkerReplyContent.LinkmicInfo.vendor)
        pub vendor: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.LinkerReplyContent.LinkmicInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkmicInfo {
        fn default() -> &'a LinkmicInfo {
            <LinkmicInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkmicInfo {
        pub fn new() -> LinkmicInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "accessKey",
                |m: &LinkmicInfo| { &m.accessKey },
                |m: &mut LinkmicInfo| { &mut m.accessKey },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "linkMicId",
                |m: &LinkmicInfo| { &m.linkMicId },
                |m: &mut LinkmicInfo| { &mut m.linkMicId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "joinable",
                |m: &LinkmicInfo| { &m.joinable },
                |m: &mut LinkmicInfo| { &mut m.joinable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "confluenceType",
                |m: &LinkmicInfo| { &m.confluenceType },
                |m: &mut LinkmicInfo| { &mut m.confluenceType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rtcExtInfo",
                |m: &LinkmicInfo| { &m.rtcExtInfo },
                |m: &mut LinkmicInfo| { &mut m.rtcExtInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rtcAppId",
                |m: &LinkmicInfo| { &m.rtcAppId },
                |m: &mut LinkmicInfo| { &mut m.rtcAppId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rtcAppSign",
                |m: &LinkmicInfo| { &m.rtcAppSign },
                |m: &mut LinkmicInfo| { &mut m.rtcAppSign },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "linkmicIdStr",
                |m: &LinkmicInfo| { &m.linkmicIdStr },
                |m: &mut LinkmicInfo| { &mut m.linkmicIdStr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "vendor",
                |m: &LinkmicInfo| { &m.vendor },
                |m: &mut LinkmicInfo| { &mut m.vendor },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkmicInfo>(
                "LinkerReplyContent.LinkmicInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkmicInfo {
        const NAME: &'static str = "LinkmicInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.accessKey = is.read_string()?;
                    },
                    16 => {
                        self.linkMicId = is.read_int64()?;
                    },
                    24 => {
                        self.joinable = is.read_bool()?;
                    },
                    32 => {
                        self.confluenceType = is.read_int32()?;
                    },
                    42 => {
                        self.rtcExtInfo = is.read_string()?;
                    },
                    50 => {
                        self.rtcAppId = is.read_string()?;
                    },
                    58 => {
                        self.rtcAppSign = is.read_string()?;
                    },
                    66 => {
                        self.linkmicIdStr = is.read_string()?;
                    },
                    72 => {
                        self.vendor = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.accessKey.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.accessKey);
            }
            if self.linkMicId != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.linkMicId);
            }
            if self.joinable != false {
                my_size += 1 + 1;
            }
            if self.confluenceType != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.confluenceType);
            }
            if !self.rtcExtInfo.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.rtcExtInfo);
            }
            if !self.rtcAppId.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.rtcAppId);
            }
            if !self.rtcAppSign.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.rtcAppSign);
            }
            if !self.linkmicIdStr.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.linkmicIdStr);
            }
            if self.vendor != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.vendor);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.accessKey.is_empty() {
                os.write_string(1, &self.accessKey)?;
            }
            if self.linkMicId != 0 {
                os.write_int64(2, self.linkMicId)?;
            }
            if self.joinable != false {
                os.write_bool(3, self.joinable)?;
            }
            if self.confluenceType != 0 {
                os.write_int32(4, self.confluenceType)?;
            }
            if !self.rtcExtInfo.is_empty() {
                os.write_string(5, &self.rtcExtInfo)?;
            }
            if !self.rtcAppId.is_empty() {
                os.write_string(6, &self.rtcAppId)?;
            }
            if !self.rtcAppSign.is_empty() {
                os.write_string(7, &self.rtcAppSign)?;
            }
            if !self.linkmicIdStr.is_empty() {
                os.write_string(8, &self.linkmicIdStr)?;
            }
            if self.vendor != 0 {
                os.write_int64(9, self.vendor)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkmicInfo {
            LinkmicInfo::new()
        }

        fn clear(&mut self) {
            self.accessKey.clear();
            self.linkMicId = 0;
            self.joinable = false;
            self.confluenceType = 0;
            self.rtcExtInfo.clear();
            self.rtcAppId.clear();
            self.rtcAppSign.clear();
            self.linkmicIdStr.clear();
            self.vendor = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkmicInfo {
            static instance: LinkmicInfo = LinkmicInfo {
                accessKey: ::std::string::String::new(),
                linkMicId: 0,
                joinable: false,
                confluenceType: 0,
                rtcExtInfo: ::std::string::String::new(),
                rtcAppId: ::std::string::String::new(),
                rtcAppSign: ::std::string::String::new(),
                linkmicIdStr: ::std::string::String::new(),
                vendor: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkmicInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LinkerReplyContent.LinkmicInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkmicInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkmicInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.LinkerSetting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerSetting {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerSetting.MaxMemberLimit)
    pub MaxMemberLimit: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerSetting.LinkType)
    pub LinkType: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerSetting.Scene)
    pub Scene: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerSetting.OwnerUserId)
    pub OwnerUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerSetting.OwnerRoomId)
    pub OwnerRoomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerSetting.Vendor)
    pub Vendor: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerSetting {
    fn default() -> &'a LinkerSetting {
        <LinkerSetting as ::protobuf::Message>::default_instance()
    }
}

impl LinkerSetting {
    pub fn new() -> LinkerSetting {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MaxMemberLimit",
            |m: &LinkerSetting| { &m.MaxMemberLimit },
            |m: &mut LinkerSetting| { &mut m.MaxMemberLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LinkType",
            |m: &LinkerSetting| { &m.LinkType },
            |m: &mut LinkerSetting| { &mut m.LinkType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Scene",
            |m: &LinkerSetting| { &m.Scene },
            |m: &mut LinkerSetting| { &mut m.Scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OwnerUserId",
            |m: &LinkerSetting| { &m.OwnerUserId },
            |m: &mut LinkerSetting| { &mut m.OwnerUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "OwnerRoomId",
            |m: &LinkerSetting| { &m.OwnerRoomId },
            |m: &mut LinkerSetting| { &mut m.OwnerRoomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Vendor",
            |m: &LinkerSetting| { &m.Vendor },
            |m: &mut LinkerSetting| { &mut m.Vendor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerSetting>(
            "LinkerSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerSetting {
    const NAME: &'static str = "LinkerSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.MaxMemberLimit = is.read_int64()?;
                },
                16 => {
                    self.LinkType = is.read_int64()?;
                },
                24 => {
                    self.Scene = is.read_int64()?;
                },
                32 => {
                    self.OwnerUserId = is.read_int64()?;
                },
                40 => {
                    self.OwnerRoomId = is.read_int64()?;
                },
                48 => {
                    self.Vendor = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.MaxMemberLimit != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.MaxMemberLimit);
        }
        if self.LinkType != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.LinkType);
        }
        if self.Scene != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.Scene);
        }
        if self.OwnerUserId != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.OwnerUserId);
        }
        if self.OwnerRoomId != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.OwnerRoomId);
        }
        if self.Vendor != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.Vendor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.MaxMemberLimit != 0 {
            os.write_int64(1, self.MaxMemberLimit)?;
        }
        if self.LinkType != 0 {
            os.write_int64(2, self.LinkType)?;
        }
        if self.Scene != 0 {
            os.write_int64(3, self.Scene)?;
        }
        if self.OwnerUserId != 0 {
            os.write_int64(4, self.OwnerUserId)?;
        }
        if self.OwnerRoomId != 0 {
            os.write_int64(5, self.OwnerRoomId)?;
        }
        if self.Vendor != 0 {
            os.write_int64(6, self.Vendor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerSetting {
        LinkerSetting::new()
    }

    fn clear(&mut self) {
        self.MaxMemberLimit = 0;
        self.LinkType = 0;
        self.Scene = 0;
        self.OwnerUserId = 0;
        self.OwnerRoomId = 0;
        self.Vendor = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerSetting {
        static instance: LinkerSetting = LinkerSetting {
            MaxMemberLimit: 0,
            LinkType: 0,
            Scene: 0,
            OwnerUserId: 0,
            OwnerRoomId: 0,
            Vendor: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerSysKickOutContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerSysKickOutContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerSysKickOutContent.userId)
    pub userId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerSysKickOutContent.linkmicIdStr)
    pub linkmicIdStr: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerSysKickOutContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerSysKickOutContent {
    fn default() -> &'a LinkerSysKickOutContent {
        <LinkerSysKickOutContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerSysKickOutContent {
    pub fn new() -> LinkerSysKickOutContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &LinkerSysKickOutContent| { &m.userId },
            |m: &mut LinkerSysKickOutContent| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkmicIdStr",
            |m: &LinkerSysKickOutContent| { &m.linkmicIdStr },
            |m: &mut LinkerSysKickOutContent| { &mut m.linkmicIdStr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerSysKickOutContent>(
            "LinkerSysKickOutContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerSysKickOutContent {
    const NAME: &'static str = "LinkerSysKickOutContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.userId = is.read_int64()?;
                },
                18 => {
                    self.linkmicIdStr = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.userId);
        }
        if !self.linkmicIdStr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.linkmicIdStr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.userId != 0 {
            os.write_int64(1, self.userId)?;
        }
        if !self.linkmicIdStr.is_empty() {
            os.write_string(2, &self.linkmicIdStr)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerSysKickOutContent {
        LinkerSysKickOutContent::new()
    }

    fn clear(&mut self) {
        self.userId = 0;
        self.linkmicIdStr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerSysKickOutContent {
        static instance: LinkerSysKickOutContent = LinkerSysKickOutContent {
            userId: 0,
            linkmicIdStr: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerSysKickOutContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerSysKickOutContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerSysKickOutContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerSysKickOutContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkmicUserToastContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkmicUserToastContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkmicUserToastContent.userId)
    pub userId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkmicUserToastContent.roomId)
    pub roomId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkmicUserToastContent.displayText)
    pub displayText: ::protobuf::MessageField<Text>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkmicUserToastContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkmicUserToastContent {
    fn default() -> &'a LinkmicUserToastContent {
        <LinkmicUserToastContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkmicUserToastContent {
    pub fn new() -> LinkmicUserToastContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &LinkmicUserToastContent| { &m.userId },
            |m: &mut LinkmicUserToastContent| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomId",
            |m: &LinkmicUserToastContent| { &m.roomId },
            |m: &mut LinkmicUserToastContent| { &mut m.roomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Text>(
            "displayText",
            |m: &LinkmicUserToastContent| { &m.displayText },
            |m: &mut LinkmicUserToastContent| { &mut m.displayText },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkmicUserToastContent>(
            "LinkmicUserToastContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkmicUserToastContent {
    const NAME: &'static str = "LinkmicUserToastContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.userId = is.read_int64()?;
                },
                16 => {
                    self.roomId = is.read_int64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.userId);
        }
        if self.roomId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.roomId);
        }
        if let Some(v) = self.displayText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.userId != 0 {
            os.write_int64(1, self.userId)?;
        }
        if self.roomId != 0 {
            os.write_int64(2, self.roomId)?;
        }
        if let Some(v) = self.displayText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkmicUserToastContent {
        LinkmicUserToastContent::new()
    }

    fn clear(&mut self) {
        self.userId = 0;
        self.roomId = 0;
        self.displayText.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkmicUserToastContent {
        static instance: LinkmicUserToastContent = LinkmicUserToastContent {
            userId: 0,
            roomId: 0,
            displayText: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkmicUserToastContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkmicUserToastContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkmicUserToastContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkmicUserToastContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerUpdateUserContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerUpdateUserContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkerUpdateUserContent.fromUserId)
    pub fromUserId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkerUpdateUserContent.toUserId)
    pub toUserId: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerUpdateUserContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerUpdateUserContent {
    fn default() -> &'a LinkerUpdateUserContent {
        <LinkerUpdateUserContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerUpdateUserContent {
    pub fn new() -> LinkerUpdateUserContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromUserId",
            |m: &LinkerUpdateUserContent| { &m.fromUserId },
            |m: &mut LinkerUpdateUserContent| { &mut m.fromUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toUserId",
            |m: &LinkerUpdateUserContent| { &m.toUserId },
            |m: &mut LinkerUpdateUserContent| { &mut m.toUserId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerUpdateUserContent>(
            "LinkerUpdateUserContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerUpdateUserContent {
    const NAME: &'static str = "LinkerUpdateUserContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fromUserId = is.read_int64()?;
                },
                16 => {
                    self.toUserId = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fromUserId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.fromUserId);
        }
        if self.toUserId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.toUserId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fromUserId != 0 {
            os.write_int64(1, self.fromUserId)?;
        }
        if self.toUserId != 0 {
            os.write_int64(2, self.toUserId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerUpdateUserContent {
        LinkerUpdateUserContent::new()
    }

    fn clear(&mut self) {
        self.fromUserId = 0;
        self.toUserId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerUpdateUserContent {
        static instance: LinkerUpdateUserContent = LinkerUpdateUserContent {
            fromUserId: 0,
            toUserId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerUpdateUserContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerUpdateUserContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerUpdateUserContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerUpdateUserContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerUpdateUserSettingContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerUpdateUserSettingContent {
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerUpdateUserSettingContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerUpdateUserSettingContent {
    fn default() -> &'a LinkerUpdateUserSettingContent {
        <LinkerUpdateUserSettingContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerUpdateUserSettingContent {
    pub fn new() -> LinkerUpdateUserSettingContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerUpdateUserSettingContent>(
            "LinkerUpdateUserSettingContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerUpdateUserSettingContent {
    const NAME: &'static str = "LinkerUpdateUserSettingContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerUpdateUserSettingContent {
        LinkerUpdateUserSettingContent::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerUpdateUserSettingContent {
        static instance: LinkerUpdateUserSettingContent = LinkerUpdateUserSettingContent {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerUpdateUserSettingContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerUpdateUserSettingContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerUpdateUserSettingContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerUpdateUserSettingContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkerWaitingListChangeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkerWaitingListChangeContent {
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkerWaitingListChangeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkerWaitingListChangeContent {
    fn default() -> &'a LinkerWaitingListChangeContent {
        <LinkerWaitingListChangeContent as ::protobuf::Message>::default_instance()
    }
}

impl LinkerWaitingListChangeContent {
    pub fn new() -> LinkerWaitingListChangeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkerWaitingListChangeContent>(
            "LinkerWaitingListChangeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkerWaitingListChangeContent {
    const NAME: &'static str = "LinkerWaitingListChangeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkerWaitingListChangeContent {
        LinkerWaitingListChangeContent::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkerWaitingListChangeContent {
        static instance: LinkerWaitingListChangeContent = LinkerWaitingListChangeContent {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkerWaitingListChangeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkerWaitingListChangeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkerWaitingListChangeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkerWaitingListChangeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkmicUserSettingInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkmicUserSettingInfo {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkmicUserSettingInfo.userId)
    pub userId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkmicUserSettingInfo.layout)
    pub layout: i64,
    // @@protoc_insertion_point(field:TikTok.LinkmicUserSettingInfo.fixMicNum)
    pub fixMicNum: i64,
    // @@protoc_insertion_point(field:TikTok.LinkmicUserSettingInfo.allowRequestFromUser)
    pub allowRequestFromUser: i64,
    // @@protoc_insertion_point(field:TikTok.LinkmicUserSettingInfo.allowRequestFromFollowerOnly)
    pub allowRequestFromFollowerOnly: i64,
    // @@protoc_insertion_point(field:TikTok.LinkmicUserSettingInfo.applierSortSetting)
    pub applierSortSetting: ::protobuf::EnumOrUnknown<super::enums::LinkmicApplierSortSetting>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkmicUserSettingInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkmicUserSettingInfo {
    fn default() -> &'a LinkmicUserSettingInfo {
        <LinkmicUserSettingInfo as ::protobuf::Message>::default_instance()
    }
}

impl LinkmicUserSettingInfo {
    pub fn new() -> LinkmicUserSettingInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &LinkmicUserSettingInfo| { &m.userId },
            |m: &mut LinkmicUserSettingInfo| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "layout",
            |m: &LinkmicUserSettingInfo| { &m.layout },
            |m: &mut LinkmicUserSettingInfo| { &mut m.layout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fixMicNum",
            |m: &LinkmicUserSettingInfo| { &m.fixMicNum },
            |m: &mut LinkmicUserSettingInfo| { &mut m.fixMicNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowRequestFromUser",
            |m: &LinkmicUserSettingInfo| { &m.allowRequestFromUser },
            |m: &mut LinkmicUserSettingInfo| { &mut m.allowRequestFromUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowRequestFromFollowerOnly",
            |m: &LinkmicUserSettingInfo| { &m.allowRequestFromFollowerOnly },
            |m: &mut LinkmicUserSettingInfo| { &mut m.allowRequestFromFollowerOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "applierSortSetting",
            |m: &LinkmicUserSettingInfo| { &m.applierSortSetting },
            |m: &mut LinkmicUserSettingInfo| { &mut m.applierSortSetting },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkmicUserSettingInfo>(
            "LinkmicUserSettingInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkmicUserSettingInfo {
    const NAME: &'static str = "LinkmicUserSettingInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.userId = is.read_int64()?;
                },
                16 => {
                    self.layout = is.read_int64()?;
                },
                24 => {
                    self.fixMicNum = is.read_int64()?;
                },
                32 => {
                    self.allowRequestFromUser = is.read_int64()?;
                },
                40 => {
                    self.allowRequestFromFollowerOnly = is.read_int64()?;
                },
                56 => {
                    self.applierSortSetting = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.userId);
        }
        if self.layout != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.layout);
        }
        if self.fixMicNum != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.fixMicNum);
        }
        if self.allowRequestFromUser != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.allowRequestFromUser);
        }
        if self.allowRequestFromFollowerOnly != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.allowRequestFromFollowerOnly);
        }
        if self.applierSortSetting != ::protobuf::EnumOrUnknown::new(super::enums::LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.applierSortSetting.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.userId != 0 {
            os.write_int64(1, self.userId)?;
        }
        if self.layout != 0 {
            os.write_int64(2, self.layout)?;
        }
        if self.fixMicNum != 0 {
            os.write_int64(3, self.fixMicNum)?;
        }
        if self.allowRequestFromUser != 0 {
            os.write_int64(4, self.allowRequestFromUser)?;
        }
        if self.allowRequestFromFollowerOnly != 0 {
            os.write_int64(5, self.allowRequestFromFollowerOnly)?;
        }
        if self.applierSortSetting != ::protobuf::EnumOrUnknown::new(super::enums::LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.applierSortSetting))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkmicUserSettingInfo {
        LinkmicUserSettingInfo::new()
    }

    fn clear(&mut self) {
        self.userId = 0;
        self.layout = 0;
        self.fixMicNum = 0;
        self.allowRequestFromUser = 0;
        self.allowRequestFromFollowerOnly = 0;
        self.applierSortSetting = ::protobuf::EnumOrUnknown::new(super::enums::LinkmicApplierSortSetting::LINKMIC_APPLIER_SORT_SETTING_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkmicUserSettingInfo {
        static instance: LinkmicUserSettingInfo = LinkmicUserSettingInfo {
            userId: 0,
            layout: 0,
            fixMicNum: 0,
            allowRequestFromUser: 0,
            allowRequestFromFollowerOnly: 0,
            applierSortSetting: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkmicUserSettingInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkmicUserSettingInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkmicUserSettingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkmicUserSettingInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.Player)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Player {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Player.roomId)
    pub roomId: i64,
    // @@protoc_insertion_point(field:TikTok.Player.userId)
    pub userId: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Player.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Player {
    fn default() -> &'a Player {
        <Player as ::protobuf::Message>::default_instance()
    }
}

impl Player {
    pub fn new() -> Player {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomId",
            |m: &Player| { &m.roomId },
            |m: &mut Player| { &mut m.roomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &Player| { &m.userId },
            |m: &mut Player| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
            "Player",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Player {
    const NAME: &'static str = "Player";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.roomId = is.read_int64()?;
                },
                16 => {
                    self.userId = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.roomId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.roomId);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.roomId != 0 {
            os.write_int64(1, self.roomId)?;
        }
        if self.userId != 0 {
            os.write_int64(2, self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Player {
        Player::new()
    }

    fn clear(&mut self) {
        self.roomId = 0;
        self.userId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Player {
        static instance: Player = Player {
            roomId: 0,
            userId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Player {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Player").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Player {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.AllListUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllListUser {
    // message fields
    // @@protoc_insertion_point(field:TikTok.AllListUser.linkedList)
    pub linkedList: ::std::vec::Vec<LinkLayerListUser>,
    // @@protoc_insertion_point(field:TikTok.AllListUser.appliedList)
    pub appliedList: ::std::vec::Vec<LinkLayerListUser>,
    // @@protoc_insertion_point(field:TikTok.AllListUser.invitedList)
    pub invitedList: ::std::vec::Vec<LinkLayerListUser>,
    // @@protoc_insertion_point(field:TikTok.AllListUser.readyList)
    pub readyList: ::std::vec::Vec<LinkLayerListUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.AllListUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllListUser {
    fn default() -> &'a AllListUser {
        <AllListUser as ::protobuf::Message>::default_instance()
    }
}

impl AllListUser {
    pub fn new() -> AllListUser {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "linkedList",
            |m: &AllListUser| { &m.linkedList },
            |m: &mut AllListUser| { &mut m.linkedList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appliedList",
            |m: &AllListUser| { &m.appliedList },
            |m: &mut AllListUser| { &mut m.appliedList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invitedList",
            |m: &AllListUser| { &m.invitedList },
            |m: &mut AllListUser| { &mut m.invitedList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "readyList",
            |m: &AllListUser| { &m.readyList },
            |m: &mut AllListUser| { &mut m.readyList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllListUser>(
            "AllListUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllListUser {
    const NAME: &'static str = "AllListUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.linkedList.push(is.read_message()?);
                },
                26 => {
                    self.appliedList.push(is.read_message()?);
                },
                34 => {
                    self.invitedList.push(is.read_message()?);
                },
                42 => {
                    self.readyList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.linkedList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.appliedList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.invitedList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.readyList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.linkedList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.appliedList {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.invitedList {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.readyList {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllListUser {
        AllListUser::new()
    }

    fn clear(&mut self) {
        self.linkedList.clear();
        self.appliedList.clear();
        self.invitedList.clear();
        self.readyList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllListUser {
        static instance: AllListUser = AllListUser {
            linkedList: ::std::vec::Vec::new(),
            appliedList: ::std::vec::Vec::new(),
            invitedList: ::std::vec::Vec::new(),
            readyList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllListUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllListUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllListUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllListUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkLayerListUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkLayerListUser {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkLayerListUser.user)
    pub user: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.LinkLayerListUser.linkmicId)
    pub linkmicId: i64,
    // @@protoc_insertion_point(field:TikTok.LinkLayerListUser.pos)
    pub pos: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:TikTok.LinkLayerListUser.linkedTimeNano)
    pub linkedTimeNano: i64,
    // @@protoc_insertion_point(field:TikTok.LinkLayerListUser.appVersion)
    pub appVersion: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.LinkLayerListUser.magicNumber1)
    pub magicNumber1: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkLayerListUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkLayerListUser {
    fn default() -> &'a LinkLayerListUser {
        <LinkLayerListUser as ::protobuf::Message>::default_instance()
    }
}

impl LinkLayerListUser {
    pub fn new() -> LinkLayerListUser {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "user",
            |m: &LinkLayerListUser| { &m.user },
            |m: &mut LinkLayerListUser| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkmicId",
            |m: &LinkLayerListUser| { &m.linkmicId },
            |m: &mut LinkLayerListUser| { &mut m.linkmicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "pos",
            |m: &LinkLayerListUser| { &m.pos },
            |m: &mut LinkLayerListUser| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkedTimeNano",
            |m: &LinkLayerListUser| { &m.linkedTimeNano },
            |m: &mut LinkLayerListUser| { &mut m.linkedTimeNano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "appVersion",
            |m: &LinkLayerListUser| { &m.appVersion },
            |m: &mut LinkLayerListUser| { &mut m.appVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "magicNumber1",
            |m: &LinkLayerListUser| { &m.magicNumber1 },
            |m: &mut LinkLayerListUser| { &mut m.magicNumber1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkLayerListUser>(
            "LinkLayerListUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkLayerListUser {
    const NAME: &'static str = "LinkLayerListUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                16 => {
                    self.linkmicId = is.read_int64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                32 => {
                    self.linkedTimeNano = is.read_int64()?;
                },
                42 => {
                    self.appVersion = is.read_string()?;
                },
                56 => {
                    self.magicNumber1 = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.linkmicId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.linkmicId);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.linkedTimeNano != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.linkedTimeNano);
        }
        if !self.appVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.appVersion);
        }
        if self.magicNumber1 != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.magicNumber1);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.linkmicId != 0 {
            os.write_int64(2, self.linkmicId)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.linkedTimeNano != 0 {
            os.write_int64(4, self.linkedTimeNano)?;
        }
        if !self.appVersion.is_empty() {
            os.write_string(5, &self.appVersion)?;
        }
        if self.magicNumber1 != 0 {
            os.write_int64(7, self.magicNumber1)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkLayerListUser {
        LinkLayerListUser::new()
    }

    fn clear(&mut self) {
        self.user.clear();
        self.linkmicId = 0;
        self.pos.clear();
        self.linkedTimeNano = 0;
        self.appVersion.clear();
        self.magicNumber1 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkLayerListUser {
        static instance: LinkLayerListUser = LinkLayerListUser {
            user: ::protobuf::MessageField::none(),
            linkmicId: 0,
            pos: ::protobuf::MessageField::none(),
            linkedTimeNano: 0,
            appVersion: ::std::string::String::new(),
            magicNumber1: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkLayerListUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkLayerListUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkLayerListUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkLayerListUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Position {
    // message fields
    // @@protoc_insertion_point(field:TikTok.Position.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:TikTok.Position.link)
    pub link: ::protobuf::MessageField<LinkPosition>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Position| { &m.type_ },
            |m: &mut Position| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkPosition>(
            "link",
            |m: &Position| { &m.link },
            |m: &mut Position| { &mut m.link },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.link)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.type_);
        }
        if let Some(v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != 0 {
            os.write_int32(1, self.type_)?;
        }
        if let Some(v) = self.link.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.type_ = 0;
        self.link.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            type_: 0,
            link: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LinkPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkPosition {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LinkPosition.position)
    pub position: i32,
    // @@protoc_insertion_point(field:TikTok.LinkPosition.opt)
    pub opt: i32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LinkPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkPosition {
    fn default() -> &'a LinkPosition {
        <LinkPosition as ::protobuf::Message>::default_instance()
    }
}

impl LinkPosition {
    pub fn new() -> LinkPosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &LinkPosition| { &m.position },
            |m: &mut LinkPosition| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "opt",
            |m: &LinkPosition| { &m.opt },
            |m: &mut LinkPosition| { &mut m.opt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkPosition>(
            "LinkPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkPosition {
    const NAME: &'static str = "LinkPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.position = is.read_int32()?;
                },
                16 => {
                    self.opt = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.position != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.position);
        }
        if self.opt != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.opt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.position != 0 {
            os.write_int32(1, self.position)?;
        }
        if self.opt != 0 {
            os.write_int32(2, self.opt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkPosition {
        LinkPosition::new()
    }

    fn clear(&mut self) {
        self.position = 0;
        self.opt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkPosition {
        static instance: LinkPosition = LinkPosition {
            position: 0,
            opt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.GroupPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupPlayer {
    // message fields
    // @@protoc_insertion_point(field:TikTok.GroupPlayer.channelId)
    pub channelId: i64,
    // @@protoc_insertion_point(field:TikTok.GroupPlayer.user)
    pub user: ::protobuf::MessageField<User>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.GroupPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupPlayer {
    fn default() -> &'a GroupPlayer {
        <GroupPlayer as ::protobuf::Message>::default_instance()
    }
}

impl GroupPlayer {
    pub fn new() -> GroupPlayer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channelId",
            |m: &GroupPlayer| { &m.channelId },
            |m: &mut GroupPlayer| { &mut m.channelId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "user",
            |m: &GroupPlayer| { &m.user },
            |m: &mut GroupPlayer| { &mut m.user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupPlayer>(
            "GroupPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupPlayer {
    const NAME: &'static str = "GroupPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channelId = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.channelId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.channelId);
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.channelId != 0 {
            os.write_int64(1, self.channelId)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupPlayer {
        GroupPlayer::new()
    }

    fn clear(&mut self) {
        self.channelId = 0;
        self.user.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupPlayer {
        static instance: GroupPlayer = GroupPlayer {
            channelId: 0,
            user: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.DSLConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DSLConfig {
    // message fields
    // @@protoc_insertion_point(field:TikTok.DSLConfig.sceneVersion)
    pub sceneVersion: i32,
    // @@protoc_insertion_point(field:TikTok.DSLConfig.layoutId)
    pub layoutId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.DSLConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DSLConfig {
    fn default() -> &'a DSLConfig {
        <DSLConfig as ::protobuf::Message>::default_instance()
    }
}

impl DSLConfig {
    pub fn new() -> DSLConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sceneVersion",
            |m: &DSLConfig| { &m.sceneVersion },
            |m: &mut DSLConfig| { &mut m.sceneVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "layoutId",
            |m: &DSLConfig| { &m.layoutId },
            |m: &mut DSLConfig| { &mut m.layoutId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DSLConfig>(
            "DSLConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DSLConfig {
    const NAME: &'static str = "DSLConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sceneVersion = is.read_int32()?;
                },
                18 => {
                    self.layoutId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sceneVersion != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.sceneVersion);
        }
        if !self.layoutId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.layoutId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sceneVersion != 0 {
            os.write_int32(1, self.sceneVersion)?;
        }
        if !self.layoutId.is_empty() {
            os.write_string(2, &self.layoutId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DSLConfig {
        DSLConfig::new()
    }

    fn clear(&mut self) {
        self.sceneVersion = 0;
        self.layoutId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DSLConfig {
        static instance: DSLConfig = DSLConfig {
            sceneVersion: 0,
            layoutId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DSLConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DSLConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DSLConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DSLConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.GroupChannelAllUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupChannelAllUser {
    // message fields
    // @@protoc_insertion_point(field:TikTok.GroupChannelAllUser.groupChannelId)
    pub groupChannelId: i64,
    // @@protoc_insertion_point(field:TikTok.GroupChannelAllUser.userList)
    pub userList: ::std::vec::Vec<GroupChannelUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.GroupChannelAllUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupChannelAllUser {
    fn default() -> &'a GroupChannelAllUser {
        <GroupChannelAllUser as ::protobuf::Message>::default_instance()
    }
}

impl GroupChannelAllUser {
    pub fn new() -> GroupChannelAllUser {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groupChannelId",
            |m: &GroupChannelAllUser| { &m.groupChannelId },
            |m: &mut GroupChannelAllUser| { &mut m.groupChannelId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userList",
            |m: &GroupChannelAllUser| { &m.userList },
            |m: &mut GroupChannelAllUser| { &mut m.userList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupChannelAllUser>(
            "GroupChannelAllUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupChannelAllUser {
    const NAME: &'static str = "GroupChannelAllUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupChannelId = is.read_int64()?;
                },
                18 => {
                    self.userList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.groupChannelId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.groupChannelId);
        }
        for value in &self.userList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.groupChannelId != 0 {
            os.write_int64(1, self.groupChannelId)?;
        }
        for v in &self.userList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupChannelAllUser {
        GroupChannelAllUser::new()
    }

    fn clear(&mut self) {
        self.groupChannelId = 0;
        self.userList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupChannelAllUser {
        static instance: GroupChannelAllUser = GroupChannelAllUser {
            groupChannelId: 0,
            userList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupChannelAllUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupChannelAllUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupChannelAllUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChannelAllUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.GroupChannelUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupChannelUser {
    // message fields
    // @@protoc_insertion_point(field:TikTok.GroupChannelUser.channelId)
    pub channelId: i64,
    // @@protoc_insertion_point(field:TikTok.GroupChannelUser.status)
    pub status: ::protobuf::EnumOrUnknown<super::enums::GroupStatus>,
    // @@protoc_insertion_point(field:TikTok.GroupChannelUser.type)
    pub type_: ::protobuf::EnumOrUnknown<super::enums::TextType>,
    // @@protoc_insertion_point(field:TikTok.GroupChannelUser.allUser)
    pub allUser: ::protobuf::MessageField<AllListUser>,
    // @@protoc_insertion_point(field:TikTok.GroupChannelUser.joinTime)
    pub joinTime: i64,
    // @@protoc_insertion_point(field:TikTok.GroupChannelUser.linkedTime)
    pub linkedTime: i64,
    // @@protoc_insertion_point(field:TikTok.GroupChannelUser.ownerUser)
    pub ownerUser: ::protobuf::MessageField<GroupPlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.GroupChannelUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupChannelUser {
    fn default() -> &'a GroupChannelUser {
        <GroupChannelUser as ::protobuf::Message>::default_instance()
    }
}

impl GroupChannelUser {
    pub fn new() -> GroupChannelUser {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channelId",
            |m: &GroupChannelUser| { &m.channelId },
            |m: &mut GroupChannelUser| { &mut m.channelId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &GroupChannelUser| { &m.status },
            |m: &mut GroupChannelUser| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &GroupChannelUser| { &m.type_ },
            |m: &mut GroupChannelUser| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllListUser>(
            "allUser",
            |m: &GroupChannelUser| { &m.allUser },
            |m: &mut GroupChannelUser| { &mut m.allUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "joinTime",
            |m: &GroupChannelUser| { &m.joinTime },
            |m: &mut GroupChannelUser| { &mut m.joinTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "linkedTime",
            |m: &GroupChannelUser| { &m.linkedTime },
            |m: &mut GroupChannelUser| { &mut m.linkedTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupPlayer>(
            "ownerUser",
            |m: &GroupChannelUser| { &m.ownerUser },
            |m: &mut GroupChannelUser| { &mut m.ownerUser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupChannelUser>(
            "GroupChannelUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupChannelUser {
    const NAME: &'static str = "GroupChannelUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channelId = is.read_int64()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allUser)?;
                },
                40 => {
                    self.joinTime = is.read_int64()?;
                },
                48 => {
                    self.linkedTime = is.read_int64()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ownerUser)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.channelId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.channelId);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::enums::GroupStatus::GROUP_STATUS_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        if let Some(v) = self.allUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.joinTime != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.joinTime);
        }
        if self.linkedTime != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.linkedTime);
        }
        if let Some(v) = self.ownerUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.channelId != 0 {
            os.write_int64(1, self.channelId)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::enums::GroupStatus::GROUP_STATUS_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.allUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.joinTime != 0 {
            os.write_int64(5, self.joinTime)?;
        }
        if self.linkedTime != 0 {
            os.write_int64(6, self.linkedTime)?;
        }
        if let Some(v) = self.ownerUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupChannelUser {
        GroupChannelUser::new()
    }

    fn clear(&mut self) {
        self.channelId = 0;
        self.status = ::protobuf::EnumOrUnknown::new(super::enums::GroupStatus::GROUP_STATUS_UNKNOWN);
        self.type_ = ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT);
        self.allUser.clear();
        self.joinTime = 0;
        self.linkedTime = 0;
        self.ownerUser.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupChannelUser {
        static instance: GroupChannelUser = GroupChannelUser {
            channelId: 0,
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            allUser: ::protobuf::MessageField::none(),
            joinTime: 0,
            linkedTime: 0,
            ownerUser: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupChannelUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupChannelUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupChannelUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupChannelUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.RTCExtraInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RTCExtraInfo {
    // message fields
    // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.liveRtcEngineConfig)
    pub liveRtcEngineConfig: ::protobuf::MessageField<rtcextra_info::RTCEngineConfig>,
    // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.liveRtcVideoParamList)
    pub liveRtcVideoParamList: ::std::vec::Vec<rtcextra_info::RTCLiveVideoParam>,
    // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.rtcBitrateMap)
    pub rtcBitrateMap: ::protobuf::MessageField<rtcextra_info::RTCBitrateMap>,
    // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.rtcFps)
    pub rtcFps: i32,
    // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.rtcBusinessId)
    pub rtcBusinessId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.interactClientType)
    pub interactClientType: i32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.RTCExtraInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RTCExtraInfo {
    fn default() -> &'a RTCExtraInfo {
        <RTCExtraInfo as ::protobuf::Message>::default_instance()
    }
}

impl RTCExtraInfo {
    pub fn new() -> RTCExtraInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, rtcextra_info::RTCEngineConfig>(
            "liveRtcEngineConfig",
            |m: &RTCExtraInfo| { &m.liveRtcEngineConfig },
            |m: &mut RTCExtraInfo| { &mut m.liveRtcEngineConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "liveRtcVideoParamList",
            |m: &RTCExtraInfo| { &m.liveRtcVideoParamList },
            |m: &mut RTCExtraInfo| { &mut m.liveRtcVideoParamList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, rtcextra_info::RTCBitrateMap>(
            "rtcBitrateMap",
            |m: &RTCExtraInfo| { &m.rtcBitrateMap },
            |m: &mut RTCExtraInfo| { &mut m.rtcBitrateMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rtcFps",
            |m: &RTCExtraInfo| { &m.rtcFps },
            |m: &mut RTCExtraInfo| { &mut m.rtcFps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rtcBusinessId",
            |m: &RTCExtraInfo| { &m.rtcBusinessId },
            |m: &mut RTCExtraInfo| { &mut m.rtcBusinessId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interactClientType",
            |m: &RTCExtraInfo| { &m.interactClientType },
            |m: &mut RTCExtraInfo| { &mut m.interactClientType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RTCExtraInfo>(
            "RTCExtraInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RTCExtraInfo {
    const NAME: &'static str = "RTCExtraInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.liveRtcEngineConfig)?;
                },
                18 => {
                    self.liveRtcVideoParamList.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rtcBitrateMap)?;
                },
                32 => {
                    self.rtcFps = is.read_int32()?;
                },
                66 => {
                    self.rtcBusinessId = is.read_string()?;
                },
                80 => {
                    self.interactClientType = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.liveRtcEngineConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.liveRtcVideoParamList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.rtcBitrateMap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.rtcFps != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.rtcFps);
        }
        if !self.rtcBusinessId.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.rtcBusinessId);
        }
        if self.interactClientType != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.interactClientType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.liveRtcEngineConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.liveRtcVideoParamList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.rtcBitrateMap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.rtcFps != 0 {
            os.write_int32(4, self.rtcFps)?;
        }
        if !self.rtcBusinessId.is_empty() {
            os.write_string(8, &self.rtcBusinessId)?;
        }
        if self.interactClientType != 0 {
            os.write_int32(10, self.interactClientType)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RTCExtraInfo {
        RTCExtraInfo::new()
    }

    fn clear(&mut self) {
        self.liveRtcEngineConfig.clear();
        self.liveRtcVideoParamList.clear();
        self.rtcBitrateMap.clear();
        self.rtcFps = 0;
        self.rtcBusinessId.clear();
        self.interactClientType = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RTCExtraInfo {
        static instance: RTCExtraInfo = RTCExtraInfo {
            liveRtcEngineConfig: ::protobuf::MessageField::none(),
            liveRtcVideoParamList: ::std::vec::Vec::new(),
            rtcBitrateMap: ::protobuf::MessageField::none(),
            rtcFps: 0,
            rtcBusinessId: ::std::string::String::new(),
            interactClientType: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RTCExtraInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RTCExtraInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RTCExtraInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RTCExtraInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RTCExtraInfo`
pub mod rtcextra_info {
    // @@protoc_insertion_point(message:TikTok.RTCExtraInfo.RTCEngineConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RTCEngineConfig {
        // message fields
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCEngineConfig.rtcAppId)
        pub rtcAppId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCEngineConfig.rtcUserId)
        pub rtcUserId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCEngineConfig.rtcToken)
        pub rtcToken: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCEngineConfig.rtcChannelId)
        pub rtcChannelId: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.RTCExtraInfo.RTCEngineConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RTCEngineConfig {
        fn default() -> &'a RTCEngineConfig {
            <RTCEngineConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl RTCEngineConfig {
        pub fn new() -> RTCEngineConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rtcAppId",
                |m: &RTCEngineConfig| { &m.rtcAppId },
                |m: &mut RTCEngineConfig| { &mut m.rtcAppId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rtcUserId",
                |m: &RTCEngineConfig| { &m.rtcUserId },
                |m: &mut RTCEngineConfig| { &mut m.rtcUserId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rtcToken",
                |m: &RTCEngineConfig| { &m.rtcToken },
                |m: &mut RTCEngineConfig| { &mut m.rtcToken },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rtcChannelId",
                |m: &RTCEngineConfig| { &m.rtcChannelId },
                |m: &mut RTCEngineConfig| { &mut m.rtcChannelId },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RTCEngineConfig>(
                "RTCExtraInfo.RTCEngineConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RTCEngineConfig {
        const NAME: &'static str = "RTCEngineConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.rtcAppId = is.read_string()?;
                    },
                    18 => {
                        self.rtcUserId = is.read_string()?;
                    },
                    26 => {
                        self.rtcToken = is.read_string()?;
                    },
                    32 => {
                        self.rtcChannelId = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.rtcAppId.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.rtcAppId);
            }
            if !self.rtcUserId.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.rtcUserId);
            }
            if !self.rtcToken.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.rtcToken);
            }
            if self.rtcChannelId != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.rtcChannelId);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.rtcAppId.is_empty() {
                os.write_string(1, &self.rtcAppId)?;
            }
            if !self.rtcUserId.is_empty() {
                os.write_string(2, &self.rtcUserId)?;
            }
            if !self.rtcToken.is_empty() {
                os.write_string(3, &self.rtcToken)?;
            }
            if self.rtcChannelId != 0 {
                os.write_int64(4, self.rtcChannelId)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RTCEngineConfig {
            RTCEngineConfig::new()
        }

        fn clear(&mut self) {
            self.rtcAppId.clear();
            self.rtcUserId.clear();
            self.rtcToken.clear();
            self.rtcChannelId = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RTCEngineConfig {
            static instance: RTCEngineConfig = RTCEngineConfig {
                rtcAppId: ::std::string::String::new(),
                rtcUserId: ::std::string::String::new(),
                rtcToken: ::std::string::String::new(),
                rtcChannelId: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RTCEngineConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RTCExtraInfo.RTCEngineConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RTCEngineConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RTCEngineConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.RTCExtraInfo.RTCLiveVideoParam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RTCLiveVideoParam {
        // message fields
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCLiveVideoParam.strategyId)
        pub strategyId: i32,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCLiveVideoParam.params)
        pub params: ::protobuf::MessageField<RTCVideoParam>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.RTCExtraInfo.RTCLiveVideoParam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RTCLiveVideoParam {
        fn default() -> &'a RTCLiveVideoParam {
            <RTCLiveVideoParam as ::protobuf::Message>::default_instance()
        }
    }

    impl RTCLiveVideoParam {
        pub fn new() -> RTCLiveVideoParam {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "strategyId",
                |m: &RTCLiveVideoParam| { &m.strategyId },
                |m: &mut RTCLiveVideoParam| { &mut m.strategyId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RTCVideoParam>(
                "params",
                |m: &RTCLiveVideoParam| { &m.params },
                |m: &mut RTCLiveVideoParam| { &mut m.params },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RTCLiveVideoParam>(
                "RTCExtraInfo.RTCLiveVideoParam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RTCLiveVideoParam {
        const NAME: &'static str = "RTCLiveVideoParam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.strategyId = is.read_int32()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.strategyId != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.strategyId);
            }
            if let Some(v) = self.params.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.strategyId != 0 {
                os.write_int32(1, self.strategyId)?;
            }
            if let Some(v) = self.params.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RTCLiveVideoParam {
            RTCLiveVideoParam::new()
        }

        fn clear(&mut self) {
            self.strategyId = 0;
            self.params.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RTCLiveVideoParam {
            static instance: RTCLiveVideoParam = RTCLiveVideoParam {
                strategyId: 0,
                params: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RTCLiveVideoParam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RTCExtraInfo.RTCLiveVideoParam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RTCLiveVideoParam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RTCLiveVideoParam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.RTCExtraInfo.RTCVideoParam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RTCVideoParam {
        // message fields
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCVideoParam.width)
        pub width: i32,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCVideoParam.height)
        pub height: i32,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCVideoParam.fps)
        pub fps: i32,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCVideoParam.bitrateKbps)
        pub bitrateKbps: i32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.RTCExtraInfo.RTCVideoParam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RTCVideoParam {
        fn default() -> &'a RTCVideoParam {
            <RTCVideoParam as ::protobuf::Message>::default_instance()
        }
    }

    impl RTCVideoParam {
        pub fn new() -> RTCVideoParam {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "width",
                |m: &RTCVideoParam| { &m.width },
                |m: &mut RTCVideoParam| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "height",
                |m: &RTCVideoParam| { &m.height },
                |m: &mut RTCVideoParam| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fps",
                |m: &RTCVideoParam| { &m.fps },
                |m: &mut RTCVideoParam| { &mut m.fps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "bitrateKbps",
                |m: &RTCVideoParam| { &m.bitrateKbps },
                |m: &mut RTCVideoParam| { &mut m.bitrateKbps },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RTCVideoParam>(
                "RTCExtraInfo.RTCVideoParam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RTCVideoParam {
        const NAME: &'static str = "RTCVideoParam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.width = is.read_int32()?;
                    },
                    16 => {
                        self.height = is.read_int32()?;
                    },
                    24 => {
                        self.fps = is.read_int32()?;
                    },
                    32 => {
                        self.bitrateKbps = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.width != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.width);
            }
            if self.height != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.height);
            }
            if self.fps != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.fps);
            }
            if self.bitrateKbps != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.bitrateKbps);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.width != 0 {
                os.write_int32(1, self.width)?;
            }
            if self.height != 0 {
                os.write_int32(2, self.height)?;
            }
            if self.fps != 0 {
                os.write_int32(3, self.fps)?;
            }
            if self.bitrateKbps != 0 {
                os.write_int32(4, self.bitrateKbps)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RTCVideoParam {
            RTCVideoParam::new()
        }

        fn clear(&mut self) {
            self.width = 0;
            self.height = 0;
            self.fps = 0;
            self.bitrateKbps = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RTCVideoParam {
            static instance: RTCVideoParam = RTCVideoParam {
                width: 0,
                height: 0,
                fps: 0,
                bitrateKbps: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RTCVideoParam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RTCExtraInfo.RTCVideoParam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RTCVideoParam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RTCVideoParam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.RTCExtraInfo.RTCBitrateMap)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RTCBitrateMap {
        // message fields
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCBitrateMap.xx1)
        pub xx1: i32,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCBitrateMap.xx2)
        pub xx2: i32,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCBitrateMap.xx3)
        pub xx3: i32,
        // @@protoc_insertion_point(field:TikTok.RTCExtraInfo.RTCBitrateMap.xx4)
        pub xx4: i32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.RTCExtraInfo.RTCBitrateMap.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RTCBitrateMap {
        fn default() -> &'a RTCBitrateMap {
            <RTCBitrateMap as ::protobuf::Message>::default_instance()
        }
    }

    impl RTCBitrateMap {
        pub fn new() -> RTCBitrateMap {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "xx1",
                |m: &RTCBitrateMap| { &m.xx1 },
                |m: &mut RTCBitrateMap| { &mut m.xx1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "xx2",
                |m: &RTCBitrateMap| { &m.xx2 },
                |m: &mut RTCBitrateMap| { &mut m.xx2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "xx3",
                |m: &RTCBitrateMap| { &m.xx3 },
                |m: &mut RTCBitrateMap| { &mut m.xx3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "xx4",
                |m: &RTCBitrateMap| { &m.xx4 },
                |m: &mut RTCBitrateMap| { &mut m.xx4 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RTCBitrateMap>(
                "RTCExtraInfo.RTCBitrateMap",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RTCBitrateMap {
        const NAME: &'static str = "RTCBitrateMap";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.xx1 = is.read_int32()?;
                    },
                    16 => {
                        self.xx2 = is.read_int32()?;
                    },
                    24 => {
                        self.xx3 = is.read_int32()?;
                    },
                    32 => {
                        self.xx4 = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.xx1 != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.xx1);
            }
            if self.xx2 != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.xx2);
            }
            if self.xx3 != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.xx3);
            }
            if self.xx4 != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.xx4);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.xx1 != 0 {
                os.write_int32(1, self.xx1)?;
            }
            if self.xx2 != 0 {
                os.write_int32(2, self.xx2)?;
            }
            if self.xx3 != 0 {
                os.write_int32(3, self.xx3)?;
            }
            if self.xx4 != 0 {
                os.write_int32(4, self.xx4)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RTCBitrateMap {
            RTCBitrateMap::new()
        }

        fn clear(&mut self) {
            self.xx1 = 0;
            self.xx2 = 0;
            self.xx3 = 0;
            self.xx4 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RTCBitrateMap {
            static instance: RTCBitrateMap = RTCBitrateMap {
                xx1: 0,
                xx2: 0,
                xx3: 0,
                xx4: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RTCBitrateMap {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RTCExtraInfo.RTCBitrateMap").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RTCBitrateMap {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RTCBitrateMap {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.CreateChannelContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateChannelContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.CreateChannelContent.owner)
    pub owner: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.CreateChannelContent.ownerLinkMicId)
    pub ownerLinkMicId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.CreateChannelContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateChannelContent {
    fn default() -> &'a CreateChannelContent {
        <CreateChannelContent as ::protobuf::Message>::default_instance()
    }
}

impl CreateChannelContent {
    pub fn new() -> CreateChannelContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "owner",
            |m: &CreateChannelContent| { &m.owner },
            |m: &mut CreateChannelContent| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ownerLinkMicId",
            |m: &CreateChannelContent| { &m.ownerLinkMicId },
            |m: &mut CreateChannelContent| { &mut m.ownerLinkMicId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateChannelContent>(
            "CreateChannelContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateChannelContent {
    const NAME: &'static str = "CreateChannelContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner)?;
                },
                18 => {
                    self.ownerLinkMicId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.ownerLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ownerLinkMicId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.ownerLinkMicId.is_empty() {
            os.write_string(2, &self.ownerLinkMicId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateChannelContent {
        CreateChannelContent::new()
    }

    fn clear(&mut self) {
        self.owner.clear();
        self.ownerLinkMicId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateChannelContent {
        static instance: CreateChannelContent = CreateChannelContent {
            owner: ::protobuf::MessageField::none(),
            ownerLinkMicId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateChannelContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateChannelContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateChannelContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateChannelContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.ListChangeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListChangeContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.ListChangeContent.type)
    pub type_: ::protobuf::EnumOrUnknown<super::enums::TextType>,
    // @@protoc_insertion_point(field:TikTok.ListChangeContent.list)
    pub list: ::protobuf::MessageField<AllListUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.ListChangeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListChangeContent {
    fn default() -> &'a ListChangeContent {
        <ListChangeContent as ::protobuf::Message>::default_instance()
    }
}

impl ListChangeContent {
    pub fn new() -> ListChangeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ListChangeContent| { &m.type_ },
            |m: &mut ListChangeContent| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllListUser>(
            "list",
            |m: &ListChangeContent| { &m.list },
            |m: &mut ListChangeContent| { &mut m.list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListChangeContent>(
            "ListChangeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListChangeContent {
    const NAME: &'static str = "ListChangeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.list)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListChangeContent {
        ListChangeContent::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT);
        self.list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListChangeContent {
        static instance: ListChangeContent = ListChangeContent {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            list: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListChangeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListChangeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListChangeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChangeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.MultiLiveContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiLiveContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.MultiLiveContent.inviteBizContent)
    pub inviteBizContent: ::protobuf::MessageField<multi_live_content::InviteBizContent>,
    // @@protoc_insertion_point(field:TikTok.MultiLiveContent.replyBizContent)
    pub replyBizContent: ::protobuf::MessageField<multi_live_content::ReplyBizContent>,
    // @@protoc_insertion_point(field:TikTok.MultiLiveContent.permitBizContent)
    pub permitBizContent: ::protobuf::MessageField<multi_live_content::PermitBizContent>,
    // @@protoc_insertion_point(field:TikTok.MultiLiveContent.kickOutBizContent)
    pub kickOutBizContent: ::protobuf::MessageField<multi_live_content::KickOutBizContent>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.MultiLiveContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiLiveContent {
    fn default() -> &'a MultiLiveContent {
        <MultiLiveContent as ::protobuf::Message>::default_instance()
    }
}

impl MultiLiveContent {
    pub fn new() -> MultiLiveContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, multi_live_content::InviteBizContent>(
            "inviteBizContent",
            |m: &MultiLiveContent| { &m.inviteBizContent },
            |m: &mut MultiLiveContent| { &mut m.inviteBizContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, multi_live_content::ReplyBizContent>(
            "replyBizContent",
            |m: &MultiLiveContent| { &m.replyBizContent },
            |m: &mut MultiLiveContent| { &mut m.replyBizContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, multi_live_content::PermitBizContent>(
            "permitBizContent",
            |m: &MultiLiveContent| { &m.permitBizContent },
            |m: &mut MultiLiveContent| { &mut m.permitBizContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, multi_live_content::KickOutBizContent>(
            "kickOutBizContent",
            |m: &MultiLiveContent| { &m.kickOutBizContent },
            |m: &mut MultiLiveContent| { &mut m.kickOutBizContent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiLiveContent>(
            "MultiLiveContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiLiveContent {
    const NAME: &'static str = "MultiLiveContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inviteBizContent)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.replyBizContent)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permitBizContent)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kickOutBizContent)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inviteBizContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.replyBizContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.permitBizContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.kickOutBizContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inviteBizContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.replyBizContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.permitBizContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.kickOutBizContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiLiveContent {
        MultiLiveContent::new()
    }

    fn clear(&mut self) {
        self.inviteBizContent.clear();
        self.replyBizContent.clear();
        self.permitBizContent.clear();
        self.kickOutBizContent.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiLiveContent {
        static instance: MultiLiveContent = MultiLiveContent {
            inviteBizContent: ::protobuf::MessageField::none(),
            replyBizContent: ::protobuf::MessageField::none(),
            permitBizContent: ::protobuf::MessageField::none(),
            kickOutBizContent: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiLiveContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiLiveContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiLiveContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiLiveContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MultiLiveContent`
pub mod multi_live_content {
    // @@protoc_insertion_point(message:TikTok.MultiLiveContent.InviteBizContent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InviteBizContent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.InviteBizContent.anchorSettingInfo)
        pub anchorSettingInfo: ::protobuf::MessageField<super::LinkmicUserSettingInfo>,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.InviteBizContent.inviteSource)
        pub inviteSource: i64,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.InviteBizContent.operatorUserInfo)
        pub operatorUserInfo: ::protobuf::MessageField<super::User>,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.InviteBizContent.operatorLinkAdminType)
        pub operatorLinkAdminType: i64,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.InviteBizContent.inviteeUserInfo)
        pub inviteeUserInfo: ::protobuf::MessageField<super::User>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.MultiLiveContent.InviteBizContent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InviteBizContent {
        fn default() -> &'a InviteBizContent {
            <InviteBizContent as ::protobuf::Message>::default_instance()
        }
    }

    impl InviteBizContent {
        pub fn new() -> InviteBizContent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::LinkmicUserSettingInfo>(
                "anchorSettingInfo",
                |m: &InviteBizContent| { &m.anchorSettingInfo },
                |m: &mut InviteBizContent| { &mut m.anchorSettingInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "inviteSource",
                |m: &InviteBizContent| { &m.inviteSource },
                |m: &mut InviteBizContent| { &mut m.inviteSource },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::User>(
                "operatorUserInfo",
                |m: &InviteBizContent| { &m.operatorUserInfo },
                |m: &mut InviteBizContent| { &mut m.operatorUserInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "operatorLinkAdminType",
                |m: &InviteBizContent| { &m.operatorLinkAdminType },
                |m: &mut InviteBizContent| { &mut m.operatorLinkAdminType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::User>(
                "inviteeUserInfo",
                |m: &InviteBizContent| { &m.inviteeUserInfo },
                |m: &mut InviteBizContent| { &mut m.inviteeUserInfo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InviteBizContent>(
                "MultiLiveContent.InviteBizContent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InviteBizContent {
        const NAME: &'static str = "InviteBizContent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.anchorSettingInfo)?;
                    },
                    16 => {
                        self.inviteSource = is.read_int64()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.operatorUserInfo)?;
                    },
                    32 => {
                        self.operatorLinkAdminType = is.read_int64()?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.inviteeUserInfo)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.anchorSettingInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.inviteSource != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.inviteSource);
            }
            if let Some(v) = self.operatorUserInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.operatorLinkAdminType != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.operatorLinkAdminType);
            }
            if let Some(v) = self.inviteeUserInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.anchorSettingInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.inviteSource != 0 {
                os.write_int64(2, self.inviteSource)?;
            }
            if let Some(v) = self.operatorUserInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.operatorLinkAdminType != 0 {
                os.write_int64(4, self.operatorLinkAdminType)?;
            }
            if let Some(v) = self.inviteeUserInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InviteBizContent {
            InviteBizContent::new()
        }

        fn clear(&mut self) {
            self.anchorSettingInfo.clear();
            self.inviteSource = 0;
            self.operatorUserInfo.clear();
            self.operatorLinkAdminType = 0;
            self.inviteeUserInfo.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InviteBizContent {
            static instance: InviteBizContent = InviteBizContent {
                anchorSettingInfo: ::protobuf::MessageField::none(),
                inviteSource: 0,
                operatorUserInfo: ::protobuf::MessageField::none(),
                operatorLinkAdminType: 0,
                inviteeUserInfo: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InviteBizContent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MultiLiveContent.InviteBizContent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InviteBizContent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InviteBizContent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.MultiLiveContent.ReplyBizContent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReplyBizContent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.ReplyBizContent.linkType)
        pub linkType: i32,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.ReplyBizContent.isTurnOffInvitation)
        pub isTurnOffInvitation: i32,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.ReplyBizContent.replyUserInfo)
        pub replyUserInfo: ::protobuf::MessageField<super::User>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.MultiLiveContent.ReplyBizContent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReplyBizContent {
        fn default() -> &'a ReplyBizContent {
            <ReplyBizContent as ::protobuf::Message>::default_instance()
        }
    }

    impl ReplyBizContent {
        pub fn new() -> ReplyBizContent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "linkType",
                |m: &ReplyBizContent| { &m.linkType },
                |m: &mut ReplyBizContent| { &mut m.linkType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isTurnOffInvitation",
                |m: &ReplyBizContent| { &m.isTurnOffInvitation },
                |m: &mut ReplyBizContent| { &mut m.isTurnOffInvitation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::User>(
                "replyUserInfo",
                |m: &ReplyBizContent| { &m.replyUserInfo },
                |m: &mut ReplyBizContent| { &mut m.replyUserInfo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplyBizContent>(
                "MultiLiveContent.ReplyBizContent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReplyBizContent {
        const NAME: &'static str = "ReplyBizContent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.linkType = is.read_int32()?;
                    },
                    16 => {
                        self.isTurnOffInvitation = is.read_int32()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.replyUserInfo)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.linkType != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.linkType);
            }
            if self.isTurnOffInvitation != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.isTurnOffInvitation);
            }
            if let Some(v) = self.replyUserInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.linkType != 0 {
                os.write_int32(1, self.linkType)?;
            }
            if self.isTurnOffInvitation != 0 {
                os.write_int32(2, self.isTurnOffInvitation)?;
            }
            if let Some(v) = self.replyUserInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReplyBizContent {
            ReplyBizContent::new()
        }

        fn clear(&mut self) {
            self.linkType = 0;
            self.isTurnOffInvitation = 0;
            self.replyUserInfo.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReplyBizContent {
            static instance: ReplyBizContent = ReplyBizContent {
                linkType: 0,
                isTurnOffInvitation: 0,
                replyUserInfo: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReplyBizContent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MultiLiveContent.ReplyBizContent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReplyBizContent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReplyBizContent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.MultiLiveContent.PermitBizContent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PermitBizContent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.PermitBizContent.anchorSettingInfo)
        pub anchorSettingInfo: ::protobuf::MessageField<super::LinkmicUserSettingInfo>,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.PermitBizContent.expireTimestamp)
        pub expireTimestamp: i64,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.PermitBizContent.operatorUserInfo)
        pub operatorUserInfo: ::protobuf::MessageField<super::User>,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.PermitBizContent.operatorLinkAdminType)
        pub operatorLinkAdminType: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.MultiLiveContent.PermitBizContent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PermitBizContent {
        fn default() -> &'a PermitBizContent {
            <PermitBizContent as ::protobuf::Message>::default_instance()
        }
    }

    impl PermitBizContent {
        pub fn new() -> PermitBizContent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::LinkmicUserSettingInfo>(
                "anchorSettingInfo",
                |m: &PermitBizContent| { &m.anchorSettingInfo },
                |m: &mut PermitBizContent| { &mut m.anchorSettingInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "expireTimestamp",
                |m: &PermitBizContent| { &m.expireTimestamp },
                |m: &mut PermitBizContent| { &mut m.expireTimestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::User>(
                "operatorUserInfo",
                |m: &PermitBizContent| { &m.operatorUserInfo },
                |m: &mut PermitBizContent| { &mut m.operatorUserInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "operatorLinkAdminType",
                |m: &PermitBizContent| { &m.operatorLinkAdminType },
                |m: &mut PermitBizContent| { &mut m.operatorLinkAdminType },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermitBizContent>(
                "MultiLiveContent.PermitBizContent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PermitBizContent {
        const NAME: &'static str = "PermitBizContent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.anchorSettingInfo)?;
                    },
                    16 => {
                        self.expireTimestamp = is.read_int64()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.operatorUserInfo)?;
                    },
                    32 => {
                        self.operatorLinkAdminType = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.anchorSettingInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.expireTimestamp != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.expireTimestamp);
            }
            if let Some(v) = self.operatorUserInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.operatorLinkAdminType != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.operatorLinkAdminType);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.anchorSettingInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.expireTimestamp != 0 {
                os.write_int64(2, self.expireTimestamp)?;
            }
            if let Some(v) = self.operatorUserInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.operatorLinkAdminType != 0 {
                os.write_int64(4, self.operatorLinkAdminType)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PermitBizContent {
            PermitBizContent::new()
        }

        fn clear(&mut self) {
            self.anchorSettingInfo.clear();
            self.expireTimestamp = 0;
            self.operatorUserInfo.clear();
            self.operatorLinkAdminType = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PermitBizContent {
            static instance: PermitBizContent = PermitBizContent {
                anchorSettingInfo: ::protobuf::MessageField::none(),
                expireTimestamp: 0,
                operatorUserInfo: ::protobuf::MessageField::none(),
                operatorLinkAdminType: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PermitBizContent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MultiLiveContent.PermitBizContent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PermitBizContent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PermitBizContent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.MultiLiveContent.KickOutBizContent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KickOutBizContent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.KickOutBizContent.operatorUserInfo)
        pub operatorUserInfo: ::protobuf::MessageField<super::User>,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.KickOutBizContent.operatorLinkAdminType)
        pub operatorLinkAdminType: i64,
        // @@protoc_insertion_point(field:TikTok.MultiLiveContent.KickOutBizContent.kickPlayerUserInfo)
        pub kickPlayerUserInfo: ::protobuf::MessageField<super::User>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.MultiLiveContent.KickOutBizContent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KickOutBizContent {
        fn default() -> &'a KickOutBizContent {
            <KickOutBizContent as ::protobuf::Message>::default_instance()
        }
    }

    impl KickOutBizContent {
        pub fn new() -> KickOutBizContent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::User>(
                "operatorUserInfo",
                |m: &KickOutBizContent| { &m.operatorUserInfo },
                |m: &mut KickOutBizContent| { &mut m.operatorUserInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "operatorLinkAdminType",
                |m: &KickOutBizContent| { &m.operatorLinkAdminType },
                |m: &mut KickOutBizContent| { &mut m.operatorLinkAdminType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::User>(
                "kickPlayerUserInfo",
                |m: &KickOutBizContent| { &m.kickPlayerUserInfo },
                |m: &mut KickOutBizContent| { &mut m.kickPlayerUserInfo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KickOutBizContent>(
                "MultiLiveContent.KickOutBizContent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KickOutBizContent {
        const NAME: &'static str = "KickOutBizContent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.operatorUserInfo)?;
                    },
                    16 => {
                        self.operatorLinkAdminType = is.read_int64()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.kickPlayerUserInfo)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.operatorUserInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.operatorLinkAdminType != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.operatorLinkAdminType);
            }
            if let Some(v) = self.kickPlayerUserInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.operatorUserInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.operatorLinkAdminType != 0 {
                os.write_int64(2, self.operatorLinkAdminType)?;
            }
            if let Some(v) = self.kickPlayerUserInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KickOutBizContent {
            KickOutBizContent::new()
        }

        fn clear(&mut self) {
            self.operatorUserInfo.clear();
            self.operatorLinkAdminType = 0;
            self.kickPlayerUserInfo.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KickOutBizContent {
            static instance: KickOutBizContent = KickOutBizContent {
                operatorUserInfo: ::protobuf::MessageField::none(),
                operatorLinkAdminType: 0,
                kickPlayerUserInfo: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KickOutBizContent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MultiLiveContent.KickOutBizContent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KickOutBizContent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KickOutBizContent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.InviteContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InviteContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.InviteContent.invitor)
    pub invitor: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.InviteContent.inviteeRtcExtInfo)
    pub inviteeRtcExtInfo: ::protobuf::MessageField<RTCExtraInfo>,
    // @@protoc_insertion_point(field:TikTok.InviteContent.invitorLinkMicId)
    pub invitorLinkMicId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.InviteContent.inviteeLinkMicId)
    pub inviteeLinkMicId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.InviteContent.isOwner)
    pub isOwner: bool,
    // @@protoc_insertion_point(field:TikTok.InviteContent.pos)
    pub pos: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:TikTok.InviteContent.dsl)
    pub dsl: ::protobuf::MessageField<DSLConfig>,
    // @@protoc_insertion_point(field:TikTok.InviteContent.invitee)
    pub invitee: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.InviteContent.operator)
    pub operator: ::protobuf::MessageField<User>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.InviteContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InviteContent {
    fn default() -> &'a InviteContent {
        <InviteContent as ::protobuf::Message>::default_instance()
    }
}

impl InviteContent {
    pub fn new() -> InviteContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "invitor",
            |m: &InviteContent| { &m.invitor },
            |m: &mut InviteContent| { &mut m.invitor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RTCExtraInfo>(
            "inviteeRtcExtInfo",
            |m: &InviteContent| { &m.inviteeRtcExtInfo },
            |m: &mut InviteContent| { &mut m.inviteeRtcExtInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invitorLinkMicId",
            |m: &InviteContent| { &m.invitorLinkMicId },
            |m: &mut InviteContent| { &mut m.invitorLinkMicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inviteeLinkMicId",
            |m: &InviteContent| { &m.inviteeLinkMicId },
            |m: &mut InviteContent| { &mut m.inviteeLinkMicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isOwner",
            |m: &InviteContent| { &m.isOwner },
            |m: &mut InviteContent| { &mut m.isOwner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "pos",
            |m: &InviteContent| { &m.pos },
            |m: &mut InviteContent| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DSLConfig>(
            "dsl",
            |m: &InviteContent| { &m.dsl },
            |m: &mut InviteContent| { &mut m.dsl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "invitee",
            |m: &InviteContent| { &m.invitee },
            |m: &mut InviteContent| { &mut m.invitee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "operator",
            |m: &InviteContent| { &m.operator },
            |m: &mut InviteContent| { &mut m.operator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InviteContent>(
            "InviteContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InviteContent {
    const NAME: &'static str = "InviteContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.invitor)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inviteeRtcExtInfo)?;
                },
                26 => {
                    self.invitorLinkMicId = is.read_string()?;
                },
                34 => {
                    self.inviteeLinkMicId = is.read_string()?;
                },
                40 => {
                    self.isOwner = is.read_bool()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dsl)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.invitee)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operator)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invitor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inviteeRtcExtInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.invitorLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.invitorLinkMicId);
        }
        if !self.inviteeLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.inviteeLinkMicId);
        }
        if self.isOwner != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dsl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.invitee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.operator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invitor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.inviteeRtcExtInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.invitorLinkMicId.is_empty() {
            os.write_string(3, &self.invitorLinkMicId)?;
        }
        if !self.inviteeLinkMicId.is_empty() {
            os.write_string(4, &self.inviteeLinkMicId)?;
        }
        if self.isOwner != false {
            os.write_bool(5, self.isOwner)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.dsl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.invitee.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.operator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InviteContent {
        InviteContent::new()
    }

    fn clear(&mut self) {
        self.invitor.clear();
        self.inviteeRtcExtInfo.clear();
        self.invitorLinkMicId.clear();
        self.inviteeLinkMicId.clear();
        self.isOwner = false;
        self.pos.clear();
        self.dsl.clear();
        self.invitee.clear();
        self.operator.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InviteContent {
        static instance: InviteContent = InviteContent {
            invitor: ::protobuf::MessageField::none(),
            inviteeRtcExtInfo: ::protobuf::MessageField::none(),
            invitorLinkMicId: ::std::string::String::new(),
            inviteeLinkMicId: ::std::string::String::new(),
            isOwner: false,
            pos: ::protobuf::MessageField::none(),
            dsl: ::protobuf::MessageField::none(),
            invitee: ::protobuf::MessageField::none(),
            operator: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InviteContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InviteContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InviteContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InviteContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.ApplyContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplyContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.ApplyContent.applier)
    pub applier: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.ApplyContent.applierLinkMicId)
    pub applierLinkMicId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.ApplyContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplyContent {
    fn default() -> &'a ApplyContent {
        <ApplyContent as ::protobuf::Message>::default_instance()
    }
}

impl ApplyContent {
    pub fn new() -> ApplyContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "applier",
            |m: &ApplyContent| { &m.applier },
            |m: &mut ApplyContent| { &mut m.applier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "applierLinkMicId",
            |m: &ApplyContent| { &m.applierLinkMicId },
            |m: &mut ApplyContent| { &mut m.applierLinkMicId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApplyContent>(
            "ApplyContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApplyContent {
    const NAME: &'static str = "ApplyContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.applier)?;
                },
                18 => {
                    self.applierLinkMicId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.applier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.applierLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.applierLinkMicId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.applier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.applierLinkMicId.is_empty() {
            os.write_string(2, &self.applierLinkMicId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplyContent {
        ApplyContent::new()
    }

    fn clear(&mut self) {
        self.applier.clear();
        self.applierLinkMicId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplyContent {
        static instance: ApplyContent = ApplyContent {
            applier: ::protobuf::MessageField::none(),
            applierLinkMicId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApplyContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApplyContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApplyContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.PermitApplyContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermitApplyContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.permiter)
    pub permiter: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.permiterLinkMicId)
    pub permiterLinkMicId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.applierPos)
    pub applierPos: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.replyStatus)
    pub replyStatus: ::protobuf::EnumOrUnknown<super::enums::ReplyStatus>,
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.dsl)
    pub dsl: ::protobuf::MessageField<DSLConfig>,
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.applier)
    pub applier: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.operator)
    pub operator: ::protobuf::MessageField<User>,
    // @@protoc_insertion_point(field:TikTok.PermitApplyContent.applierLinkMicId)
    pub applierLinkMicId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.PermitApplyContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermitApplyContent {
    fn default() -> &'a PermitApplyContent {
        <PermitApplyContent as ::protobuf::Message>::default_instance()
    }
}

impl PermitApplyContent {
    pub fn new() -> PermitApplyContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "permiter",
            |m: &PermitApplyContent| { &m.permiter },
            |m: &mut PermitApplyContent| { &mut m.permiter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permiterLinkMicId",
            |m: &PermitApplyContent| { &m.permiterLinkMicId },
            |m: &mut PermitApplyContent| { &mut m.permiterLinkMicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "applierPos",
            |m: &PermitApplyContent| { &m.applierPos },
            |m: &mut PermitApplyContent| { &mut m.applierPos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replyStatus",
            |m: &PermitApplyContent| { &m.replyStatus },
            |m: &mut PermitApplyContent| { &mut m.replyStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DSLConfig>(
            "dsl",
            |m: &PermitApplyContent| { &m.dsl },
            |m: &mut PermitApplyContent| { &mut m.dsl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "applier",
            |m: &PermitApplyContent| { &m.applier },
            |m: &mut PermitApplyContent| { &mut m.applier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "operator",
            |m: &PermitApplyContent| { &m.operator },
            |m: &mut PermitApplyContent| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "applierLinkMicId",
            |m: &PermitApplyContent| { &m.applierLinkMicId },
            |m: &mut PermitApplyContent| { &mut m.applierLinkMicId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermitApplyContent>(
            "PermitApplyContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermitApplyContent {
    const NAME: &'static str = "PermitApplyContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permiter)?;
                },
                18 => {
                    self.permiterLinkMicId = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.applierPos)?;
                },
                32 => {
                    self.replyStatus = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dsl)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.applier)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operator)?;
                },
                66 => {
                    self.applierLinkMicId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permiter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.permiterLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.permiterLinkMicId);
        }
        if let Some(v) = self.applierPos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.replyStatus != ::protobuf::EnumOrUnknown::new(super::enums::ReplyStatus::REPLY_STATUS_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.replyStatus.value());
        }
        if let Some(v) = self.dsl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.applier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.operator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.applierLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.applierLinkMicId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permiter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.permiterLinkMicId.is_empty() {
            os.write_string(2, &self.permiterLinkMicId)?;
        }
        if let Some(v) = self.applierPos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.replyStatus != ::protobuf::EnumOrUnknown::new(super::enums::ReplyStatus::REPLY_STATUS_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.replyStatus))?;
        }
        if let Some(v) = self.dsl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.applier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.operator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if !self.applierLinkMicId.is_empty() {
            os.write_string(8, &self.applierLinkMicId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermitApplyContent {
        PermitApplyContent::new()
    }

    fn clear(&mut self) {
        self.permiter.clear();
        self.permiterLinkMicId.clear();
        self.applierPos.clear();
        self.replyStatus = ::protobuf::EnumOrUnknown::new(super::enums::ReplyStatus::REPLY_STATUS_UNKNOWN);
        self.dsl.clear();
        self.applier.clear();
        self.operator.clear();
        self.applierLinkMicId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermitApplyContent {
        static instance: PermitApplyContent = PermitApplyContent {
            permiter: ::protobuf::MessageField::none(),
            permiterLinkMicId: ::std::string::String::new(),
            applierPos: ::protobuf::MessageField::none(),
            replyStatus: ::protobuf::EnumOrUnknown::from_i32(0),
            dsl: ::protobuf::MessageField::none(),
            applier: ::protobuf::MessageField::none(),
            operator: ::protobuf::MessageField::none(),
            applierLinkMicId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermitApplyContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermitApplyContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermitApplyContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermitApplyContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.ReplyInviteContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplyInviteContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.ReplyInviteContent.invitee)
    pub invitee: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.ReplyInviteContent.replyStatus)
    pub replyStatus: ::protobuf::EnumOrUnknown<super::enums::ReplyStatus>,
    // @@protoc_insertion_point(field:TikTok.ReplyInviteContent.inviteeLinkMicId)
    pub inviteeLinkMicId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.ReplyInviteContent.inviteePos)
    pub inviteePos: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:TikTok.ReplyInviteContent.inviteOperatorUser)
    pub inviteOperatorUser: ::protobuf::MessageField<Player>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.ReplyInviteContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplyInviteContent {
    fn default() -> &'a ReplyInviteContent {
        <ReplyInviteContent as ::protobuf::Message>::default_instance()
    }
}

impl ReplyInviteContent {
    pub fn new() -> ReplyInviteContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "invitee",
            |m: &ReplyInviteContent| { &m.invitee },
            |m: &mut ReplyInviteContent| { &mut m.invitee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replyStatus",
            |m: &ReplyInviteContent| { &m.replyStatus },
            |m: &mut ReplyInviteContent| { &mut m.replyStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inviteeLinkMicId",
            |m: &ReplyInviteContent| { &m.inviteeLinkMicId },
            |m: &mut ReplyInviteContent| { &mut m.inviteeLinkMicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "inviteePos",
            |m: &ReplyInviteContent| { &m.inviteePos },
            |m: &mut ReplyInviteContent| { &mut m.inviteePos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "inviteOperatorUser",
            |m: &ReplyInviteContent| { &m.inviteOperatorUser },
            |m: &mut ReplyInviteContent| { &mut m.inviteOperatorUser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplyInviteContent>(
            "ReplyInviteContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplyInviteContent {
    const NAME: &'static str = "ReplyInviteContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.invitee)?;
                },
                16 => {
                    self.replyStatus = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.inviteeLinkMicId = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inviteePos)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inviteOperatorUser)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invitee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.replyStatus != ::protobuf::EnumOrUnknown::new(super::enums::ReplyStatus::REPLY_STATUS_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.replyStatus.value());
        }
        if !self.inviteeLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.inviteeLinkMicId);
        }
        if let Some(v) = self.inviteePos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inviteOperatorUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invitee.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.replyStatus != ::protobuf::EnumOrUnknown::new(super::enums::ReplyStatus::REPLY_STATUS_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.replyStatus))?;
        }
        if !self.inviteeLinkMicId.is_empty() {
            os.write_string(3, &self.inviteeLinkMicId)?;
        }
        if let Some(v) = self.inviteePos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.inviteOperatorUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplyInviteContent {
        ReplyInviteContent::new()
    }

    fn clear(&mut self) {
        self.invitee.clear();
        self.replyStatus = ::protobuf::EnumOrUnknown::new(super::enums::ReplyStatus::REPLY_STATUS_UNKNOWN);
        self.inviteeLinkMicId.clear();
        self.inviteePos.clear();
        self.inviteOperatorUser.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplyInviteContent {
        static instance: ReplyInviteContent = ReplyInviteContent {
            invitee: ::protobuf::MessageField::none(),
            replyStatus: ::protobuf::EnumOrUnknown::from_i32(0),
            inviteeLinkMicId: ::std::string::String::new(),
            inviteePos: ::protobuf::MessageField::none(),
            inviteOperatorUser: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplyInviteContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplyInviteContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplyInviteContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplyInviteContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.KickOutContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KickOutContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.KickOutContent.offliner)
    pub offliner: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.KickOutContent.kickoutReason)
    pub kickoutReason: ::protobuf::EnumOrUnknown<super::enums::KickoutReason>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.KickOutContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KickOutContent {
    fn default() -> &'a KickOutContent {
        <KickOutContent as ::protobuf::Message>::default_instance()
    }
}

impl KickOutContent {
    pub fn new() -> KickOutContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "offliner",
            |m: &KickOutContent| { &m.offliner },
            |m: &mut KickOutContent| { &mut m.offliner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kickoutReason",
            |m: &KickOutContent| { &m.kickoutReason },
            |m: &mut KickOutContent| { &mut m.kickoutReason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KickOutContent>(
            "KickOutContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KickOutContent {
    const NAME: &'static str = "KickOutContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.offliner)?;
                },
                16 => {
                    self.kickoutReason = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offliner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.kickoutReason != ::protobuf::EnumOrUnknown::new(super::enums::KickoutReason::KICKOUT_REASON_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.kickoutReason.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.offliner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.kickoutReason != ::protobuf::EnumOrUnknown::new(super::enums::KickoutReason::KICKOUT_REASON_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.kickoutReason))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KickOutContent {
        KickOutContent::new()
    }

    fn clear(&mut self) {
        self.offliner.clear();
        self.kickoutReason = ::protobuf::EnumOrUnknown::new(super::enums::KickoutReason::KICKOUT_REASON_UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KickOutContent {
        static instance: KickOutContent = KickOutContent {
            offliner: ::protobuf::MessageField::none(),
            kickoutReason: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KickOutContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KickOutContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KickOutContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KickOutContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.CancelApplyContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelApplyContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.CancelApplyContent.applier)
    pub applier: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.CancelApplyContent.applierLinkMicId)
    pub applierLinkMicId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.CancelApplyContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelApplyContent {
    fn default() -> &'a CancelApplyContent {
        <CancelApplyContent as ::protobuf::Message>::default_instance()
    }
}

impl CancelApplyContent {
    pub fn new() -> CancelApplyContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "applier",
            |m: &CancelApplyContent| { &m.applier },
            |m: &mut CancelApplyContent| { &mut m.applier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "applierLinkMicId",
            |m: &CancelApplyContent| { &m.applierLinkMicId },
            |m: &mut CancelApplyContent| { &mut m.applierLinkMicId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelApplyContent>(
            "CancelApplyContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelApplyContent {
    const NAME: &'static str = "CancelApplyContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.applier)?;
                },
                18 => {
                    self.applierLinkMicId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.applier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.applierLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.applierLinkMicId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.applier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.applierLinkMicId.is_empty() {
            os.write_string(2, &self.applierLinkMicId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelApplyContent {
        CancelApplyContent::new()
    }

    fn clear(&mut self) {
        self.applier.clear();
        self.applierLinkMicId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelApplyContent {
        static instance: CancelApplyContent = CancelApplyContent {
            applier: ::protobuf::MessageField::none(),
            applierLinkMicId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelApplyContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelApplyContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelApplyContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelApplyContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.CancelInviteContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelInviteContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.CancelInviteContent.invitor)
    pub invitor: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.CancelInviteContent.invitorLinkMicId)
    pub invitorLinkMicId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.CancelInviteContent.inviteeLinkMicId)
    pub inviteeLinkMicId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.CancelInviteContent.inviteSeqId)
    pub inviteSeqId: i64,
    // @@protoc_insertion_point(field:TikTok.CancelInviteContent.invitee)
    pub invitee: ::protobuf::MessageField<Player>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.CancelInviteContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelInviteContent {
    fn default() -> &'a CancelInviteContent {
        <CancelInviteContent as ::protobuf::Message>::default_instance()
    }
}

impl CancelInviteContent {
    pub fn new() -> CancelInviteContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "invitor",
            |m: &CancelInviteContent| { &m.invitor },
            |m: &mut CancelInviteContent| { &mut m.invitor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invitorLinkMicId",
            |m: &CancelInviteContent| { &m.invitorLinkMicId },
            |m: &mut CancelInviteContent| { &mut m.invitorLinkMicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inviteeLinkMicId",
            |m: &CancelInviteContent| { &m.inviteeLinkMicId },
            |m: &mut CancelInviteContent| { &mut m.inviteeLinkMicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inviteSeqId",
            |m: &CancelInviteContent| { &m.inviteSeqId },
            |m: &mut CancelInviteContent| { &mut m.inviteSeqId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "invitee",
            |m: &CancelInviteContent| { &m.invitee },
            |m: &mut CancelInviteContent| { &mut m.invitee },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelInviteContent>(
            "CancelInviteContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelInviteContent {
    const NAME: &'static str = "CancelInviteContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.invitor)?;
                },
                18 => {
                    self.invitorLinkMicId = is.read_string()?;
                },
                26 => {
                    self.inviteeLinkMicId = is.read_string()?;
                },
                32 => {
                    self.inviteSeqId = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.invitee)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invitor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.invitorLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.invitorLinkMicId);
        }
        if !self.inviteeLinkMicId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.inviteeLinkMicId);
        }
        if self.inviteSeqId != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.inviteSeqId);
        }
        if let Some(v) = self.invitee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invitor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.invitorLinkMicId.is_empty() {
            os.write_string(2, &self.invitorLinkMicId)?;
        }
        if !self.inviteeLinkMicId.is_empty() {
            os.write_string(3, &self.inviteeLinkMicId)?;
        }
        if self.inviteSeqId != 0 {
            os.write_int64(4, self.inviteSeqId)?;
        }
        if let Some(v) = self.invitee.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelInviteContent {
        CancelInviteContent::new()
    }

    fn clear(&mut self) {
        self.invitor.clear();
        self.invitorLinkMicId.clear();
        self.inviteeLinkMicId.clear();
        self.inviteSeqId = 0;
        self.invitee.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelInviteContent {
        static instance: CancelInviteContent = CancelInviteContent {
            invitor: ::protobuf::MessageField::none(),
            invitorLinkMicId: ::std::string::String::new(),
            inviteeLinkMicId: ::std::string::String::new(),
            inviteSeqId: 0,
            invitee: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelInviteContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelInviteContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelInviteContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelInviteContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LeaveContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LeaveContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LeaveContent.leaver)
    pub leaver: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.LeaveContent.leaveReason)
    pub leaveReason: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LeaveContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LeaveContent {
    fn default() -> &'a LeaveContent {
        <LeaveContent as ::protobuf::Message>::default_instance()
    }
}

impl LeaveContent {
    pub fn new() -> LeaveContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "leaver",
            |m: &LeaveContent| { &m.leaver },
            |m: &mut LeaveContent| { &mut m.leaver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "leaveReason",
            |m: &LeaveContent| { &m.leaveReason },
            |m: &mut LeaveContent| { &mut m.leaveReason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LeaveContent>(
            "LeaveContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LeaveContent {
    const NAME: &'static str = "LeaveContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leaver)?;
                },
                16 => {
                    self.leaveReason = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.leaver.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.leaveReason != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.leaveReason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.leaver.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.leaveReason != 0 {
            os.write_int64(2, self.leaveReason)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LeaveContent {
        LeaveContent::new()
    }

    fn clear(&mut self) {
        self.leaver.clear();
        self.leaveReason = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LeaveContent {
        static instance: LeaveContent = LeaveContent {
            leaver: ::protobuf::MessageField::none(),
            leaveReason: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LeaveContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LeaveContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LeaveContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaveContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.FinishChannelContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FinishChannelContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.FinishChannelContent.owner)
    pub owner: ::protobuf::MessageField<Player>,
    // @@protoc_insertion_point(field:TikTok.FinishChannelContent.finishReason)
    pub finishReason: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.FinishChannelContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FinishChannelContent {
    fn default() -> &'a FinishChannelContent {
        <FinishChannelContent as ::protobuf::Message>::default_instance()
    }
}

impl FinishChannelContent {
    pub fn new() -> FinishChannelContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Player>(
            "owner",
            |m: &FinishChannelContent| { &m.owner },
            |m: &mut FinishChannelContent| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "finishReason",
            |m: &FinishChannelContent| { &m.finishReason },
            |m: &mut FinishChannelContent| { &mut m.finishReason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FinishChannelContent>(
            "FinishChannelContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FinishChannelContent {
    const NAME: &'static str = "FinishChannelContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner)?;
                },
                16 => {
                    self.finishReason = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.finishReason != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.finishReason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.finishReason != 0 {
            os.write_int64(2, self.finishReason)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FinishChannelContent {
        FinishChannelContent::new()
    }

    fn clear(&mut self) {
        self.owner.clear();
        self.finishReason = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FinishChannelContent {
        static instance: FinishChannelContent = FinishChannelContent {
            owner: ::protobuf::MessageField::none(),
            finishReason: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FinishChannelContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FinishChannelContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FinishChannelContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinishChannelContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.JoinDirectContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JoinDirectContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.JoinDirectContent.joiner)
    pub joiner: ::protobuf::MessageField<LinkLayerListUser>,
    // @@protoc_insertion_point(field:TikTok.JoinDirectContent.allUsers)
    pub allUsers: ::protobuf::MessageField<AllListUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.JoinDirectContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JoinDirectContent {
    fn default() -> &'a JoinDirectContent {
        <JoinDirectContent as ::protobuf::Message>::default_instance()
    }
}

impl JoinDirectContent {
    pub fn new() -> JoinDirectContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkLayerListUser>(
            "joiner",
            |m: &JoinDirectContent| { &m.joiner },
            |m: &mut JoinDirectContent| { &mut m.joiner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllListUser>(
            "allUsers",
            |m: &JoinDirectContent| { &m.allUsers },
            |m: &mut JoinDirectContent| { &mut m.allUsers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JoinDirectContent>(
            "JoinDirectContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JoinDirectContent {
    const NAME: &'static str = "JoinDirectContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.joiner)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allUsers)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.joiner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allUsers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.joiner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.allUsers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JoinDirectContent {
        JoinDirectContent::new()
    }

    fn clear(&mut self) {
        self.joiner.clear();
        self.allUsers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JoinDirectContent {
        static instance: JoinDirectContent = JoinDirectContent {
            joiner: ::protobuf::MessageField::none(),
            allUsers: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JoinDirectContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JoinDirectContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JoinDirectContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JoinDirectContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.LeaveJoinGroupContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LeaveJoinGroupContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.LeaveJoinGroupContent.operator)
    pub operator: ::protobuf::MessageField<GroupPlayer>,
    // @@protoc_insertion_point(field:TikTok.LeaveJoinGroupContent.groupChannelId)
    pub groupChannelId: i64,
    // @@protoc_insertion_point(field:TikTok.LeaveJoinGroupContent.leaveSource)
    pub leaveSource: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.LeaveJoinGroupContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LeaveJoinGroupContent {
    fn default() -> &'a LeaveJoinGroupContent {
        <LeaveJoinGroupContent as ::protobuf::Message>::default_instance()
    }
}

impl LeaveJoinGroupContent {
    pub fn new() -> LeaveJoinGroupContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupPlayer>(
            "operator",
            |m: &LeaveJoinGroupContent| { &m.operator },
            |m: &mut LeaveJoinGroupContent| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groupChannelId",
            |m: &LeaveJoinGroupContent| { &m.groupChannelId },
            |m: &mut LeaveJoinGroupContent| { &mut m.groupChannelId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "leaveSource",
            |m: &LeaveJoinGroupContent| { &m.leaveSource },
            |m: &mut LeaveJoinGroupContent| { &mut m.leaveSource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LeaveJoinGroupContent>(
            "LeaveJoinGroupContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LeaveJoinGroupContent {
    const NAME: &'static str = "LeaveJoinGroupContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operator)?;
                },
                16 => {
                    self.groupChannelId = is.read_int64()?;
                },
                26 => {
                    self.leaveSource = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.groupChannelId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.groupChannelId);
        }
        if !self.leaveSource.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.leaveSource);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.groupChannelId != 0 {
            os.write_int64(2, self.groupChannelId)?;
        }
        if !self.leaveSource.is_empty() {
            os.write_string(3, &self.leaveSource)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LeaveJoinGroupContent {
        LeaveJoinGroupContent::new()
    }

    fn clear(&mut self) {
        self.operator.clear();
        self.groupChannelId = 0;
        self.leaveSource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LeaveJoinGroupContent {
        static instance: LeaveJoinGroupContent = LeaveJoinGroupContent {
            operator: ::protobuf::MessageField::none(),
            groupChannelId: 0,
            leaveSource: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LeaveJoinGroupContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LeaveJoinGroupContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LeaveJoinGroupContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaveJoinGroupContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.PermitJoinGroupContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermitJoinGroupContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.PermitJoinGroupContent.approver)
    pub approver: ::protobuf::MessageField<GroupPlayer>,
    // @@protoc_insertion_point(field:TikTok.PermitJoinGroupContent.agreeStatus)
    pub agreeStatus: ::protobuf::EnumOrUnknown<super::enums::AgreeStatus>,
    // @@protoc_insertion_point(field:TikTok.PermitJoinGroupContent.type)
    pub type_: ::protobuf::EnumOrUnknown<super::enums::TextType>,
    // @@protoc_insertion_point(field:TikTok.PermitJoinGroupContent.groupExtInfoList)
    pub groupExtInfoList: ::std::vec::Vec<RTCExtraInfo>,
    // @@protoc_insertion_point(field:TikTok.PermitJoinGroupContent.groupUser)
    pub groupUser: ::protobuf::MessageField<GroupChannelAllUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.PermitJoinGroupContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermitJoinGroupContent {
    fn default() -> &'a PermitJoinGroupContent {
        <PermitJoinGroupContent as ::protobuf::Message>::default_instance()
    }
}

impl PermitJoinGroupContent {
    pub fn new() -> PermitJoinGroupContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupPlayer>(
            "approver",
            |m: &PermitJoinGroupContent| { &m.approver },
            |m: &mut PermitJoinGroupContent| { &mut m.approver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "agreeStatus",
            |m: &PermitJoinGroupContent| { &m.agreeStatus },
            |m: &mut PermitJoinGroupContent| { &mut m.agreeStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &PermitJoinGroupContent| { &m.type_ },
            |m: &mut PermitJoinGroupContent| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groupExtInfoList",
            |m: &PermitJoinGroupContent| { &m.groupExtInfoList },
            |m: &mut PermitJoinGroupContent| { &mut m.groupExtInfoList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupChannelAllUser>(
            "groupUser",
            |m: &PermitJoinGroupContent| { &m.groupUser },
            |m: &mut PermitJoinGroupContent| { &mut m.groupUser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermitJoinGroupContent>(
            "PermitJoinGroupContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermitJoinGroupContent {
    const NAME: &'static str = "PermitJoinGroupContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.approver)?;
                },
                16 => {
                    self.agreeStatus = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.groupExtInfoList.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.groupUser)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.approver.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.agreeStatus != ::protobuf::EnumOrUnknown::new(super::enums::AgreeStatus::AGREE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.agreeStatus.value());
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        for value in &self.groupExtInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.groupUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.approver.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.agreeStatus != ::protobuf::EnumOrUnknown::new(super::enums::AgreeStatus::AGREE_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.agreeStatus))?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for v in &self.groupExtInfoList {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.groupUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermitJoinGroupContent {
        PermitJoinGroupContent::new()
    }

    fn clear(&mut self) {
        self.approver.clear();
        self.agreeStatus = ::protobuf::EnumOrUnknown::new(super::enums::AgreeStatus::AGREE_UNKNOWN);
        self.type_ = ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT);
        self.groupExtInfoList.clear();
        self.groupUser.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermitJoinGroupContent {
        static instance: PermitJoinGroupContent = PermitJoinGroupContent {
            approver: ::protobuf::MessageField::none(),
            agreeStatus: ::protobuf::EnumOrUnknown::from_i32(0),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            groupExtInfoList: ::std::vec::Vec::new(),
            groupUser: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermitJoinGroupContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermitJoinGroupContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermitJoinGroupContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermitJoinGroupContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.CancelJoinGroupContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelJoinGroupContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.CancelJoinGroupContent.leaverList)
    pub leaverList: ::std::vec::Vec<GroupPlayer>,
    // @@protoc_insertion_point(field:TikTok.CancelJoinGroupContent.operator)
    pub operator: ::protobuf::MessageField<GroupPlayer>,
    // @@protoc_insertion_point(field:TikTok.CancelJoinGroupContent.type)
    pub type_: ::protobuf::EnumOrUnknown<super::enums::TextType>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.CancelJoinGroupContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelJoinGroupContent {
    fn default() -> &'a CancelJoinGroupContent {
        <CancelJoinGroupContent as ::protobuf::Message>::default_instance()
    }
}

impl CancelJoinGroupContent {
    pub fn new() -> CancelJoinGroupContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "leaverList",
            |m: &CancelJoinGroupContent| { &m.leaverList },
            |m: &mut CancelJoinGroupContent| { &mut m.leaverList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupPlayer>(
            "operator",
            |m: &CancelJoinGroupContent| { &m.operator },
            |m: &mut CancelJoinGroupContent| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CancelJoinGroupContent| { &m.type_ },
            |m: &mut CancelJoinGroupContent| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelJoinGroupContent>(
            "CancelJoinGroupContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelJoinGroupContent {
    const NAME: &'static str = "CancelJoinGroupContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.leaverList.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operator)?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.leaverList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.operator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.leaverList {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.operator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelJoinGroupContent {
        CancelJoinGroupContent::new()
    }

    fn clear(&mut self) {
        self.leaverList.clear();
        self.operator.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelJoinGroupContent {
        static instance: CancelJoinGroupContent = CancelJoinGroupContent {
            leaverList: ::std::vec::Vec::new(),
            operator: ::protobuf::MessageField::none(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelJoinGroupContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelJoinGroupContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelJoinGroupContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelJoinGroupContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.P2PGroupChangeContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct P2PGroupChangeContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.P2PGroupChangeContent.groupExtInfoList)
    pub groupExtInfoList: ::std::vec::Vec<RTCExtraInfo>,
    // @@protoc_insertion_point(field:TikTok.P2PGroupChangeContent.groupUser)
    pub groupUser: ::protobuf::MessageField<GroupChannelAllUser>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.P2PGroupChangeContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a P2PGroupChangeContent {
    fn default() -> &'a P2PGroupChangeContent {
        <P2PGroupChangeContent as ::protobuf::Message>::default_instance()
    }
}

impl P2PGroupChangeContent {
    pub fn new() -> P2PGroupChangeContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groupExtInfoList",
            |m: &P2PGroupChangeContent| { &m.groupExtInfoList },
            |m: &mut P2PGroupChangeContent| { &mut m.groupExtInfoList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupChannelAllUser>(
            "groupUser",
            |m: &P2PGroupChangeContent| { &m.groupUser },
            |m: &mut P2PGroupChangeContent| { &mut m.groupUser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<P2PGroupChangeContent>(
            "P2PGroupChangeContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for P2PGroupChangeContent {
    const NAME: &'static str = "P2PGroupChangeContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupExtInfoList.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.groupUser)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.groupExtInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.groupUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.groupExtInfoList {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.groupUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> P2PGroupChangeContent {
        P2PGroupChangeContent::new()
    }

    fn clear(&mut self) {
        self.groupExtInfoList.clear();
        self.groupUser.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static P2PGroupChangeContent {
        static instance: P2PGroupChangeContent = P2PGroupChangeContent {
            groupExtInfoList: ::std::vec::Vec::new(),
            groupUser: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for P2PGroupChangeContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("P2PGroupChangeContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for P2PGroupChangeContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P2PGroupChangeContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.BusinessContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BusinessContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.BusinessContent.overLength)
    pub overLength: i64,
    // @@protoc_insertion_point(field:TikTok.BusinessContent.multiLiveContent)
    pub multiLiveContent: ::protobuf::MessageField<MultiLiveContent>,
    // @@protoc_insertion_point(field:TikTok.BusinessContent.cohostContent)
    pub cohostContent: ::protobuf::MessageField<business_content::CohostContent>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.BusinessContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BusinessContent {
    fn default() -> &'a BusinessContent {
        <BusinessContent as ::protobuf::Message>::default_instance()
    }
}

impl BusinessContent {
    pub fn new() -> BusinessContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "overLength",
            |m: &BusinessContent| { &m.overLength },
            |m: &mut BusinessContent| { &mut m.overLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MultiLiveContent>(
            "multiLiveContent",
            |m: &BusinessContent| { &m.multiLiveContent },
            |m: &mut BusinessContent| { &mut m.multiLiveContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, business_content::CohostContent>(
            "cohostContent",
            |m: &BusinessContent| { &m.cohostContent },
            |m: &mut BusinessContent| { &mut m.cohostContent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BusinessContent>(
            "BusinessContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BusinessContent {
    const NAME: &'static str = "BusinessContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overLength = is.read_int64()?;
                },
                802 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.multiLiveContent)?;
                },
                1602 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cohostContent)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.overLength != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.overLength);
        }
        if let Some(v) = self.multiLiveContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cohostContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.overLength != 0 {
            os.write_int64(1, self.overLength)?;
        }
        if let Some(v) = self.multiLiveContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
        }
        if let Some(v) = self.cohostContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(200, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BusinessContent {
        BusinessContent::new()
    }

    fn clear(&mut self) {
        self.overLength = 0;
        self.multiLiveContent.clear();
        self.cohostContent.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BusinessContent {
        static instance: BusinessContent = BusinessContent {
            overLength: 0,
            multiLiveContent: ::protobuf::MessageField::none(),
            cohostContent: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BusinessContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BusinessContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BusinessContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BusinessContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BusinessContent`
pub mod business_content {
    // @@protoc_insertion_point(message:TikTok.BusinessContent.CohostContent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CohostContent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.CohostContent.joinGroupBizContent)
        pub joinGroupBizContent: ::protobuf::MessageField<JoinGroupBizContent>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.CohostContent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CohostContent {
        fn default() -> &'a CohostContent {
            <CohostContent as ::protobuf::Message>::default_instance()
        }
    }

    impl CohostContent {
        pub fn new() -> CohostContent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JoinGroupBizContent>(
                "joinGroupBizContent",
                |m: &CohostContent| { &m.joinGroupBizContent },
                |m: &mut CohostContent| { &mut m.joinGroupBizContent },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CohostContent>(
                "BusinessContent.CohostContent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CohostContent {
        const NAME: &'static str = "CohostContent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.joinGroupBizContent)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.joinGroupBizContent.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.joinGroupBizContent.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CohostContent {
            CohostContent::new()
        }

        fn clear(&mut self) {
            self.joinGroupBizContent.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CohostContent {
            static instance: CohostContent = CohostContent {
                joinGroupBizContent: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CohostContent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.CohostContent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CohostContent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CohostContent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BusinessContent.JoinGroupBizContent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct JoinGroupBizContent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupBizContent.fromRoomAgeRestricted)
        pub fromRoomAgeRestricted: i32,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupBizContent.fromTag)
        pub fromTag: ::protobuf::MessageField<Tag>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupBizContent.dialog)
        pub dialog: ::protobuf::MessageField<PerceptionDialogInfo>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupBizContent.punishInfo)
        pub punishInfo: ::protobuf::MessageField<super::PunishEventInfo>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupBizContent.joinGroupMsgExtra)
        pub joinGroupMsgExtra: ::protobuf::MessageField<JoinGroupMessageExtra>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.JoinGroupBizContent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a JoinGroupBizContent {
        fn default() -> &'a JoinGroupBizContent {
            <JoinGroupBizContent as ::protobuf::Message>::default_instance()
        }
    }

    impl JoinGroupBizContent {
        pub fn new() -> JoinGroupBizContent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fromRoomAgeRestricted",
                |m: &JoinGroupBizContent| { &m.fromRoomAgeRestricted },
                |m: &mut JoinGroupBizContent| { &mut m.fromRoomAgeRestricted },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Tag>(
                "fromTag",
                |m: &JoinGroupBizContent| { &m.fromTag },
                |m: &mut JoinGroupBizContent| { &mut m.fromTag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PerceptionDialogInfo>(
                "dialog",
                |m: &JoinGroupBizContent| { &m.dialog },
                |m: &mut JoinGroupBizContent| { &mut m.dialog },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::PunishEventInfo>(
                "punishInfo",
                |m: &JoinGroupBizContent| { &m.punishInfo },
                |m: &mut JoinGroupBizContent| { &mut m.punishInfo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JoinGroupMessageExtra>(
                "joinGroupMsgExtra",
                |m: &JoinGroupBizContent| { &m.joinGroupMsgExtra },
                |m: &mut JoinGroupBizContent| { &mut m.joinGroupMsgExtra },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JoinGroupBizContent>(
                "BusinessContent.JoinGroupBizContent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for JoinGroupBizContent {
        const NAME: &'static str = "JoinGroupBizContent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fromRoomAgeRestricted = is.read_int32()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.fromTag)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.dialog)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.punishInfo)?;
                    },
                    810 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.joinGroupMsgExtra)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.fromRoomAgeRestricted != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.fromRoomAgeRestricted);
            }
            if let Some(v) = self.fromTag.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dialog.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.punishInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.joinGroupMsgExtra.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.fromRoomAgeRestricted != 0 {
                os.write_int32(1, self.fromRoomAgeRestricted)?;
            }
            if let Some(v) = self.fromTag.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.dialog.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.punishInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.joinGroupMsgExtra.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(101, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> JoinGroupBizContent {
            JoinGroupBizContent::new()
        }

        fn clear(&mut self) {
            self.fromRoomAgeRestricted = 0;
            self.fromTag.clear();
            self.dialog.clear();
            self.punishInfo.clear();
            self.joinGroupMsgExtra.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static JoinGroupBizContent {
            static instance: JoinGroupBizContent = JoinGroupBizContent {
                fromRoomAgeRestricted: 0,
                fromTag: ::protobuf::MessageField::none(),
                dialog: ::protobuf::MessageField::none(),
                punishInfo: ::protobuf::MessageField::none(),
                joinGroupMsgExtra: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for JoinGroupBizContent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.JoinGroupBizContent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for JoinGroupBizContent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for JoinGroupBizContent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BusinessContent.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.Tag.tagType)
        pub tagType: i32,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.Tag.tagValue)
        pub tagValue: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.Tag.tagText)
        pub tagText: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.Tag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tagType",
                |m: &Tag| { &m.tagType },
                |m: &mut Tag| { &mut m.tagType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tagValue",
                |m: &Tag| { &m.tagValue },
                |m: &mut Tag| { &mut m.tagValue },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tagText",
                |m: &Tag| { &m.tagText },
                |m: &mut Tag| { &mut m.tagText },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "BusinessContent.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagType = is.read_int32()?;
                    },
                    18 => {
                        self.tagValue = is.read_string()?;
                    },
                    26 => {
                        self.tagText = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.tagType != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.tagType);
            }
            if !self.tagValue.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.tagValue);
            }
            if !self.tagText.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.tagText);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.tagType != 0 {
                os.write_int32(1, self.tagType)?;
            }
            if !self.tagValue.is_empty() {
                os.write_string(2, &self.tagValue)?;
            }
            if !self.tagText.is_empty() {
                os.write_string(3, &self.tagText)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagType = 0;
            self.tagValue.clear();
            self.tagText.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagType: 0,
                tagValue: ::std::string::String::new(),
                tagText: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Tag {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tag {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BusinessContent.PerceptionDialogInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PerceptionDialogInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.iconType)
        pub iconType: i64,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.title)
        pub title: ::protobuf::MessageField<super::Text>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.subTitle)
        pub subTitle: ::protobuf::MessageField<super::Text>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.adviceActionText)
        pub adviceActionText: ::protobuf::MessageField<super::Text>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.defaultActionText)
        pub defaultActionText: ::protobuf::MessageField<super::Text>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.violationDetailUrl)
        pub violationDetailUrl: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.scene)
        pub scene: i32,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.targetUserId)
        pub targetUserId: i64,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.targetRoomId)
        pub targetRoomId: i64,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.countDownTime)
        pub countDownTime: i64,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.showFeedback)
        pub showFeedback: bool,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.feedbackOptionsList)
        pub feedbackOptionsList: ::std::vec::Vec<PerceptionFeedbackOption>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionDialogInfo.policyTip)
        pub policyTip: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.PerceptionDialogInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PerceptionDialogInfo {
        fn default() -> &'a PerceptionDialogInfo {
            <PerceptionDialogInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PerceptionDialogInfo {
        pub fn new() -> PerceptionDialogInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "iconType",
                |m: &PerceptionDialogInfo| { &m.iconType },
                |m: &mut PerceptionDialogInfo| { &mut m.iconType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Text>(
                "title",
                |m: &PerceptionDialogInfo| { &m.title },
                |m: &mut PerceptionDialogInfo| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Text>(
                "subTitle",
                |m: &PerceptionDialogInfo| { &m.subTitle },
                |m: &mut PerceptionDialogInfo| { &mut m.subTitle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Text>(
                "adviceActionText",
                |m: &PerceptionDialogInfo| { &m.adviceActionText },
                |m: &mut PerceptionDialogInfo| { &mut m.adviceActionText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Text>(
                "defaultActionText",
                |m: &PerceptionDialogInfo| { &m.defaultActionText },
                |m: &mut PerceptionDialogInfo| { &mut m.defaultActionText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "violationDetailUrl",
                |m: &PerceptionDialogInfo| { &m.violationDetailUrl },
                |m: &mut PerceptionDialogInfo| { &mut m.violationDetailUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "scene",
                |m: &PerceptionDialogInfo| { &m.scene },
                |m: &mut PerceptionDialogInfo| { &mut m.scene },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "targetUserId",
                |m: &PerceptionDialogInfo| { &m.targetUserId },
                |m: &mut PerceptionDialogInfo| { &mut m.targetUserId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "targetRoomId",
                |m: &PerceptionDialogInfo| { &m.targetRoomId },
                |m: &mut PerceptionDialogInfo| { &mut m.targetRoomId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "countDownTime",
                |m: &PerceptionDialogInfo| { &m.countDownTime },
                |m: &mut PerceptionDialogInfo| { &mut m.countDownTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "showFeedback",
                |m: &PerceptionDialogInfo| { &m.showFeedback },
                |m: &mut PerceptionDialogInfo| { &mut m.showFeedback },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "feedbackOptionsList",
                |m: &PerceptionDialogInfo| { &m.feedbackOptionsList },
                |m: &mut PerceptionDialogInfo| { &mut m.feedbackOptionsList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "policyTip",
                |m: &PerceptionDialogInfo| { &m.policyTip },
                |m: &mut PerceptionDialogInfo| { &mut m.policyTip },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerceptionDialogInfo>(
                "BusinessContent.PerceptionDialogInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PerceptionDialogInfo {
        const NAME: &'static str = "PerceptionDialogInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.iconType = is.read_int64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.title)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.subTitle)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.adviceActionText)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.defaultActionText)?;
                    },
                    50 => {
                        self.violationDetailUrl = is.read_string()?;
                    },
                    56 => {
                        self.scene = is.read_int32()?;
                    },
                    64 => {
                        self.targetUserId = is.read_int64()?;
                    },
                    72 => {
                        self.targetRoomId = is.read_int64()?;
                    },
                    80 => {
                        self.countDownTime = is.read_int64()?;
                    },
                    88 => {
                        self.showFeedback = is.read_bool()?;
                    },
                    98 => {
                        self.feedbackOptionsList.push(is.read_message()?);
                    },
                    104 => {
                        self.policyTip = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.iconType != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.iconType);
            }
            if let Some(v) = self.title.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.subTitle.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.adviceActionText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.defaultActionText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.violationDetailUrl.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.violationDetailUrl);
            }
            if self.scene != 0 {
                my_size += ::protobuf::rt::int32_size(7, self.scene);
            }
            if self.targetUserId != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.targetUserId);
            }
            if self.targetRoomId != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.targetRoomId);
            }
            if self.countDownTime != 0 {
                my_size += ::protobuf::rt::int64_size(10, self.countDownTime);
            }
            if self.showFeedback != false {
                my_size += 1 + 1;
            }
            for value in &self.feedbackOptionsList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.policyTip != 0 {
                my_size += ::protobuf::rt::int64_size(13, self.policyTip);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.iconType != 0 {
                os.write_int64(1, self.iconType)?;
            }
            if let Some(v) = self.title.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.subTitle.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.adviceActionText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.defaultActionText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if !self.violationDetailUrl.is_empty() {
                os.write_string(6, &self.violationDetailUrl)?;
            }
            if self.scene != 0 {
                os.write_int32(7, self.scene)?;
            }
            if self.targetUserId != 0 {
                os.write_int64(8, self.targetUserId)?;
            }
            if self.targetRoomId != 0 {
                os.write_int64(9, self.targetRoomId)?;
            }
            if self.countDownTime != 0 {
                os.write_int64(10, self.countDownTime)?;
            }
            if self.showFeedback != false {
                os.write_bool(11, self.showFeedback)?;
            }
            for v in &self.feedbackOptionsList {
                ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            };
            if self.policyTip != 0 {
                os.write_int64(13, self.policyTip)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PerceptionDialogInfo {
            PerceptionDialogInfo::new()
        }

        fn clear(&mut self) {
            self.iconType = 0;
            self.title.clear();
            self.subTitle.clear();
            self.adviceActionText.clear();
            self.defaultActionText.clear();
            self.violationDetailUrl.clear();
            self.scene = 0;
            self.targetUserId = 0;
            self.targetRoomId = 0;
            self.countDownTime = 0;
            self.showFeedback = false;
            self.feedbackOptionsList.clear();
            self.policyTip = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PerceptionDialogInfo {
            static instance: PerceptionDialogInfo = PerceptionDialogInfo {
                iconType: 0,
                title: ::protobuf::MessageField::none(),
                subTitle: ::protobuf::MessageField::none(),
                adviceActionText: ::protobuf::MessageField::none(),
                defaultActionText: ::protobuf::MessageField::none(),
                violationDetailUrl: ::std::string::String::new(),
                scene: 0,
                targetUserId: 0,
                targetRoomId: 0,
                countDownTime: 0,
                showFeedback: false,
                feedbackOptionsList: ::std::vec::Vec::new(),
                policyTip: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PerceptionDialogInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.PerceptionDialogInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PerceptionDialogInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PerceptionDialogInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BusinessContent.PerceptionFeedbackOption)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PerceptionFeedbackOption {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionFeedbackOption.id)
        pub id: i64,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.PerceptionFeedbackOption.contentKey)
        pub contentKey: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.PerceptionFeedbackOption.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PerceptionFeedbackOption {
        fn default() -> &'a PerceptionFeedbackOption {
            <PerceptionFeedbackOption as ::protobuf::Message>::default_instance()
        }
    }

    impl PerceptionFeedbackOption {
        pub fn new() -> PerceptionFeedbackOption {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &PerceptionFeedbackOption| { &m.id },
                |m: &mut PerceptionFeedbackOption| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "contentKey",
                |m: &PerceptionFeedbackOption| { &m.contentKey },
                |m: &mut PerceptionFeedbackOption| { &mut m.contentKey },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerceptionFeedbackOption>(
                "BusinessContent.PerceptionFeedbackOption",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PerceptionFeedbackOption {
        const NAME: &'static str = "PerceptionFeedbackOption";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_int64()?;
                    },
                    18 => {
                        self.contentKey = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.id);
            }
            if !self.contentKey.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.contentKey);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_int64(1, self.id)?;
            }
            if !self.contentKey.is_empty() {
                os.write_string(2, &self.contentKey)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PerceptionFeedbackOption {
            PerceptionFeedbackOption::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.contentKey.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PerceptionFeedbackOption {
            static instance: PerceptionFeedbackOption = PerceptionFeedbackOption {
                id: 0,
                contentKey: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PerceptionFeedbackOption {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.PerceptionFeedbackOption").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PerceptionFeedbackOption {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PerceptionFeedbackOption {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BusinessContent.JoinGroupMessageExtra)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct JoinGroupMessageExtra {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.sourceType)
        pub sourceType: i64,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.extra)
        pub extra: ::protobuf::MessageField<join_group_message_extra::RivalExtra>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.otherUsersList)
        pub otherUsersList: ::std::vec::Vec<join_group_message_extra::RivalExtra>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.JoinGroupMessageExtra.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a JoinGroupMessageExtra {
        fn default() -> &'a JoinGroupMessageExtra {
            <JoinGroupMessageExtra as ::protobuf::Message>::default_instance()
        }
    }

    impl JoinGroupMessageExtra {
        pub fn new() -> JoinGroupMessageExtra {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sourceType",
                |m: &JoinGroupMessageExtra| { &m.sourceType },
                |m: &mut JoinGroupMessageExtra| { &mut m.sourceType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, join_group_message_extra::RivalExtra>(
                "extra",
                |m: &JoinGroupMessageExtra| { &m.extra },
                |m: &mut JoinGroupMessageExtra| { &mut m.extra },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "otherUsersList",
                |m: &JoinGroupMessageExtra| { &m.otherUsersList },
                |m: &mut JoinGroupMessageExtra| { &mut m.otherUsersList },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JoinGroupMessageExtra>(
                "BusinessContent.JoinGroupMessageExtra",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for JoinGroupMessageExtra {
        const NAME: &'static str = "JoinGroupMessageExtra";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sourceType = is.read_int64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.extra)?;
                    },
                    26 => {
                        self.otherUsersList.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.sourceType != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.sourceType);
            }
            if let Some(v) = self.extra.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.otherUsersList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.sourceType != 0 {
                os.write_int64(1, self.sourceType)?;
            }
            if let Some(v) = self.extra.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.otherUsersList {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> JoinGroupMessageExtra {
            JoinGroupMessageExtra::new()
        }

        fn clear(&mut self) {
            self.sourceType = 0;
            self.extra.clear();
            self.otherUsersList.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static JoinGroupMessageExtra {
            static instance: JoinGroupMessageExtra = JoinGroupMessageExtra {
                sourceType: 0,
                extra: ::protobuf::MessageField::none(),
                otherUsersList: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for JoinGroupMessageExtra {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.JoinGroupMessageExtra").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for JoinGroupMessageExtra {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for JoinGroupMessageExtra {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `JoinGroupMessageExtra`
    pub mod join_group_message_extra {
        // @@protoc_insertion_point(message:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RivalExtra {
            // message fields
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.userCount)
            pub userCount: i64,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.avatarThumb)
            pub avatarThumb: ::protobuf::MessageField<super::super::Image>,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.displayId)
            pub displayId: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.authenticationInfo)
            pub authenticationInfo: ::protobuf::MessageField<rival_extra::AuthenticationInfo>,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.nickname)
            pub nickname: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.followStatus)
            pub followStatus: i64,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.hashtag)
            pub hashtag: ::protobuf::MessageField<super::Hashtag>,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.topHostInfo)
            pub topHostInfo: ::protobuf::MessageField<super::TopHostInfo>,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.userId)
            pub userId: i64,
            // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.isBestTeammate)
            pub isBestTeammate: bool,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RivalExtra {
            fn default() -> &'a RivalExtra {
                <RivalExtra as ::protobuf::Message>::default_instance()
            }
        }

        impl RivalExtra {
            pub fn new() -> RivalExtra {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(10);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "userCount",
                    |m: &RivalExtra| { &m.userCount },
                    |m: &mut RivalExtra| { &mut m.userCount },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::Image>(
                    "avatarThumb",
                    |m: &RivalExtra| { &m.avatarThumb },
                    |m: &mut RivalExtra| { &mut m.avatarThumb },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "displayId",
                    |m: &RivalExtra| { &m.displayId },
                    |m: &mut RivalExtra| { &mut m.displayId },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, rival_extra::AuthenticationInfo>(
                    "authenticationInfo",
                    |m: &RivalExtra| { &m.authenticationInfo },
                    |m: &mut RivalExtra| { &mut m.authenticationInfo },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "nickname",
                    |m: &RivalExtra| { &m.nickname },
                    |m: &mut RivalExtra| { &mut m.nickname },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "followStatus",
                    |m: &RivalExtra| { &m.followStatus },
                    |m: &mut RivalExtra| { &mut m.followStatus },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Hashtag>(
                    "hashtag",
                    |m: &RivalExtra| { &m.hashtag },
                    |m: &mut RivalExtra| { &mut m.hashtag },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::TopHostInfo>(
                    "topHostInfo",
                    |m: &RivalExtra| { &m.topHostInfo },
                    |m: &mut RivalExtra| { &mut m.topHostInfo },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "userId",
                    |m: &RivalExtra| { &m.userId },
                    |m: &mut RivalExtra| { &mut m.userId },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "isBestTeammate",
                    |m: &RivalExtra| { &m.isBestTeammate },
                    |m: &mut RivalExtra| { &mut m.isBestTeammate },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RivalExtra>(
                    "BusinessContent.JoinGroupMessageExtra.RivalExtra",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RivalExtra {
            const NAME: &'static str = "RivalExtra";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        32 => {
                            self.userCount = is.read_int64()?;
                        },
                        42 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatarThumb)?;
                        },
                        50 => {
                            self.displayId = is.read_string()?;
                        },
                        58 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.authenticationInfo)?;
                        },
                        66 => {
                            self.nickname = is.read_string()?;
                        },
                        72 => {
                            self.followStatus = is.read_int64()?;
                        },
                        82 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.hashtag)?;
                        },
                        90 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.topHostInfo)?;
                        },
                        96 => {
                            self.userId = is.read_int64()?;
                        },
                        104 => {
                            self.isBestTeammate = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.userCount != 0 {
                    my_size += ::protobuf::rt::int64_size(4, self.userCount);
                }
                if let Some(v) = self.avatarThumb.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if !self.displayId.is_empty() {
                    my_size += ::protobuf::rt::string_size(6, &self.displayId);
                }
                if let Some(v) = self.authenticationInfo.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if !self.nickname.is_empty() {
                    my_size += ::protobuf::rt::string_size(8, &self.nickname);
                }
                if self.followStatus != 0 {
                    my_size += ::protobuf::rt::int64_size(9, self.followStatus);
                }
                if let Some(v) = self.hashtag.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.topHostInfo.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if self.userId != 0 {
                    my_size += ::protobuf::rt::int64_size(12, self.userId);
                }
                if self.isBestTeammate != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.userCount != 0 {
                    os.write_int64(4, self.userCount)?;
                }
                if let Some(v) = self.avatarThumb.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                }
                if !self.displayId.is_empty() {
                    os.write_string(6, &self.displayId)?;
                }
                if let Some(v) = self.authenticationInfo.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                }
                if !self.nickname.is_empty() {
                    os.write_string(8, &self.nickname)?;
                }
                if self.followStatus != 0 {
                    os.write_int64(9, self.followStatus)?;
                }
                if let Some(v) = self.hashtag.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                }
                if let Some(v) = self.topHostInfo.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                }
                if self.userId != 0 {
                    os.write_int64(12, self.userId)?;
                }
                if self.isBestTeammate != false {
                    os.write_bool(13, self.isBestTeammate)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RivalExtra {
                RivalExtra::new()
            }

            fn clear(&mut self) {
                self.userCount = 0;
                self.avatarThumb.clear();
                self.displayId.clear();
                self.authenticationInfo.clear();
                self.nickname.clear();
                self.followStatus = 0;
                self.hashtag.clear();
                self.topHostInfo.clear();
                self.userId = 0;
                self.isBestTeammate = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RivalExtra {
                static instance: RivalExtra = RivalExtra {
                    userCount: 0,
                    avatarThumb: ::protobuf::MessageField::none(),
                    displayId: ::std::string::String::new(),
                    authenticationInfo: ::protobuf::MessageField::none(),
                    nickname: ::std::string::String::new(),
                    followStatus: 0,
                    hashtag: ::protobuf::MessageField::none(),
                    topHostInfo: ::protobuf::MessageField::none(),
                    userId: 0,
                    isBestTeammate: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for RivalExtra {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("BusinessContent.JoinGroupMessageExtra.RivalExtra").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RivalExtra {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RivalExtra {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `RivalExtra`
        pub mod rival_extra {
            // @@protoc_insertion_point(message:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.AuthenticationInfo)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct AuthenticationInfo {
                // message fields
                // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.AuthenticationInfo.customVerify)
                pub customVerify: ::std::string::String,
                // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.AuthenticationInfo.enterpriseVerifyReason)
                pub enterpriseVerifyReason: ::std::string::String,
                // @@protoc_insertion_point(field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.AuthenticationInfo.authenticationBadge)
                pub authenticationBadge: ::protobuf::MessageField<super::super::super::Image>,
                // special fields
                // @@protoc_insertion_point(special_field:TikTok.BusinessContent.JoinGroupMessageExtra.RivalExtra.AuthenticationInfo.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a AuthenticationInfo {
                fn default() -> &'a AuthenticationInfo {
                    <AuthenticationInfo as ::protobuf::Message>::default_instance()
                }
            }

            impl AuthenticationInfo {
                pub fn new() -> AuthenticationInfo {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(3);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "customVerify",
                        |m: &AuthenticationInfo| { &m.customVerify },
                        |m: &mut AuthenticationInfo| { &mut m.customVerify },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "enterpriseVerifyReason",
                        |m: &AuthenticationInfo| { &m.enterpriseVerifyReason },
                        |m: &mut AuthenticationInfo| { &mut m.enterpriseVerifyReason },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::Image>(
                        "authenticationBadge",
                        |m: &AuthenticationInfo| { &m.authenticationBadge },
                        |m: &mut AuthenticationInfo| { &mut m.authenticationBadge },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthenticationInfo>(
                        "BusinessContent.JoinGroupMessageExtra.RivalExtra.AuthenticationInfo",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for AuthenticationInfo {
                const NAME: &'static str = "AuthenticationInfo";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.customVerify = is.read_string()?;
                            },
                            18 => {
                                self.enterpriseVerifyReason = is.read_string()?;
                            },
                            26 => {
                                ::protobuf::rt::read_singular_message_into_field(is, &mut self.authenticationBadge)?;
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if !self.customVerify.is_empty() {
                        my_size += ::protobuf::rt::string_size(1, &self.customVerify);
                    }
                    if !self.enterpriseVerifyReason.is_empty() {
                        my_size += ::protobuf::rt::string_size(2, &self.enterpriseVerifyReason);
                    }
                    if let Some(v) = self.authenticationBadge.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if !self.customVerify.is_empty() {
                        os.write_string(1, &self.customVerify)?;
                    }
                    if !self.enterpriseVerifyReason.is_empty() {
                        os.write_string(2, &self.enterpriseVerifyReason)?;
                    }
                    if let Some(v) = self.authenticationBadge.as_ref() {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> AuthenticationInfo {
                    AuthenticationInfo::new()
                }

                fn clear(&mut self) {
                    self.customVerify.clear();
                    self.enterpriseVerifyReason.clear();
                    self.authenticationBadge.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static AuthenticationInfo {
                    static instance: AuthenticationInfo = AuthenticationInfo {
                        customVerify: ::std::string::String::new(),
                        enterpriseVerifyReason: ::std::string::String::new(),
                        authenticationBadge: ::protobuf::MessageField::none(),
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for AuthenticationInfo {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("BusinessContent.JoinGroupMessageExtra.RivalExtra.AuthenticationInfo").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for AuthenticationInfo {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for AuthenticationInfo {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }
    }

    // @@protoc_insertion_point(message:TikTok.BusinessContent.Hashtag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Hashtag {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.Hashtag.id)
        pub id: i64,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.Hashtag.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.Hashtag.image)
        pub image: ::protobuf::MessageField<super::Image>,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.Hashtag.namespace)
        pub namespace: ::protobuf::EnumOrUnknown<super::super::enums::HashtagNamespace>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.Hashtag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Hashtag {
        fn default() -> &'a Hashtag {
            <Hashtag as ::protobuf::Message>::default_instance()
        }
    }

    impl Hashtag {
        pub fn new() -> Hashtag {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &Hashtag| { &m.id },
                |m: &mut Hashtag| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &Hashtag| { &m.title },
                |m: &mut Hashtag| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Image>(
                "image",
                |m: &Hashtag| { &m.image },
                |m: &mut Hashtag| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "namespace",
                |m: &Hashtag| { &m.namespace },
                |m: &mut Hashtag| { &mut m.namespace },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hashtag>(
                "BusinessContent.Hashtag",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Hashtag {
        const NAME: &'static str = "Hashtag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_int64()?;
                    },
                    18 => {
                        self.title = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                    },
                    32 => {
                        self.namespace = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.id);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.title);
            }
            if let Some(v) = self.image.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.namespace != ::protobuf::EnumOrUnknown::new(super::super::enums::HashtagNamespace::GLOBAL) {
                my_size += ::protobuf::rt::int32_size(4, self.namespace.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_int64(1, self.id)?;
            }
            if !self.title.is_empty() {
                os.write_string(2, &self.title)?;
            }
            if let Some(v) = self.image.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.namespace != ::protobuf::EnumOrUnknown::new(super::super::enums::HashtagNamespace::GLOBAL) {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.namespace))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Hashtag {
            Hashtag::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.title.clear();
            self.image.clear();
            self.namespace = ::protobuf::EnumOrUnknown::new(super::super::enums::HashtagNamespace::GLOBAL);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Hashtag {
            static instance: Hashtag = Hashtag {
                id: 0,
                title: ::std::string::String::new(),
                image: ::protobuf::MessageField::none(),
                namespace: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Hashtag {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.Hashtag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Hashtag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Hashtag {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.BusinessContent.TopHostInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TopHostInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.BusinessContent.TopHostInfo.rankType)
        pub rankType: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.BusinessContent.TopHostInfo.topIndex)
        pub topIndex: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.BusinessContent.TopHostInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TopHostInfo {
        fn default() -> &'a TopHostInfo {
            <TopHostInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl TopHostInfo {
        pub fn new() -> TopHostInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rankType",
                |m: &TopHostInfo| { &m.rankType },
                |m: &mut TopHostInfo| { &mut m.rankType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "topIndex",
                |m: &TopHostInfo| { &m.topIndex },
                |m: &mut TopHostInfo| { &mut m.topIndex },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TopHostInfo>(
                "BusinessContent.TopHostInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TopHostInfo {
        const NAME: &'static str = "TopHostInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.rankType = is.read_string()?;
                    },
                    16 => {
                        self.topIndex = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.rankType.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.rankType);
            }
            if self.topIndex != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.topIndex);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.rankType.is_empty() {
                os.write_string(1, &self.rankType)?;
            }
            if self.topIndex != 0 {
                os.write_int64(2, self.topIndex)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TopHostInfo {
            TopHostInfo::new()
        }

        fn clear(&mut self) {
            self.rankType.clear();
            self.topIndex = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TopHostInfo {
            static instance: TopHostInfo = TopHostInfo {
                rankType: ::std::string::String::new(),
                topIndex: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TopHostInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BusinessContent.TopHostInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TopHostInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TopHostInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.JoinGroupContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JoinGroupContent {
    // message fields
    // @@protoc_insertion_point(field:TikTok.JoinGroupContent.groupUser)
    pub groupUser: ::protobuf::MessageField<GroupChannelAllUser>,
    // @@protoc_insertion_point(field:TikTok.JoinGroupContent.joinUser)
    pub joinUser: ::protobuf::MessageField<GroupPlayer>,
    // @@protoc_insertion_point(field:TikTok.JoinGroupContent.type)
    pub type_: ::protobuf::EnumOrUnknown<super::enums::TextType>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.JoinGroupContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JoinGroupContent {
    fn default() -> &'a JoinGroupContent {
        <JoinGroupContent as ::protobuf::Message>::default_instance()
    }
}

impl JoinGroupContent {
    pub fn new() -> JoinGroupContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupChannelAllUser>(
            "groupUser",
            |m: &JoinGroupContent| { &m.groupUser },
            |m: &mut JoinGroupContent| { &mut m.groupUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupPlayer>(
            "joinUser",
            |m: &JoinGroupContent| { &m.joinUser },
            |m: &mut JoinGroupContent| { &mut m.joinUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &JoinGroupContent| { &m.type_ },
            |m: &mut JoinGroupContent| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JoinGroupContent>(
            "JoinGroupContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JoinGroupContent {
    const NAME: &'static str = "JoinGroupContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.groupUser)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.joinUser)?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.joinUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.joinUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JoinGroupContent {
        JoinGroupContent::new()
    }

    fn clear(&mut self) {
        self.groupUser.clear();
        self.joinUser.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(super::enums::TextType::DISPLAY_TEXT);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JoinGroupContent {
        static instance: JoinGroupContent = JoinGroupContent {
            groupUser: ::protobuf::MessageField::none(),
            joinUser: ::protobuf::MessageField::none(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JoinGroupContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JoinGroupContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JoinGroupContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JoinGroupContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\ndata.proto\x12\x06TikTok\x1a\x0benums.proto\"\xb7\n\n\x06Common\x12\
    \x16\n\x06method\x18\x01\x20\x01(\tR\x06method\x12\x14\n\x05msgId\x18\
    \x02\x20\x01(\x03R\x05msgId\x12\x16\n\x06roomId\x18\x03\x20\x01(\x03R\
    \x06roomId\x12\x1e\n\ncreateTime\x18\x04\x20\x01(\x03R\ncreateTime\x12\
    \x18\n\x07monitor\x18\x05\x20\x01(\x05R\x07monitor\x12\x1c\n\tisShowMsg\
    \x18\x06\x20\x01(\x08R\tisShowMsg\x12\x1a\n\x08describe\x18\x07\x20\x01(\
    \tR\x08describe\x12.\n\x0bdisplayText\x18\x08\x20\x01(\x0b2\x0c.TikTok.T\
    extR\x0bdisplayText\x12\x1a\n\x08foldType\x18\t\x20\x01(\x03R\x08foldTyp\
    e\x12&\n\x0eanchorFoldType\x18\n\x20\x01(\x03R\x0eanchorFoldType\x12$\n\
    \rpriorityScore\x18\x0b\x20\x01(\x03R\rpriorityScore\x12\x14\n\x05logId\
    \x18\x0c\x20\x01(\tR\x05logId\x12,\n\x11msgProcessFilterK\x18\r\x20\x01(\
    \tR\x11msgProcessFilterK\x12,\n\x11msgProcessFilterV\x18\x0e\x20\x01(\tR\
    \x11msgProcessFilterV\x12\x18\n\x07fromIdc\x18\x0f\x20\x01(\tR\x07fromId\
    c\x12\x14\n\x05toIdc\x18\x10\x20\x01(\tR\x05toIdc\x12,\n\x11filterMsgTag\
    sList\x18\x11\x20\x03(\tR\x11filterMsgTagsList\x12/\n\x03sei\x18\x12\x20\
    \x01(\x0b2\x1d.TikTok.Common.LiveMessageSEIR\x03sei\x12@\n\x0cdependRoot\
    Id\x18\x13\x20\x01(\x0b2\x1c.TikTok.Common.LiveMessageIDR\x0cdependRootI\
    d\x128\n\x08dependId\x18\x14\x20\x01(\x0b2\x1c.TikTok.Common.LiveMessage\
    IDR\x08dependId\x120\n\x13anchorPriorityScore\x18\x15\x20\x01(\x03R\x13a\
    nchorPriorityScore\x122\n\x14roomMessageHeatLevel\x18\x16\x20\x01(\x03R\
    \x14roomMessageHeatLevel\x12&\n\x0efoldTypeForWeb\x18\x17\x20\x01(\x03R\
    \x0efoldTypeForWeb\x122\n\x14anchorFoldTypeForWeb\x18\x18\x20\x01(\x03R\
    \x14anchorFoldTypeForWeb\x12&\n\x0eclientSendTime\x18\x19\x20\x01(\x03R\
    \x0eclientSendTime\x12M\n\x10dispatchStrategy\x18\x1a\x20\x01(\x0e2!.Tik\
    Tok.Common.IMDispatchStrategyR\x10dispatchStrategy\x1ah\n\x0eLiveMessage\
    SEI\x128\n\x08uniqueId\x18\x01\x20\x01(\x0b2\x1c.TikTok.Common.LiveMessa\
    geIDR\x08uniqueId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\
    \x1aQ\n\rLiveMessageID\x12\x1c\n\tprimaryId\x18\x01\x20\x01(\tR\tprimary\
    Id\x12\"\n\x0cmessageScene\x18\x02\x20\x01(\tR\x0cmessageScene\"f\n\x12I\
    MDispatchStrategy\x12\x20\n\x1cIM_DISPATCH_STRATEGY_DEFAULT\x10\0\x12.\n\
    *IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE\x10\x01\"\xe3\x07\n\x04Text\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12&\n\x0edefaultPattern\
    \x18\x02\x20\x01(\tR\x0edefaultPattern\x12=\n\rdefaultFormat\x18\x03\x20\
    \x01(\x0b2\x17.TikTok.Text.TextFormatR\rdefaultFormat\x126\n\npiecesList\
    \x18\x04\x20\x03(\x0b2\x16.TikTok.Text.TextPieceR\npiecesList\x1a\xc7\
    \x02\n\tTextPiece\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12/\n\
    \x06format\x18\x02\x20\x01(\x0b2\x17.TikTok.Text.TextFormatR\x06format\
    \x12\x20\n\x0bstringValue\x18\x0b\x20\x01(\tR\x0bstringValue\x12:\n\tuse\
    rValue\x18\x15\x20\x01(\x0b2\x1a.TikTok.Text.TextPieceUserH\0R\tuserValu\
    e\x12:\n\tgiftValue\x18\x16\x20\x01(\x0b2\x1a.TikTok.Text.TextPieceGiftH\
    \0R\tgiftValue\x12J\n\x0fpatternRefValue\x18\x18\x20\x01(\x0b2\x20.TikTo\
    k.Text.TextPiecePatternRefR\x0fpatternRefValueB\x0f\n\rtextPieceType\x1a\
    \xfa\x01\n\nTextFormat\x12\x14\n\x05color\x18\x01\x20\x01(\tR\x05color\
    \x12\x12\n\x04bold\x18\x02\x20\x01(\x08R\x04bold\x12\x16\n\x06italic\x18\
    \x03\x20\x01(\x08R\x06italic\x12\x16\n\x06weight\x18\x04\x20\x01(\x05R\
    \x06weight\x12\x20\n\x0bitalicAngle\x18\x05\x20\x01(\x05R\x0bitalicAngle\
    \x12\x1a\n\x08fontSize\x18\x06\x20\x01(\x05R\x08fontSize\x12.\n\x12useHe\
    ighLightColor\x18\x07\x20\x01(\x08R\x12useHeighLightColor\x12$\n\ruseRem\
    oteClor\x18\x08\x20\x01(\x08R\ruseRemoteClor\x1aA\n\rTextPieceGift\x12\
    \x16\n\x06giftId\x18\x01\x20\x01(\x05R\x06giftId\x12\x18\n\x07colorId\
    \x18\x04\x20\x01(\x03R\x07colorId\x1aO\n\x13TextPiecePatternRef\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12&\n\x0edefaultPattern\x18\x02\
    \x20\x01(\tR\x0edefaultPattern\x1aO\n\rTextPieceUser\x12\x20\n\x04user\
    \x18\x01\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12\x1c\n\twithColon\x18\
    \x02\x20\x01(\x08R\twithColon\"A\n\x05Image\x12\x18\n\x07urlList\x18\x01\
    \x20\x03(\tR\x07urlList\x12\x1e\n\nisAnimated\x18\t\x20\x01(\x08R\nisAni\
    mated\"\xc8\x12\n\x0bBadgeStruct\x12F\n\x0bdisplayType\x18\x01\x20\x01(\
    \x0e2$.TikTok.BadgeStruct.BadgeDisplayTypeR\x0bdisplayType\x126\n\x05ima\
    ge\x18\x14\x20\x01(\x0b2\x1e.TikTok.BadgeStruct.ImageBadgeH\0R\x05image\
    \x123\n\x04text\x18\x15\x20\x01(\x0b2\x1d.TikTok.BadgeStruct.TextBadgeH\
    \0R\x04text\x123\n\x03str\x18\x16\x20\x01(\x0b2\x1f.TikTok.BadgeStruct.S\
    tringBadgeH\0R\x03str\x12<\n\x07combine\x18\x17\x20\x01(\x0b2\x20.TikTok\
    .BadgeStruct.CombineBadgeH\0R\x07combine\x1a\xbc\x05\n\x0cCombineBadge\
    \x12!\n\x04icon\x18\x02\x20\x01(\x0b2\r.TikTok.ImageR\x04icon\x121\n\x04\
    text\x18\x03\x20\x01(\x0b2\x1d.TikTok.BadgeStruct.TextBadgeR\x04text\x12\
    \x10\n\x03str\x18\x04\x20\x01(\tR\x03str\x12P\n\x10profileCardPanel\x18\
    \x07\x20\x01(\x0b2$.TikTok.BadgeStruct.ProfileCardPanelR\x10profileCardP\
    anel\x12J\n\nbackground\x18\x0b\x20\x01(\x0b2*.TikTok.BadgeStruct.Combin\
    eBadgeBackgroundR\nbackground\x12Z\n\x12backgroundDarkMode\x18\x0c\x20\
    \x01(\x0b2*.TikTok.BadgeStruct.CombineBadgeBackgroundR\x12backgroundDark\
    Mode\x12*\n\x10iconAutoMirrored\x18\r\x20\x01(\x08R\x10iconAutoMirrored\
    \x126\n\x16backgroundAutoMirrored\x18\x0e\x20\x01(\x08R\x16backgroundAut\
    oMirrored\x124\n\x15publicScreenShowStyle\x18\x0f\x20\x01(\x05R\x15publi\
    cScreenShowStyle\x124\n\x15personalCardShowStyle\x18\x10\x20\x01(\x05R\
    \x15personalCardShowStyle\x12H\n\x1franklistOnlineAudienceShowStyle\x18\
    \x11\x20\x01(\x05R\x1franklistOnlineAudienceShowStyle\x120\n\x13multiGue\
    stShowStyle\x18\x12\x20\x01(\x05R\x13multiGuestShowStyle\x1a\xb2\x01\n\
    \x0eProfileContent\x12\x1e\n\nuseContent\x18\x01\x20\x01(\x08R\nuseConte\
    nt\x12:\n\x08iconList\x18\x02\x20\x03(\x0b2\x1e.TikTok.BadgeStruct.IconC\
    onfigR\x08iconList\x12D\n\x0cnumberConfig\x18\x03\x20\x01(\x0b2\x20.TikT\
    ok.BadgeStruct.NumberConfigR\x0cnumberConfig\x1a[\n\x10ProjectionConfig\
    \x12$\n\ruseProjection\x18\x01\x20\x01(\x08R\ruseProjection\x12!\n\x04ic\
    on\x18\x02\x20\x01(\x0b2\r.TikTok.ImageR\x04icon\x1ar\n\x0cNumberConfig\
    \x12\x16\n\x06number\x18\x01\x20\x01(\x03R\x06number\x12J\n\nbackground\
    \x18\x03\x20\x01(\x0b2*.TikTok.BadgeStruct.CombineBadgeBackgroundR\nback\
    ground\x1a\xe8\x01\n\x10ProfileCardPanel\x126\n\x16useNewProfileCardStyl\
    e\x18\x01\x20\x01(\x08R\x16useNewProfileCardStyle\x12P\n\x10projectionCo\
    nfig\x18\x03\x20\x01(\x0b2$.TikTok.BadgeStruct.ProjectionConfigR\x10proj\
    ectionConfig\x12J\n\x0eprofileContent\x18\x04\x20\x01(\x0b2\".TikTok.Bad\
    geStruct.ProfileContentR\x0eprofileContent\x1a\x99\x01\n\x16CombineBadge\
    Background\x12#\n\x05image\x18\x01\x20\x01(\x0b2\r.TikTok.ImageR\x05imag\
    e\x120\n\x13backgroundColorCode\x18\x02\x20\x01(\tR\x13backgroundColorCo\
    de\x12(\n\x0fborderColorCode\x18\x03\x20\x01(\tR\x0fborderColorCode\x1a1\
    \n\nImageBadge\x12#\n\x05image\x18\x02\x20\x01(\x0b2\r.TikTok.ImageR\x05\
    image\x1a3\n\tTextBadge\x12&\n\x0edefaultPattern\x18\x03\x20\x01(\tR\x0e\
    defaultPattern\x1a{\n\nIconConfig\x12!\n\x04icon\x18\x01\x20\x01(\x0b2\r\
    .TikTok.ImageR\x04icon\x12J\n\nbackground\x18\x02\x20\x01(\x0b2*.TikTok.\
    BadgeStruct.CombineBadgeBackgroundR\nbackground\x1a\x1f\n\x0bStringBadge\
    \x12\x10\n\x03str\x18\x02\x20\x01(\tR\x03str\"G\n\x08DataCase\x12\x10\n\
    \x0cDATA_NOT_SET\x10\0\x12\t\n\x05IMAGE\x10\x14\x12\x08\n\x04TEXT\x10\
    \x15\x12\x07\n\x03STR\x10\x16\x12\x0b\n\x07COMBINE\x10\x17\"\xa2\x01\n\
    \x10BadgeDisplayType\x12\x1c\n\x18BADGEDISPLAYTYPE_UNKNOWN\x10\0\x12\x1a\
    \n\x16BADGEDISPLAYTYPE_IMAGE\x10\x01\x12\x19\n\x15BADGEDISPLAYTYPE_TEXT\
    \x10\x02\x12\x1b\n\x17BADGEDISPLAYTYPE_STRING\x10\x03\x12\x1c\n\x18BADGE\
    DISPLAYTYPE_COMBINE\x10\x04\"D\n\x08Position\x12\x13\n\x0fPOSITIONUNKNOW\
    N\x10\0\x12\x10\n\x0cPOSITIONLEFT\x10\x01\x12\x11\n\rPOSITIONRIGHT\x10\
    \x02B\x0b\n\tbadgeType\"\xf1\r\n\nGiftStruct\x12#\n\x05image\x18\x01\x20\
    \x01(\x0b2\r.TikTok.ImageR\x05image\x12\x1a\n\x08describe\x18\x02\x20\
    \x01(\tR\x08describe\x12\x1a\n\x08duration\x18\x04\x20\x01(\x03R\x08dura\
    tion\x12\x0e\n\x02id\x18\x05\x20\x01(\x03R\x02id\x12\x1e\n\nforLinkmic\
    \x18\x07\x20\x01(\x08R\nforLinkmic\x12\x14\n\x05combo\x18\n\x20\x01(\x08\
    R\x05combo\x12\x12\n\x04type\x18\x0b\x20\x01(\x05R\x04type\x12\"\n\x0cdi\
    amondCount\x18\x0c\x20\x01(\x05R\x0cdiamondCount\x12.\n\x12isDisplayedOn\
    Panel\x18\r\x20\x01(\x08R\x12isDisplayedOnPanel\x12(\n\x0fprimaryEffectI\
    d\x18\x0e\x20\x01(\x03R\x0fprimaryEffectId\x123\n\rgiftLabelIcon\x18\x0f\
    \x20\x01(\x0b2\r.TikTok.ImageR\rgiftLabelIcon\x12\x12\n\x04name\x18\x10\
    \x20\x01(\tR\x04name\x12!\n\x04icon\x18\x15\x20\x01(\x0b2\r.TikTok.Image\
    R\x04icon\x12\x1e\n\ngoldEffect\x18\x18\x20\x01(\tR\ngoldEffect\x121\n\
    \x0cpreviewImage\x18/\x20\x01(\x0b2\r.TikTok.ImageR\x0cpreviewImage\x12L\
    \n\x0fgiftPanelBanner\x180\x20\x01(\x0b2\".TikTok.GiftStruct.GiftPanelBa\
    nnerR\x0fgiftPanelBanner\x12(\n\x0fisBroadcastGift\x181\x20\x01(\x08R\
    \x0fisBroadcastGift\x12(\n\x0fisEffectBefview\x182\x20\x01(\x08R\x0fisEf\
    fectBefview\x12\"\n\x0cisRandomGift\x183\x20\x01(\x08R\x0cisRandomGift\
    \x12\x1c\n\tisBoxGift\x184\x20\x01(\x08R\tisBoxGift\x12(\n\x0fcanPutInGi\
    ftBox\x185\x20\x01(\x08R\x0fcanPutInGiftBox\x1a\xde\x01\n\x0fGiftPanelBa\
    nner\x12.\n\x0bdisplayText\x18\x01\x20\x01(\x0b2\x0c.TikTok.TextR\x0bdis\
    playText\x12)\n\x08leftIcon\x18\x02\x20\x01(\x0b2\r.TikTok.ImageR\x08lef\
    tIcon\x12\x1c\n\tschemaUrl\x18\x03\x20\x01(\tR\tschemaUrl\x12,\n\x11bgCo\
    lorValuesList\x18\x05\x20\x03(\tR\x11bgColorValuesList\x12$\n\rbannerLyn\
    xUrl\x18\x06\x20\x01(\tR\rbannerLynxUrl\x1a\xa9\x02\n\x14GiftRandomEffec\
    tInfo\x12^\n\x15randomGiftPanelBanner\x18\x01\x20\x01(\x0b2(.TikTok.Gift\
    Struct.RandomGiftPanelBannerR\x15randomGiftPanelBanner\x12$\n\reffectIds\
    List\x18\x02\x20\x03(\x03R\reffectIdsList\x12\x18\n\x07hostKey\x18\x03\
    \x20\x01(\tR\x07hostKey\x12\x20\n\x0baudienceKey\x18\x04\x20\x01(\tR\x0b\
    audienceKey\x12O\n\x10randomGiftBubble\x18\x05\x20\x01(\x0b2#.TikTok.Gif\
    tStruct.RandomGiftBubbleR\x10randomGiftBubble\x1aq\n\x10RandomGiftBubble\
    \x12\x20\n\x0bdisplayText\x18\x01\x20\x01(\tR\x0bdisplayText\x12;\n\x11i\
    conDynamicEffect\x18\x02\x20\x01(\x0b2\r.TikTok.ImageR\x11iconDynamicEff\
    ect\x1a\xe0\x02\n\x15RandomGiftPanelBanner\x12'\n\x07bgImage\x18\x01\x20\
    \x01(\x0b2\r.TikTok.ImageR\x07bgImage\x121\n\x0cshadingImage\x18\x02\x20\
    \x01(\x0b2\r.TikTok.ImageR\x0cshadingImage\x12\x1c\n\ttargetNum\x18\x03\
    \x20\x01(\x03R\ttargetNum\x12\x1e\n\ncollectNum\x18\x04\x20\x01(\x03R\nc\
    ollectNum\x12\x20\n\x0bdisplayText\x18\x05\x20\x01(\tR\x0bdisplayText\
    \x12)\n\x08leftIcon\x18\x06\x20\x01(\x0b2\r.TikTok.ImageR\x08leftIcon\
    \x12\x1c\n\tschemaUrl\x18\x07\x20\x01(\tR\tschemaUrl\x12,\n\x11bgColorVa\
    luesList\x18\x08\x20\x03(\tR\x11bgColorValuesList\x12\x14\n\x05round\x18\
    \t\x20\x01(\x03R\x05round\"\x9fX\n\x04User\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\x03R\x02id\x12\x1a\n\x08nickname\x18\x03\x20\x01(\tR\x08nickname\
    \x12&\n\x0ebioDescription\x18\x05\x20\x01(\tR\x0ebioDescription\x12/\n\
    \x0bavatarThumb\x18\t\x20\x01(\x0b2\r.TikTok.ImageR\x0bavatarThumb\x121\
    \n\x0cavatarMedium\x18\n\x20\x01(\x0b2\r.TikTok.ImageR\x0cavatarMedium\
    \x12/\n\x0bavatarLarge\x18\x0b\x20\x01(\x0b2\r.TikTok.ImageR\x0bavatarLa\
    rge\x12\x1a\n\x08verified\x18\x0c\x20\x01(\x08R\x08verified\x12\x16\n\
    \x06status\x18\x0f\x20\x01(\x05R\x06status\x12\x1e\n\ncreateTime\x18\x10\
    \x20\x01(\x03R\ncreateTime\x12\x1e\n\nmodifyTime\x18\x11\x20\x01(\x03R\n\
    modifyTime\x12\x16\n\x06secret\x18\x12\x20\x01(\x05R\x06secret\x12&\n\
    \x0eshareQrcodeUri\x18\x13\x20\x01(\tR\x0eshareQrcodeUri\x125\n\x0ebadge\
    ImageList\x18\x15\x20\x03(\x0b2\r.TikTok.ImageR\x0ebadgeImageList\x127\n\
    \nfollowInfo\x18\x16\x20\x01(\x0b2\x17.TikTok.User.FollowInfoR\nfollowIn\
    fo\x121\n\x08payGrade\x18\x17\x20\x01(\x0b2\x15.TikTok.User.PayGradeR\
    \x08payGrade\x121\n\x08fansClub\x18\x18\x20\x01(\x0b2\x15.TikTok.User.Fa\
    nsClubR\x08fansClub\x12+\n\x06border\x18\x19\x20\x01(\x0b2\x13.TikTok.Us\
    er.BorderR\x06border\x12\x1c\n\tspecialId\x18\x1a\x20\x01(\tR\tspecialId\
    \x121\n\x0cavatarBorder\x18\x1b\x20\x01(\x0b2\r.TikTok.ImageR\x0cavatarB\
    order\x12#\n\x05medal\x18\x1c\x20\x01(\x0b2\r.TikTok.ImageR\x05medal\x12\
    ;\n\x11realTimeIconsList\x18\x1d\x20\x03(\x0b2\r.TikTok.ImageR\x11realTi\
    meIconsList\x12A\n\x14newRealTimeIconsList\x18\x1e\x20\x03(\x0b2\r.TikTo\
    k.ImageR\x14newRealTimeIconsList\x12\x1a\n\x08topVipNo\x18\x1f\x20\x01(\
    \x03R\x08topVipNo\x121\n\x08userAttr\x18\x20\x20\x01(\x0b2\x15.TikTok.Us\
    er.UserAttrR\x08userAttr\x12.\n\x07ownRoom\x18!\x20\x01(\x0b2\x14.TikTok\
    .User.OwnRoomR\x07ownRoom\x12\x1a\n\x08payScore\x18\"\x20\x01(\x03R\x08p\
    ayScore\x12\x20\n\x0bticketCount\x18#\x20\x01(\x03R\x0bticketCount\x129\
    \n\x0clinkMicStats\x18%\x20\x01(\x0e2\x15.TikTok.LinkmicStatusR\x0clinkM\
    icStats\x12\x1c\n\tdisplayId\x18&\x20\x01(\tR\tdisplayId\x126\n\x16withC\
    ommercePermission\x18'\x20\x01(\x08R\x16withCommercePermission\x120\n\
    \x13withFusionShopEntry\x18(\x20\x01(\x08R\x13withFusionShopEntry\x12H\n\
    \x12webcastAnchorLevel\x18*\x20\x01(\x0b2\x18.TikTok.User.AnchorLevelR\
    \x12webcastAnchorLevel\x12(\n\x0fverifiedContent\x18+\x20\x01(\tR\x0fver\
    ifiedContent\x12:\n\x0bauthorStats\x18,\x20\x01(\x0b2\x18.TikTok.User.Au\
    thorStatsR\x0bauthorStats\x12.\n\x0btopFansList\x18-\x20\x03(\x0b2\x0c.T\
    ikTok.UserR\x0btopFansList\x12\x16\n\x06secUid\x18.\x20\x01(\tR\x06secUi\
    d\x12\x1a\n\x08userRole\x18/\x20\x01(\x05R\x08userRole\x12A\n\x0eactivit\
    yReward\x181\x20\x01(\x0b2\x19.TikTok.User.ActivityInfoR\x0eactivityRewa\
    rd\x121\n\x0cpersonalCard\x184\x20\x01(\x0b2\r.TikTok.ImageR\x0cpersonal\
    Card\x12O\n\x12authenticationInfo\x185\x20\x01(\x0b2\x1f.TikTok.User.Aut\
    henticationInfoR\x12authenticationInfo\x12?\n\x13mediaBadgeImageList\x18\
    9\x20\x03(\x0b2\r.TikTok.ImageR\x13mediaBadgeImageList\x12B\n\x1ccommerc\
    eWebcastConfigIdsList\x18<\x20\x03(\x03R\x1ccommerceWebcastConfigIdsList\
    \x123\n\nborderList\x18=\x20\x03(\x0b2\x13.TikTok.User.BorderR\nborderLi\
    st\x12C\n\x0ecomboBadgeInfo\x18>\x20\x01(\x0b2\x1b.TikTok.User.ComboBadg\
    eInfoR\x0ecomboBadgeInfo\x12@\n\rsubscribeInfo\x18?\x20\x01(\x0b2\x1a.Ti\
    kTok.User.SubscribeInfoR\rsubscribeInfo\x121\n\tbadgeList\x18@\x20\x03(\
    \x0b2\x13.TikTok.BadgeStructR\tbadgeList\x12,\n\x11mintTypeLabelList\x18\
    A\x20\x03(\x03R\x11mintTypeLabelList\x12=\n\x0cfansClubInfo\x18B\x20\x01\
    (\x0b2\x19.TikTok.User.FansClubInfoR\x0cfansClubInfo\x121\n\x13allowFind\
    ByContacts\x18\xea\x07\x20\x01(\x08R\x13allowFindByContacts\x12;\n\x18al\
    lowOthersDownloadVideo\x18\xeb\x07\x20\x01(\x08R\x18allowOthersDownloadV\
    ideo\x12Q\n#allowOthersDownloadWhenSharingVideo\x18\xec\x07\x20\x01(\x08\
    R#allowOthersDownloadWhenSharingVideo\x125\n\x15allowShareShowProfile\
    \x18\xed\x07\x20\x01(\x08R\x15allowShareShowProfile\x12-\n\x11allowShowI\
    nGossip\x18\xee\x07\x20\x01(\x08R\x11allowShowInGossip\x12-\n\x11allowSh\
    owMyAction\x18\xef\x07\x20\x01(\x08R\x11allowShowMyAction\x121\n\x13allo\
    wStrangeComment\x18\xf0\x07\x20\x01(\x08R\x13allowStrangeComment\x127\n\
    \x16allowUnfollowerComment\x18\xf1\x07\x20\x01(\x08R\x16allowUnfollowerC\
    omment\x12)\n\x0fallowUseLinkmic\x18\xf2\x07\x20\x01(\x08R\x0fallowUseLi\
    nkmic\x12;\n\x0banchorLevel\x18\xf3\x07\x20\x01(\x0b2\x18.TikTok.User.An\
    chorLevelR\x0banchorLevel\x12,\n\tavatarJpg\x18\xf4\x07\x20\x01(\x0b2\r.\
    TikTok.ImageR\tavatarJpg\x12\x1b\n\x08bgImgUrl\x18\xf5\x07\x20\x01(\tR\
    \x08bgImgUrl\x12!\n\x0bblockStatus\x18\xf8\x07\x20\x01(\x05R\x0bblockSta\
    tus\x12)\n\x0fcommentRestrict\x18\xf9\x07\x20\x01(\x05R\x0fcommentRestri\
    ct\x12%\n\rconstellation\x18\xfa\x07\x20\x01(\tR\rconstellation\x12#\n\
    \x0cdisableIchat\x18\xfb\x07\x20\x01(\x05R\x0cdisableIchat\x12'\n\x0eena\
    bleIchatImg\x18\xfc\x07\x20\x01(\x03R\x0eenableIchatImg\x12\x11\n\x03exp\
    \x18\xfd\x07\x20\x01(\x05R\x03exp\x12'\n\x0efanTicketCount\x18\xfe\x07\
    \x20\x01(\x03R\x0efanTicketCount\x12+\n\x10foldStrangerChat\x18\xff\x07\
    \x20\x01(\x08R\x10foldStrangerChat\x12#\n\x0cfollowStatus\x18\x80\x08\
    \x20\x01(\x03R\x0cfollowStatus\x12-\n\x11ichatRestrictType\x18\x83\x08\
    \x20\x01(\x05R\x11ichatRestrictType\x12\x15\n\x05idStr\x18\x84\x08\x20\
    \x01(\tR\x05idStr\x12\x1f\n\nisFollower\x18\x85\x08\x20\x01(\x08R\nisFol\
    lower\x12!\n\x0bisFollowing\x18\x86\x08\x20\x01(\x08R\x0bisFollowing\x12\
    +\n\x10needProfileGuide\x18\x87\x08\x20\x01(\x08R\x10needProfileGuide\
    \x12\x1d\n\tpayScores\x18\x88\x08\x20\x01(\x03R\tpayScores\x12-\n\x11pus\
    hCommentStatus\x18\x89\x08\x20\x01(\x08R\x11pushCommentStatus\x12\x1b\n\
    \x08pushDigg\x18\x8a\x08\x20\x01(\x08R\x08pushDigg\x12\x1f\n\npushFollow\
    \x18\x8b\x08\x20\x01(\x08R\npushFollow\x12+\n\x10pushFriendAction\x18\
    \x8c\x08\x20\x01(\x08R\x10pushFriendAction\x12\x1d\n\tpushIchat\x18\x8d\
    \x08\x20\x01(\x08R\tpushIchat\x12\x1f\n\npushStatus\x18\x8e\x08\x20\x01(\
    \x08R\npushStatus\x12%\n\rpushVideoPost\x18\x8f\x08\x20\x01(\x08R\rpushV\
    ideoPost\x12/\n\x12pushVideoRecommend\x18\x90\x08\x20\x01(\x08R\x12pushV\
    ideoRecommend\x12-\n\x05stats\x18\x91\x08\x20\x01(\x0b2\x16.TikTok.User.\
    UserStatsR\x05stats\x12'\n\x0everifiedReason\x18\x93\x08\x20\x01(\tR\x0e\
    verifiedReason\x12A\n\x1bwithCarManagementPermission\x18\x94\x08\x20\x01\
    (\x08R\x1bwithCarManagementPermission\x12I\n\x11upcomingEventList\x18\
    \x95\x08\x20\x03(\x0b2\x1a.TikTok.User.LiveEventInfoR\x11upcomingEventLi\
    st\x12\x1b\n\x08scmLabel\x18\x96\x08\x20\x01(\tR\x08scmLabel\x12M\n\x11e\
    commerceEntrance\x18\x97\x08\x20\x01(\x0b2\x1e.TikTok.User.EcommerceEntr\
    anceR\x11ecommerceEntrance\x12\x19\n\x07isBlock\x18\x98\x08\x20\x01(\x08\
    R\x07isBlock\x1a\xce\x03\n\rLiveEventInfo\x12\x18\n\x07eventId\x18\x01\
    \x20\x01(\x03R\x07eventId\x12\x1c\n\tstartTime\x18\x02\x20\x01(\x03R\tst\
    artTime\x12\x1a\n\x08duration\x18\x03\x20\x01(\x03R\x08duration\x12\x14\
    \n\x05title\x18\x04\x20\x01(\tR\x05title\x12\x20\n\x0bdescription\x18\
    \x05\x20\x01(\tR\x0bdescription\x12$\n\rhasSubscribed\x18\x06\x20\x01(\
    \x08R\rhasSubscribed\x12\x20\n\x0bisPaidEvent\x18\x07\x20\x01(\x08R\x0bi\
    sPaidEvent\x12\"\n\x0cticketAmount\x18\x08\x20\x01(\x03R\x0cticketAmount\
    \x12\x1c\n\tpayMethod\x18\t\x20\x01(\x03R\tpayMethod\x1aI\n\rWalletPacka\
    ge\x12\x14\n\x05iapId\x18\x01\x20\x01(\tR\x05iapId\x12\"\n\x0cusdPriceSh\
    ow\x18\x02\x20\x01(\tR\x0cusdPriceShow\"\\\n\x0eEventPayMethod\x12\x19\n\
    \x15EVENTPAYMETHODINVALID\x10\0\x12\x17\n\x13EVENTPAYMETHODCOINS\x10\x01\
    \x12\x16\n\x12EVENTPAYMETHODCASH\x10\x02\x1a^\n\x0cActivityInfo\x12#\n\
    \x05badge\x18\x01\x20\x01(\x0b2\r.TikTok.ImageR\x05badge\x12)\n\x08story\
    tag\x18\x02\x20\x01(\x0b2\r.TikTok.ImageR\x08storytag\x1a\xfd\x04\n\x0bA\
    nchorLevel\x12\x14\n\x05level\x18\x01\x20\x01(\x03R\x05level\x12\x1e\n\n\
    experience\x18\x02\x20\x01(\x03R\nexperience\x12<\n\x19lowestExperienceT\
    hisLevel\x18\x03\x20\x01(\x03R\x19lowestExperienceThisLevel\x12>\n\x1ahi\
    ghestExperienceThisLevel\x18\x04\x20\x01(\x03R\x1ahighestExperienceThisL\
    evel\x120\n\x13taskStartExperience\x18\x05\x20\x01(\x03R\x13taskStartExp\
    erience\x12$\n\rtaskStartTime\x18\x06\x20\x01(\x03R\rtaskStartTime\x126\
    \n\x16taskDecreaseExperience\x18\x07\x20\x01(\x03R\x16taskDecreaseExperi\
    ence\x122\n\x14taskTargetExperience\x18\x08\x20\x01(\x03R\x14taskTargetE\
    xperience\x12\x20\n\x0btaskEndTime\x18\t\x20\x01(\x03R\x0btaskEndTime\
    \x127\n\x0fprofileDialogBg\x18\n\x20\x01(\x0b2\r.TikTok.ImageR\x0fprofil\
    eDialogBg\x12?\n\x13profileDialogBgBack\x18\x0b\x20\x01(\x0b2\r.TikTok.I\
    mageR\x13profileDialogBgBack\x12-\n\nstageLevel\x18\x0c\x20\x01(\x0b2\r.\
    TikTok.ImageR\nstageLevel\x12+\n\tsmallIcon\x18\r\x20\x01(\x0b2\r.TikTok\
    .ImageR\tsmallIcon\x1a\xb1\x01\n\x12AuthenticationInfo\x12\"\n\x0ccustom\
    Verify\x18\x01\x20\x01(\tR\x0ccustomVerify\x126\n\x16enterpriseVerifyRea\
    son\x18\x02\x20\x01(\tR\x16enterpriseVerifyReason\x12?\n\x13authenticati\
    onBadge\x18\x03\x20\x01(\x0b2\r.TikTok.ImageR\x13authenticationBadge\x1a\
    \xc1\x02\n\x0bAuthorStats\x12(\n\x0fvideoTotalCount\x18\x01\x20\x01(\x03\
    R\x0fvideoTotalCount\x120\n\x13videoTotalPlayCount\x18\x02\x20\x01(\x03R\
    \x13videoTotalPlayCount\x122\n\x14videoTotalShareCount\x18\x03\x20\x01(\
    \x03R\x14videoTotalShareCount\x124\n\x15videoTotalSeriesCount\x18\x04\
    \x20\x01(\x03R\x15videoTotalSeriesCount\x122\n\x14varietyShowPlayCount\
    \x18\x05\x20\x01(\x03R\x14varietyShowPlayCount\x128\n\x17videoTotalFavor\
    iteCount\x18\x06\x20\x01(\x03R\x17videoTotalFavoriteCount\x1a\x9a\x02\n\
    \x06Border\x12!\n\x04icon\x18\x01\x20\x01(\x0b2\r.TikTok.ImageR\x04icon\
    \x12\x14\n\x05level\x18\x02\x20\x01(\x03R\x05level\x12\x16\n\x06source\
    \x18\x03\x20\x01(\tR\x06source\x12G\n\x17profileDecorationRibbon\x18\x04\
    \x20\x01(\x0b2\r.TikTok.ImageR\x17profileDecorationRibbon\x124\n\x15avat\
    arBackgroundColor\x18\x07\x20\x01(\tR\x15avatarBackgroundColor\x12@\n\
    \x1bavatarBackgroundBorderColor\x18\x08\x20\x01(\tR\x1bavatarBackgroundB\
    orderColor\x1aS\n\x0eComboBadgeInfo\x12!\n\x04icon\x18\x01\x20\x01(\x0b2\
    \r.TikTok.ImageR\x04icon\x12\x1e\n\ncomboCount\x18\x02\x20\x01(\x03R\nco\
    mboCount\x1a\xaa\x0f\n\x11EcommerceEntrance\x12O\n\x0centranceType\x18\
    \x01\x20\x01(\x0e2+.TikTok.User.EcommerceEntrance.EntranceTypeR\x0centra\
    nceType\x12L\n\x0bcreatorType\x18\x02\x20\x01(\x0e2*.TikTok.User.Ecommer\
    ceEntrance.CreatorTypeR\x0bcreatorType\x12\x16\n\x06schema\x18\x03\x20\
    \x01(\tR\x06schema\x12[\n\x10shopEntranceInfo\x18\x04\x20\x01(\x0b2/.Tik\
    Tok.User.EcommerceEntrance.ShopEntranceInfoR\x10shopEntranceInfo\x12g\n\
    \x14showcaseEntranceInfo\x18\x05\x20\x01(\x0b23.TikTok.User.EcommerceEnt\
    rance.ShowcaseEntranceInfoR\x14showcaseEntranceInfo\x1a\xbe\n\n\x10ShopE\
    ntranceInfo\x12\x16\n\x06shopId\x18\x01\x20\x01(\tR\x06shopId\x12\x1a\n\
    \x08shopName\x18\x02\x20\x01(\tR\x08shopName\x12\x1e\n\nshopRating\x18\
    \x03\x20\x01(\tR\nshopRating\x12Z\n\nstoreLabel\x18\x04\x20\x01(\x0b2:.T\
    ikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabelR\nstoreLabel\
    \x12(\n\x0fformatSoldCount\x18\x05\x20\x01(\tR\x0fformatSoldCount\x12\
    \x1c\n\tsoldCount\x18\x06\x20\x01(\x03R\tsoldCount\x12,\n\x11expRatePerc\
    entile\x18\x07\x20\x01(\x05R\x11expRatePercentile\x12,\n\x11expRateTopDi\
    splay\x18\x08\x20\x01(\tR\x11expRateTopDisplay\x12*\n\x10rateDisplayStyl\
    e\x18\t\x20\x01(\x05R\x10rateDisplayStyle\x124\n\x15showRateNotApplicabl\
    e\x18\n\x20\x01(\x08R\x15showRateNotApplicable\x1a\xf3\x06\n\nStoreLabel\
    \x12s\n\rofficialLabel\x18\x01\x20\x01(\x0b2M.TikTok.User.EcommerceEntra\
    nce.ShopEntranceInfo.StoreLabel.StoreOfficialLabelR\rofficialLabel\x12\
    \x1e\n\nisBytemall\x18\x02\x20\x01(\x08R\nisBytemall\x1a\xc5\x04\n\x12St\
    oreOfficialLabel\x12\x86\x01\n\x0flabelImageLight\x18\x01\x20\x01(\x0b2\
    \\.TikTok.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOffici\
    alLabel.ShopLabelImageR\x0flabelImageLight\x12\x84\x01\n\x0elabelImageDa\
    rk\x18\x02\x20\x01(\x0b2\\.TikTok.User.EcommerceEntrance.ShopEntranceInf\
    o.StoreLabel.StoreOfficialLabel.ShopLabelImageR\x0elabelImageDark\x12\
    \x1c\n\tlabelType\x18\x03\x20\x01(\x03R\tlabelType\x12\"\n\x0clabelTypeS\
    tr\x18\x04\x20\x01(\tR\x0clabelTypeStr\x1a\xdc\x01\n\x0eShopLabelImage\
    \x12\x16\n\x06height\x18\x01\x20\x01(\x05R\x06height\x12\x14\n\x05width\
    \x18\x02\x20\x01(\x05R\x05width\x12\x1a\n\x08minetype\x18\x03\x20\x01(\t\
    R\x08minetype\x12\x1a\n\x08thumbUri\x18\x04\x20\x01(\tR\x08thumbUri\x12\
    \"\n\x0cthumbUriList\x18\x05\x20\x03(\tR\x0cthumbUriList\x12\x10\n\x03ur\
    i\x18\x06\x20\x01(\tR\x03uri\x12\x18\n\x07urlList\x18\x07\x20\x03(\tR\
    \x07urlList\x12\x14\n\x05color\x18\x08\x20\x01(\tR\x05color\"\x87\x01\n\
    \x13StoreBrandLabelType\x12\x08\n\x04NONE\x10\0\x12\x0c\n\x08OFFICIAL\
    \x10\x01\x12\x0e\n\nAUTHORIZED\x10\x02\x12!\n\x1dSTORE_BRAND_LABEL_TYPE_\
    BLUE_V\x10\x03\x12%\n!STORE_BRAND_LABEL_TYPE_TOP_CHOICE\x10\x04\x1a^\n\
    \x14ShowcaseEntranceInfo\x12(\n\x0fformatSoldCount\x18\x01\x20\x01(\tR\
    \x0fformatSoldCount\x12\x1c\n\tsoldCount\x18\x02\x20\x01(\x03R\tsoldCoun\
    t\"B\n\x0bCreatorType\x12\r\n\tUNDEFINED\x10\0\x12\x0c\n\x08OFFICIAL\x10\
    \x01\x12\n\n\x06MARKET\x10\x02\x12\n\n\x06NORMAL\x10\x03\"3\n\x0cEntranc\
    eType\x12\x0b\n\x07PROFILE\x10\0\x12\x0c\n\x08SHOWCASE\x10\x01\x12\x08\n\
    \x04SHOP\x10\x02\x1a\xe5\x03\n\x08FansClub\x126\n\x04data\x18\x01\x20\
    \x01(\x0b2\".TikTok.User.FansClub.FansClubDataR\x04data\x1a\xe9\x02\n\
    \x0cFansClubData\x12\x1a\n\x08clubName\x18\x01\x20\x01(\tR\x08clubName\
    \x12\x14\n\x05level\x18\x02\x20\x01(\x05R\x05level\x12e\n\x12userFansClu\
    bStatus\x18\x03\x20\x01(\x0e25.TikTok.User.FansClub.FansClubData.UserFan\
    sClubStatusR\x12userFansClubStatus\x122\n\x14availableGiftIdsList\x18\
    \x05\x20\x03(\x03R\x14availableGiftIdsList\x12\x1a\n\x08anchorId\x18\x06\
    \x20\x01(\x03R\x08anchorId\"1\n\tBadgeIcon\x12\x0b\n\x07UNKNOWN\x10\0\
    \x12\x08\n\x04ICON\x10\x01\x12\r\n\tSMALLICON\x10\x02\"=\n\x12UserFansCl\
    ubStatus\x12\r\n\tNOTJOINED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x0c\n\
    \x08INACTIVE\x10\x02\"5\n\x0fPreferntialType\x12\x13\n\x0fPRESONALPROFIL\
    E\x10\0\x12\r\n\tOTHERROOM\x10\x01\x1a\xad\x01\n\x0cFansClubInfo\x12\x1e\
    \n\nisSleeping\x18\x01\x20\x01(\x08R\nisSleeping\x12\x1c\n\tfansLevel\
    \x18\x02\x20\x01(\x03R\tfansLevel\x12\x1c\n\tfansScore\x18\x03\x20\x01(\
    \x03R\tfansScore\x12#\n\x05badge\x18\x04\x20\x01(\x0b2\r.TikTok.ImageR\
    \x05badge\x12\x1c\n\tfansCount\x18\x05\x20\x01(\x03R\tfansCount\x1a\x9e\
    \x01\n\nFollowInfo\x12&\n\x0efollowingCount\x18\x01\x20\x01(\x03R\x0efol\
    lowingCount\x12$\n\rfollowerCount\x18\x02\x20\x01(\x03R\rfollowerCount\
    \x12\"\n\x0cfollowStatus\x18\x03\x20\x01(\x03R\x0cfollowStatus\x12\x1e\n\
    \npushStatus\x18\x04\x20\x01(\x03R\npushStatus\x1aS\n\x07OwnRoom\x12\x20\
    \n\x0broomIdsList\x18\x01\x20\x03(\x03R\x0broomIdsList\x12&\n\x0eroomIds\
    StrList\x18\x02\x20\x03(\tR\x0eroomIdsStrList\x1a\xd7\x08\n\x08PayGrade\
    \x12/\n\x0bdiamondIcon\x18\x02\x20\x01(\x0b2\r.TikTok.ImageR\x0bdiamondI\
    con\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12!\n\x04icon\x18\x04\
    \x20\x01(\x0b2\r.TikTok.ImageR\x04icon\x12\x1a\n\x08nextName\x18\x05\x20\
    \x01(\tR\x08nextName\x12\x14\n\x05level\x18\x06\x20\x01(\x03R\x05level\
    \x12)\n\x08nextIcon\x18\x07\x20\x01(\x0b2\r.TikTok.ImageR\x08nextIcon\
    \x12$\n\rgradeDescribe\x18\r\x20\x01(\tR\rgradeDescribe\x12E\n\rgradeIco\
    nList\x18\x0e\x20\x03(\x0b2\x1f.TikTok.User.PayGrade.GradeIconR\rgradeIc\
    onList\x12&\n\x0escreenChatType\x18\x0f\x20\x01(\x03R\x0escreenChatType\
    \x12%\n\x06imIcon\x18\x10\x20\x01(\x0b2\r.TikTok.ImageR\x06imIcon\x127\n\
    \x0fimIconWithLevel\x18\x11\x20\x01(\x0b2\r.TikTok.ImageR\x0fimIconWithL\
    evel\x12)\n\x08liveIcon\x18\x12\x20\x01(\x0b2\r.TikTok.ImageR\x08liveIco\
    n\x12=\n\x12newImIconWithLevel\x18\x13\x20\x01(\x0b2\r.TikTok.ImageR\x12\
    newImIconWithLevel\x12/\n\x0bnewLiveIcon\x18\x14\x20\x01(\x0b2\r.TikTok.\
    ImageR\x0bnewLiveIcon\x12.\n\x12upgradeNeedConsume\x18\x15\x20\x01(\x03R\
    \x12upgradeNeedConsume\x12&\n\x0enextPrivileges\x18\x16\x20\x01(\tR\x0en\
    extPrivileges\x12-\n\nbackground\x18\x17\x20\x01(\x0b2\r.TikTok.ImageR\n\
    background\x125\n\x0ebackgroundBack\x18\x18\x20\x01(\x0b2\r.TikTok.Image\
    R\x0ebackgroundBack\x12\x14\n\x05score\x18\x19\x20\x01(\x03R\x05score\
    \x12!\n\x0bgradeBanner\x18\xe9\x07\x20\x01(\tR\x0bgradeBanner\x128\n\x0f\
    profileDialogBg\x18\xea\x07\x20\x01(\x0b2\r.TikTok.ImageR\x0fprofileDial\
    ogBg\x12@\n\x13profileDialogBgBack\x18\xeb\x07\x20\x01(\x0b2\r.TikTok.Im\
    ageR\x13profileDialogBgBack\x1a\x82\x01\n\tGradeIcon\x12!\n\x04icon\x18\
    \x01\x20\x01(\x0b2\r.TikTok.ImageR\x04icon\x12\x20\n\x0biconDiamond\x18\
    \x02\x20\x01(\x03R\x0biconDiamond\x12\x14\n\x05level\x18\x03\x20\x01(\
    \x03R\x05level\x12\x1a\n\x08levelStr\x18\x04\x20\x01(\tR\x08levelStr\x1a\
    l\n\x0eSubscribeBadge\x12+\n\toriginImg\x18\x03\x20\x01(\x0b2\r.TikTok.I\
    mageR\toriginImg\x12-\n\npreviewImg\x18\x04\x20\x01(\x0b2\r.TikTok.Image\
    R\npreviewImg\x1a\x9a\x03\n\rSubscribeInfo\x12$\n\rqualification\x18\x01\
    \x20\x01(\x08R\rqualification\x12\x20\n\x0bisSubscribe\x18\x02\x20\x01(\
    \x08R\x0bisSubscribe\x121\n\x05badge\x18\x03\x20\x01(\x0b2\x1b.TikTok.Us\
    er.SubscribeBadgeR\x05badge\x12.\n\x12enableSubscription\x18\x04\x20\x01\
    (\x08R\x12enableSubscription\x12(\n\x0fsubscriberCount\x18\x05\x20\x01(\
    \x03R\x0fsubscriberCount\x12(\n\x0fisInGracePeriod\x18\x06\x20\x01(\x08R\
    \x0fisInGracePeriod\x122\n\x14isSubscribedToAnchor\x18\x07\x20\x01(\x08R\
    \x14isSubscribedToAnchor\x12(\n\x0fuserGiftSubAuth\x18\t\x20\x01(\x08R\
    \x0fuserGiftSubAuth\x12,\n\x11anchorGiftSubAuth\x18\n\x20\x01(\x08R\x11a\
    nchorGiftSubAuth\x1a\x86\x01\n\x08UserAttr\x12\x18\n\x07isMuted\x18\x01\
    \x20\x01(\x08R\x07isMuted\x12\x18\n\x07isAdmin\x18\x02\x20\x01(\x08R\x07\
    isAdmin\x12\"\n\x0cisSuperAdmin\x18\x03\x20\x01(\x08R\x0cisSuperAdmin\
    \x12\"\n\x0cmuteDuration\x18\x04\x20\x01(\x03R\x0cmuteDuration\x1a\xc3\
    \x03\n\tUserStats\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x14\n\
    \x05idStr\x18\x02\x20\x01(\tR\x05idStr\x12&\n\x0efollowingCount\x18\x03\
    \x20\x01(\x03R\x0efollowingCount\x12$\n\rfollowerCount\x18\x04\x20\x01(\
    \x03R\rfollowerCount\x12\x20\n\x0brecordCount\x18\x05\x20\x01(\x03R\x0br\
    ecordCount\x12$\n\rtotalDuration\x18\x06\x20\x01(\x03R\rtotalDuration\
    \x120\n\x13dailyFanTicketCount\x18\x07\x20\x01(\x03R\x13dailyFanTicketCo\
    unt\x12\x20\n\x0bdailyIncome\x18\x08\x20\x01(\x03R\x0bdailyIncome\x12\
    \x1c\n\titemCount\x18\t\x20\x01(\x03R\titemCount\x12,\n\x11favoriteItemC\
    ount\x18\n\x20\x01(\x03R\x11favoriteItemCount\x122\n\x14diamondConsumedC\
    ount\x18\x0c\x20\x01(\x03R\x14diamondConsumedCount\x12&\n\x0etuwenItemCo\
    unt\x18\r\x20\x01(\x03R\x0etuwenItemCount\"\xc5\x02\n\x05Emote\x12\x18\n\
    \x07emoteId\x18\x01\x20\x01(\tR\x07emoteId\x12#\n\x05image\x18\x02\x20\
    \x01(\x0b2\r.TikTok.ImageR\x05image\x125\n\x0bauditStatus\x18\x03\x20\
    \x01(\x0e2\x13.TikTok.AuditStatusR\x0bauditStatus\x12\x12\n\x04uuid\x18\
    \x04\x20\x01(\tR\x04uuid\x12/\n\temoteType\x18\x05\x20\x01(\x0e2\x11.Tik\
    Tok.EmoteTypeR\temoteType\x12;\n\rcontentSource\x18\x06\x20\x01(\x0e2\
    \x15.TikTok.ContentSourceR\rcontentSource\x12D\n\x10emotePrivateType\x18\
    \x07\x20\x01(\x0e2\x18.TikTok.EmotePrivateTypeR\x10emotePrivateType\"\
    \xd5\x01\n\x0fPunishEventInfo\x12\x1e\n\npunishType\x18\x01\x20\x01(\tR\
    \npunishType\x12\"\n\x0cpunishReason\x18\x02\x20\x01(\tR\x0cpunishReason\
    \x12\x1a\n\x08punishId\x18\x03\x20\x01(\tR\x08punishId\x12\"\n\x0cviolat\
    ionUid\x18\x04\x20\x01(\x03R\x0cviolationUid\x12\"\n\x0cpunishTypeId\x18\
    \x05\x20\x01(\x05R\x0cpunishTypeId\x12\x1a\n\x08duration\x18\x06\x20\x01\
    (\x03R\x08duration\"[\n\tMsgFilter\x12\x1a\n\x08isGifter\x18\x01\x20\x01\
    (\x08R\x08isGifter\x122\n\x14isSubscribedToAnchor\x18\x02\x20\x01(\x08R\
    \x14isSubscribedToAnchor\"\xb4\x02\n\x0cUserIdentity\x120\n\x13isGiftGiv\
    erOfAnchor\x18\x01\x20\x01(\x08R\x13isGiftGiverOfAnchor\x122\n\x14isSubs\
    criberOfAnchor\x18\x02\x20\x01(\x08R\x14isSubscriberOfAnchor\x12@\n\x1bi\
    sMutualFollowingWithAnchor\x18\x03\x20\x01(\x08R\x1bisMutualFollowingWit\
    hAnchor\x12.\n\x12isFollowerOfAnchor\x18\x04\x20\x01(\x08R\x12isFollower\
    OfAnchor\x120\n\x13isModeratorOfAnchor\x18\x05\x20\x01(\x08R\x13isModera\
    torOfAnchor\x12\x1a\n\x08isAnchor\x18\x06\x20\x01(\x08R\x08isAnchor\"\
    \xe1\x06\n\x04Goal\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x20\n\
    \x0bdescription\x18\x05\x20\x01(\tR\x0bdescription\x12\x20\n\x0bauditSta\
    tus\x18\x06\x20\x01(\x05R\x0bauditStatus\x12\x1c\n\tstartTime\x18\x08\
    \x20\x01(\x03R\tstartTime\x12\x1e\n\nexpireTime\x18\t\x20\x01(\x03R\nexp\
    ireTime\x12&\n\x0erealFinishTime\x18\n\x20\x01(\x03R\x0erealFinishTime\
    \x12H\n\x10contributorsList\x18\x0b\x20\x03(\x0b2\x1c.TikTok.Goal.GoalCo\
    ntributorR\x10contributorsList\x12.\n\x12contributorsLength\x18\x0c\x20\
    \x01(\x05R\x12contributorsLength\x12\x14\n\x05idStr\x18\r\x20\x01(\tR\
    \x05idStr\x12*\n\x10auditDescription\x18\x0e\x20\x01(\tR\x10auditDescrip\
    tion\x12,\n\x05stats\x18\x0f\x20\x01(\x0b2\x16.TikTok.Goal.GoalStatsR\
    \x05stats\x1aW\n\tGoalStats\x12\x1e\n\ntotalCoins\x18\x01\x20\x01(\x03R\
    \ntotalCoins\x12*\n\x10totalContributor\x18\x02\x20\x01(\x03R\x10totalCo\
    ntributor\x1a\xdb\x02\n\x0fGoalContributor\x12\x16\n\x06userId\x18\x01\
    \x20\x01(\x03R\x06userId\x12%\n\x06avatar\x18\x02\x20\x01(\x0b2\r.TikTok\
    .ImageR\x06avatar\x12\x1c\n\tdisplayId\x18\x03\x20\x01(\tR\tdisplayId\
    \x12\x14\n\x05score\x18\x04\x20\x01(\x03R\x05score\x12\x1c\n\tuserIdStr\
    \x18\x05\x20\x01(\tR\tuserIdStr\x12\x16\n\x06inRoom\x18\x06\x20\x01(\x08\
    R\x06inRoom\x12\x1a\n\x08isFriend\x18\x07\x20\x01(\x08R\x08isFriend\x121\
    \n\tbadgeList\x18\x08\x20\x03(\x0b2\x13.TikTok.BadgeStructR\tbadgeList\
    \x12$\n\rfollowByOwner\x18\t\x20\x01(\x08R\rfollowByOwner\x12*\n\x10isFi\
    stContribute\x18\n\x20\x01(\x08R\x10isFistContribute\"-\n\tIndicator\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x0e\n\x02op\x18\x02\x20\x01\
    (\x03R\x02op\"\x8c\x01\n\x07Ranking\x12\x12\n\x04type\x18\x01\x20\x01(\t\
    R\x04type\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12)\n\x05colo\
    r\x18\x03\x20\x01(\x0b2\x13.TikTok.TikTokColorR\x05color\x12,\n\x07detai\
    ls\x18\x04\x20\x03(\x0b2\x12.TikTok.ValueLabelR\x07details\"I\n\x0bTikTo\
    kColor\x12\x14\n\x05color\x18\x01\x20\x01(\tR\x05color\x12\x0e\n\x02id\
    \x18\x04\x20\x01(\x04R\x02id\x12\x14\n\x05data1\x18\x06\x20\x01(\rR\x05d\
    ata1\"f\n\nValueLabel\x12\x12\n\x04data\x18\x01\x20\x01(\rR\x04data\x12\
    \x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12\x16\n\x06label2\x18\x03\
    \x20\x01(\tR\x06label2\x12\x16\n\x06label3\x18\x0b\x20\x01(\tR\x06label3\
    \"\x98\x01\n\x0eMessageDetails\x12\x14\n\x05data1\x18\x01\x20\x01(\rR\
    \x05data1\x12)\n\x05color\x18\x02\x20\x01(\x0b2\x13.TikTok.TikTokColorR\
    \x05color\x12\x1a\n\x08category\x18\x0b\x20\x01(\tR\x08category\x12)\n\
    \x04user\x18\x15\x20\x01(\x0b2\x15.TikTok.UserContainerR\x04user\"G\n\rU\
    serContainer\x12\x20\n\x04user\x18\x01\x20\x01(\x0b2\x0c.TikTok.UserR\
    \x04user\x12\x14\n\x05data1\x18\x02\x20\x01(\rR\x05data1\"\xd5\x01\n\rDa\
    taContainer\x12\x14\n\x05data1\x18\x01\x20\x01(\x04R\x05data1\x12\x14\n\
    \x05data2\x18\x02\x20\x01(\rR\x05data2\x12\x14\n\x05data3\x18\x03\x20\
    \x01(\rR\x05data3\x12\x14\n\x05data4\x18\x04\x20\x01(\rR\x05data4\x12\
    \x14\n\x05data5\x18\x05\x20\x01(\rR\x05data5\x12\x14\n\x05data6\x18\x06\
    \x20\x01(\rR\x05data6\x12\x14\n\x05data7\x18\x07\x20\x01(\rR\x05data7\
    \x12\x14\n\x05data8\x18\x08\x20\x01(\rR\x05data8\x12\x14\n\x05data9\x18\
    \t\x20\x01(\rR\x05data9\"t\n\x12TimeStampContainer\x12\x1e\n\ntimestamp1\
    \x18\x01\x20\x01(\x04R\ntimestamp1\x12\x1e\n\ntimestamp2\x18\x02\x20\x01\
    (\x04R\ntimestamp2\x12\x1e\n\ntimestamp3\x18\x03\x20\x01(\x04R\ntimestam\
    p3\"\x9a\x01\n\x11MemberMessageData\x12\x12\n\x04type\x18\x01\x20\x01(\t\
    R\x04type\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12)\n\x05colo\
    r\x18\x03\x20\x01(\x0b2\x13.TikTok.TikTokColorR\x05color\x120\n\x07detai\
    ls\x18\x04\x20\x03(\x0b2\x16.TikTok.MessageDetailsR\x07details\"\xd9\x01\
    \n\x12LinkMicArmiesItems\x12\x1e\n\nhostUserId\x18\x01\x20\x01(\x04R\nho\
    stUserId\x12Q\n\x0cbattleGroups\x18\x02\x20\x03(\x0b2-.TikTok.LinkMicArm\
    iesItems.LinkMicArmiesGroupR\x0cbattleGroups\x1aP\n\x12LinkMicArmiesGrou\
    p\x12\"\n\x05users\x18\x01\x20\x03(\x0b2\x0c.TikTok.UserR\x05users\x12\
    \x16\n\x06points\x18\x02\x20\x01(\rR\x06points\"\xc2\x01\n\x10PollStartC\
    ontent\x12\x1c\n\tStartTime\x18\x01\x20\x01(\x03R\tStartTime\x12\x18\n\
    \x07EndTime\x18\x02\x20\x01(\x03R\x07EndTime\x126\n\nOptionList\x18\x03\
    \x20\x03(\x0b2\x16.TikTok.PollOptionInfoR\nOptionList\x12\x14\n\x05Title\
    \x18\x04\x20\x01(\tR\x05Title\x12(\n\x08Operator\x18\x05\x20\x01(\x0b2\
    \x0c.TikTok.UserR\x08Operator\"\x8c\x01\n\x0ePollEndContent\x12\x18\n\
    \x07EndType\x18\x01\x20\x01(\x05R\x07EndType\x126\n\nOptionList\x18\x02\
    \x20\x03(\x0b2\x16.TikTok.PollOptionInfoR\nOptionList\x12(\n\x08Operator\
    \x18\x03\x20\x01(\x0b2\x0c.TikTok.UserR\x08Operator\"\xa2\x01\n\x0ePollO\
    ptionInfo\x12\x14\n\x05Votes\x18\x01\x20\x01(\x05R\x05Votes\x12&\n\x0eDi\
    splayContent\x18\x02\x20\x01(\tR\x0eDisplayContent\x12\x1c\n\tOptionIdx\
    \x18\x03\x20\x01(\x05R\tOptionIdx\x124\n\x0cVoteUserList\x18\x04\x20\x03\
    (\x0b2\x10.TikTok.VoteUserR\x0cVoteUserList\"o\n\x08VoteUser\x12\x16\n\
    \x06UserId\x18\x01\x20\x01(\x03R\x06UserId\x12\x1a\n\x08NickName\x18\x02\
    \x20\x01(\tR\x08NickName\x12/\n\x0bAvatarThumb\x18\x03\x20\x01(\x0b2\r.T\
    ikTok.ImageR\x0bAvatarThumb\"P\n\x16PollUpdateVotesContent\x126\n\nOptio\
    nList\x18\x02\x20\x03(\x0b2\x16.TikTok.PollOptionInfoR\nOptionList\"\x8d\
    \x01\n\rUserFanTicket\x12\x16\n\x06UserId\x18\x01\x20\x01(\x03R\x06UserI\
    d\x12\x1c\n\tFanTicket\x18\x02\x20\x01(\x03R\tFanTicket\x12(\n\x0fMatchT\
    otalScore\x18\x03\x20\x01(\x03R\x0fMatchTotalScore\x12\x1c\n\tMatchRank\
    \x18\x04\x20\x01(\x05R\tMatchRank\"\xfb\x01\n\x1aFanTicketRoomNoticeCont\
    ent\x12C\n\x11UserFanTicketList\x18\x01\x20\x03(\x0b2\x15.TikTok.UserFan\
    TicketR\x11UserFanTicketList\x124\n\x15TotalLinkMicFanTicket\x18\x02\x20\
    \x01(\x03R\x15TotalLinkMicFanTicket\x12\x18\n\x07MatchId\x18\x03\x20\x01\
    (\x03R\x07MatchId\x12\x1c\n\tEventTime\x18\x04\x20\x01(\x03R\tEventTime\
    \x12*\n\x10FanTicketIconUrl\x18\x05\x20\x01(\tR\x10FanTicketIconUrl\"w\n\
    \x19LinkerAcceptNoticeContent\x12\x1e\n\nfromUserId\x18\x01\x20\x01(\x03\
    R\nfromUserId\x12\x1e\n\nfromRoomId\x18\x02\x20\x01(\x03R\nfromRoomId\
    \x12\x1a\n\x08toUserId\x18\x03\x20\x01(\x03R\x08toUserId\"\x8d\x01\n\x13\
    LinkerCancelContent\x12\x1e\n\nfromUserId\x18\x01\x20\x01(\x03R\nfromUse\
    rId\x12\x1a\n\x08toUserId\x18\x02\x20\x01(\x03R\x08toUserId\x12\x1e\n\nc\
    ancelType\x18\x03\x20\x01(\x03R\ncancelType\x12\x1a\n\x08actionId\x18\
    \x04\x20\x01(\x03R\x08actionId\"\x9b\x03\n\x08ListUser\x12\x20\n\x04user\
    \x18\x01\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12\x1c\n\tlinkmicId\x18\
    \x02\x20\x01(\x03R\tlinkmicId\x12\"\n\x0clinkmicIdStr\x18\x03\x20\x01(\t\
    R\x0clinkmicIdStr\x12\x1e\n\nlinkStatus\x18\x04\x20\x01(\x03R\nlinkStatu\
    s\x125\n\x08linkType\x18\x05\x20\x01(\x0e2\x19.TikTok.ListUser.LinkTypeR\
    \x08linkType\x12\"\n\x0cuserPosition\x18\x06\x20\x01(\x05R\x0cuserPositi\
    on\x12$\n\rsilenceStatus\x18\x07\x20\x01(\x05R\rsilenceStatus\x12\x1e\n\
    \nmodifyTime\x18\x08\x20\x01(\x03R\nmodifyTime\x12\x1a\n\x08linkerId\x18\
    \t\x20\x01(\x03R\x08linkerId\x12\x1a\n\x08roleType\x18\n\x20\x01(\x05R\
    \x08roleType\"2\n\x08LinkType\x12\x10\n\x0cLINK_UNKNOWN\x10\0\x12\t\n\
    \x05AUDIO\x10\x01\x12\t\n\x05VIDEO\x10\x02\"\x14\n\x12LinkerCloseContent\
    \"m\n\x13LinkerCreateContent\x12\x18\n\x07ownerId\x18\x01\x20\x01(\x03R\
    \x07ownerId\x12\x20\n\x0bownerRoomId\x18\x02\x20\x01(\x03R\x0bownerRoomI\
    d\x12\x1a\n\x08linkType\x18\x03\x20\x01(\x03R\x08linkType\"\xd0\x01\n\
    \x12LinkerEnterContent\x12:\n\x0flinkedUsersList\x18\x01\x20\x03(\x0b2\
    \x10.TikTok.ListUserR\x0flinkedUsersList\x120\n\x13anchorMultiLiveEnum\
    \x18\x02\x20\x01(\x05R\x13anchorMultiLiveEnum\x12L\n\x11anchorSettingInf\
    o\x18\x03\x20\x01(\x0b2\x1e.TikTok.LinkmicUserSettingInfoR\x11anchorSett\
    ingInfo\"\xd9\x02\n\x13LinkerInviteContent\x12\x1e\n\nfromUserId\x18\x01\
    \x20\x01(\x03R\nfromUserId\x12\x1e\n\nfromRoomId\x18\x02\x20\x01(\x03R\n\
    fromRoomId\x12\"\n\x0ctoRtcExtInfo\x18\x03\x20\x01(\tR\x0ctoRtcExtInfo\
    \x12&\n\x0ertcJoinChannel\x18\x04\x20\x01(\x08R\x0ertcJoinChannel\x12\
    \x16\n\x06vendor\x18\x05\x20\x01(\x03R\x06vendor\x12$\n\rsecFromUserId\
    \x18\x06\x20\x01(\tR\rsecFromUserId\x12&\n\x0etoLinkmicIdStr\x18\x07\x20\
    \x01(\tR\x0etoLinkmicIdStr\x12(\n\x08fromUser\x18\x08\x20\x01(\x0b2\x0c.\
    TikTok.UserR\x08fromUser\x12&\n\x0erequiredMicIdx\x18\t\x20\x01(\x03R\
    \x0erequiredMicIdx\"s\n\x14LinkerKickOutContent\x12\x1e\n\nfromUserId\
    \x18\x01\x20\x01(\x03R\nfromUserId\x12;\n\rkickoutReason\x18\x02\x20\x01\
    (\x0e2\x15.TikTok.KickoutReasonR\rkickoutReason\"\x96\x01\n\x12LinkerLea\
    veContent\x12\x16\n\x06userId\x18\x01\x20\x01(\x03R\x06userId\x12\"\n\
    \x0clinkmicIdStr\x18\x02\x20\x01(\tR\x0clinkmicIdStr\x12\"\n\x0csendLeav\
    eUid\x18\x03\x20\x01(\x03R\x0csendLeaveUid\x12\x20\n\x0bleaveReason\x18\
    \x04\x20\x01(\x03R\x0bleaveReason\"\x1f\n\x1dLinkerLinkedListChangeConte\
    nt\"\x19\n\x17CohostListChangeContent\"\xd7\x01\n\x17LinkerListChangeCon\
    tent\x12:\n\x0flinkedUsersList\x18\x01\x20\x03(\x0b2\x10.TikTok.ListUser\
    R\x0flinkedUsersList\x12<\n\x10appliedUsersList\x18\x02\x20\x03(\x0b2\
    \x10.TikTok.ListUserR\x10appliedUsersList\x12B\n\x13connectingUsersList\
    \x18\x03\x20\x03(\x0b2\x10.TikTok.ListUserR\x13connectingUsersList\"\x9c\
    \x01\n\x18LinkerMediaChangeContent\x12\x0e\n\x02op\x18\x01\x20\x01(\x03R\
    \x02op\x12\x1a\n\x08toUserId\x18\x02\x20\x01(\x03R\x08toUserId\x12\x1a\n\
    \x08anchorId\x18\x03\x20\x01(\x03R\x08anchorId\x12\x16\n\x06roomId\x18\
    \x04\x20\x01(\x03R\x06roomId\x12\x20\n\x0bchangeScene\x18\x05\x20\x01(\
    \x03R\x0bchangeScene\"\x1b\n\x19LinkerMicIdxUpdateContent\"C\n\x11Linker\
    MuteContent\x12\x16\n\x06userId\x18\x01\x20\x01(\x03R\x06userId\x12\x16\
    \n\x06status\x18\x02\x20\x01(\x03R\x06status\"\xb6\x01\n\x18LinkerRandom\
    MatchContent\x12\x20\n\x04user\x18\x01\x20\x01(\x0b2\x0c.TikTok.UserR\
    \x04user\x12\x16\n\x06roomId\x18\x02\x20\x01(\x03R\x06roomId\x12\x1e\n\n\
    inviteType\x18\x03\x20\x01(\x03R\ninviteType\x12\x18\n\x07matchId\x18\
    \x04\x20\x01(\tR\x07matchId\x12&\n\x0einnerChannelId\x18\x05\x20\x01(\
    \x03R\x0einnerChannelId\"\x93\x06\n\x12LinkerReplyContent\x12\x1e\n\nfro\
    mUserId\x18\x01\x20\x01(\x03R\nfromUserId\x12\x1e\n\nfromRoomId\x18\x02\
    \x20\x01(\x03R\nfromRoomId\x12X\n\x13fromUserLinkmicInfo\x18\x03\x20\x01\
    (\x0b2&.TikTok.LinkerReplyContent.LinkmicInfoR\x13fromUserLinkmicInfo\
    \x12\x1a\n\x08toUserId\x18\x04\x20\x01(\x03R\x08toUserId\x12T\n\x11toUse\
    rLinkmicInfo\x18\x05\x20\x01(\x0b2&.TikTok.LinkerReplyContent.LinkmicInf\
    oR\x11toUserLinkmicInfo\x12\x1a\n\x08linkType\x18\x06\x20\x01(\x03R\x08l\
    inkType\x12\x20\n\x0breplyStatus\x18\x07\x20\x01(\x03R\x0breplyStatus\
    \x12;\n\rlinkerSetting\x18\x08\x20\x01(\x0b2\x15.TikTok.LinkerSettingR\r\
    linkerSetting\x12(\n\x08fromUser\x18\t\x20\x01(\x0b2\x0c.TikTok.UserR\
    \x08fromUser\x12$\n\x06toUser\x18\n\x20\x01(\x0b2\x0c.TikTok.UserR\x06to\
    User\x1a\xa5\x02\n\x0bLinkmicInfo\x12\x1c\n\taccessKey\x18\x01\x20\x01(\
    \tR\taccessKey\x12\x1c\n\tlinkMicId\x18\x02\x20\x01(\x03R\tlinkMicId\x12\
    \x1a\n\x08joinable\x18\x03\x20\x01(\x08R\x08joinable\x12&\n\x0econfluenc\
    eType\x18\x04\x20\x01(\x05R\x0econfluenceType\x12\x1e\n\nrtcExtInfo\x18\
    \x05\x20\x01(\tR\nrtcExtInfo\x12\x1a\n\x08rtcAppId\x18\x06\x20\x01(\tR\
    \x08rtcAppId\x12\x1e\n\nrtcAppSign\x18\x07\x20\x01(\tR\nrtcAppSign\x12\"\
    \n\x0clinkmicIdStr\x18\x08\x20\x01(\tR\x0clinkmicIdStr\x12\x16\n\x06vend\
    or\x18\t\x20\x01(\x03R\x06vendor\"\xc5\x01\n\rLinkerSetting\x12&\n\x0eMa\
    xMemberLimit\x18\x01\x20\x01(\x03R\x0eMaxMemberLimit\x12\x1a\n\x08LinkTy\
    pe\x18\x02\x20\x01(\x03R\x08LinkType\x12\x14\n\x05Scene\x18\x03\x20\x01(\
    \x03R\x05Scene\x12\x20\n\x0bOwnerUserId\x18\x04\x20\x01(\x03R\x0bOwnerUs\
    erId\x12\x20\n\x0bOwnerRoomId\x18\x05\x20\x01(\x03R\x0bOwnerRoomId\x12\
    \x16\n\x06Vendor\x18\x06\x20\x01(\x03R\x06Vendor\"U\n\x17LinkerSysKickOu\
    tContent\x12\x16\n\x06userId\x18\x01\x20\x01(\x03R\x06userId\x12\"\n\x0c\
    linkmicIdStr\x18\x02\x20\x01(\tR\x0clinkmicIdStr\"y\n\x17LinkmicUserToas\
    tContent\x12\x16\n\x06userId\x18\x01\x20\x01(\x03R\x06userId\x12\x16\n\
    \x06roomId\x18\x02\x20\x01(\x03R\x06roomId\x12.\n\x0bdisplayText\x18\x03\
    \x20\x01(\x0b2\x0c.TikTok.TextR\x0bdisplayText\"U\n\x17LinkerUpdateUserC\
    ontent\x12\x1e\n\nfromUserId\x18\x01\x20\x01(\x03R\nfromUserId\x12\x1a\n\
    \x08toUserId\x18\x02\x20\x01(\x03R\x08toUserId\"\x20\n\x1eLinkerUpdateUs\
    erSettingContent\"\x20\n\x1eLinkerWaitingListChangeContent\"\xb1\x02\n\
    \x16LinkmicUserSettingInfo\x12\x16\n\x06userId\x18\x01\x20\x01(\x03R\x06\
    userId\x12\x16\n\x06layout\x18\x02\x20\x01(\x03R\x06layout\x12\x1c\n\tfi\
    xMicNum\x18\x03\x20\x01(\x03R\tfixMicNum\x122\n\x14allowRequestFromUser\
    \x18\x04\x20\x01(\x03R\x14allowRequestFromUser\x12B\n\x1callowRequestFro\
    mFollowerOnly\x18\x05\x20\x01(\x03R\x1callowRequestFromFollowerOnly\x12Q\
    \n\x12applierSortSetting\x18\x07\x20\x01(\x0e2!.TikTok.LinkmicApplierSor\
    tSettingR\x12applierSortSetting\"8\n\x06Player\x12\x16\n\x06roomId\x18\
    \x01\x20\x01(\x03R\x06roomId\x12\x16\n\x06userId\x18\x02\x20\x01(\x03R\
    \x06userId\"\xfb\x01\n\x0bAllListUser\x129\n\nlinkedList\x18\x02\x20\x03\
    (\x0b2\x19.TikTok.LinkLayerListUserR\nlinkedList\x12;\n\x0bappliedList\
    \x18\x03\x20\x03(\x0b2\x19.TikTok.LinkLayerListUserR\x0bappliedList\x12;\
    \n\x0binvitedList\x18\x04\x20\x03(\x0b2\x19.TikTok.LinkLayerListUserR\
    \x0binvitedList\x127\n\treadyList\x18\x05\x20\x03(\x0b2\x19.TikTok.LinkL\
    ayerListUserR\treadyList\"\xe3\x01\n\x11LinkLayerListUser\x12\x20\n\x04u\
    ser\x18\x01\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12\x1c\n\tlinkmicId\
    \x18\x02\x20\x01(\x03R\tlinkmicId\x12\"\n\x03pos\x18\x03\x20\x01(\x0b2\
    \x10.TikTok.PositionR\x03pos\x12&\n\x0elinkedTimeNano\x18\x04\x20\x01(\
    \x03R\x0elinkedTimeNano\x12\x1e\n\nappVersion\x18\x05\x20\x01(\tR\nappVe\
    rsion\x12\"\n\x0cmagicNumber1\x18\x07\x20\x01(\x03R\x0cmagicNumber1\"H\n\
    \x08Position\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12(\n\x04l\
    ink\x18\x02\x20\x01(\x0b2\x14.TikTok.LinkPositionR\x04link\"<\n\x0cLinkP\
    osition\x12\x1a\n\x08position\x18\x01\x20\x01(\x05R\x08position\x12\x10\
    \n\x03opt\x18\x02\x20\x01(\x05R\x03opt\"M\n\x0bGroupPlayer\x12\x1c\n\tch\
    annelId\x18\x01\x20\x01(\x03R\tchannelId\x12\x20\n\x04user\x18\x02\x20\
    \x01(\x0b2\x0c.TikTok.UserR\x04user\"K\n\tDSLConfig\x12\"\n\x0csceneVers\
    ion\x18\x01\x20\x01(\x05R\x0csceneVersion\x12\x1a\n\x08layoutId\x18\x02\
    \x20\x01(\tR\x08layoutId\"s\n\x13GroupChannelAllUser\x12&\n\x0egroupChan\
    nelId\x18\x01\x20\x01(\x03R\x0egroupChannelId\x124\n\x08userList\x18\x02\
    \x20\x03(\x0b2\x18.TikTok.GroupChannelUserR\x08userList\"\xa1\x02\n\x10G\
    roupChannelUser\x12\x1c\n\tchannelId\x18\x01\x20\x01(\x03R\tchannelId\
    \x12+\n\x06status\x18\x02\x20\x01(\x0e2\x13.TikTok.GroupStatusR\x06statu\
    s\x12$\n\x04type\x18\x03\x20\x01(\x0e2\x10.TikTok.TextTypeR\x04type\x12-\
    \n\x07allUser\x18\x04\x20\x01(\x0b2\x13.TikTok.AllListUserR\x07allUser\
    \x12\x1a\n\x08joinTime\x18\x05\x20\x01(\x03R\x08joinTime\x12\x1e\n\nlink\
    edTime\x18\x06\x20\x01(\x03R\nlinkedTime\x121\n\townerUser\x18\x07\x20\
    \x01(\x0b2\x13.TikTok.GroupPlayerR\townerUser\"\xc7\x06\n\x0cRTCExtraInf\
    o\x12V\n\x13liveRtcEngineConfig\x18\x01\x20\x01(\x0b2$.TikTok.RTCExtraIn\
    fo.RTCEngineConfigR\x13liveRtcEngineConfig\x12\\\n\x15liveRtcVideoParamL\
    ist\x18\x02\x20\x03(\x0b2&.TikTok.RTCExtraInfo.RTCLiveVideoParamR\x15liv\
    eRtcVideoParamList\x12H\n\rrtcBitrateMap\x18\x03\x20\x01(\x0b2\".TikTok.\
    RTCExtraInfo.RTCBitrateMapR\rrtcBitrateMap\x12\x16\n\x06rtcFps\x18\x04\
    \x20\x01(\x05R\x06rtcFps\x12$\n\rrtcBusinessId\x18\x08\x20\x01(\tR\rrtcB\
    usinessId\x12.\n\x12interactClientType\x18\n\x20\x01(\x05R\x12interactCl\
    ientType\x1a\x8b\x01\n\x0fRTCEngineConfig\x12\x1a\n\x08rtcAppId\x18\x01\
    \x20\x01(\tR\x08rtcAppId\x12\x1c\n\trtcUserId\x18\x02\x20\x01(\tR\trtcUs\
    erId\x12\x1a\n\x08rtcToken\x18\x03\x20\x01(\tR\x08rtcToken\x12\"\n\x0crt\
    cChannelId\x18\x04\x20\x01(\x03R\x0crtcChannelId\x1ao\n\x11RTCLiveVideoP\
    aram\x12\x1e\n\nstrategyId\x18\x01\x20\x01(\x05R\nstrategyId\x12:\n\x06p\
    arams\x18\x02\x20\x01(\x0b2\".TikTok.RTCExtraInfo.RTCVideoParamR\x06para\
    ms\x1aq\n\rRTCVideoParam\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05wid\
    th\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\x12\x10\n\x03fps\
    \x18\x03\x20\x01(\x05R\x03fps\x12\x20\n\x0bbitrateKbps\x18\x04\x20\x01(\
    \x05R\x0bbitrateKbps\x1aW\n\rRTCBitrateMap\x12\x10\n\x03xx1\x18\x01\x20\
    \x01(\x05R\x03xx1\x12\x10\n\x03xx2\x18\x02\x20\x01(\x05R\x03xx2\x12\x10\
    \n\x03xx3\x18\x03\x20\x01(\x05R\x03xx3\x12\x10\n\x03xx4\x18\x04\x20\x01(\
    \x05R\x03xx4\"d\n\x14CreateChannelContent\x12$\n\x05owner\x18\x01\x20\
    \x01(\x0b2\x0e.TikTok.PlayerR\x05owner\x12&\n\x0eownerLinkMicId\x18\x02\
    \x20\x01(\tR\x0eownerLinkMicId\"b\n\x11ListChangeContent\x12$\n\x04type\
    \x18\x01\x20\x01(\x0e2\x10.TikTok.TextTypeR\x04type\x12'\n\x04list\x18\
    \x02\x20\x01(\x0b2\x13.TikTok.AllListUserR\x04list\"\xf4\t\n\x10MultiLiv\
    eContent\x12U\n\x10inviteBizContent\x18\x02\x20\x01(\x0b2).TikTok.MultiL\
    iveContent.InviteBizContentR\x10inviteBizContent\x12R\n\x0freplyBizConte\
    nt\x18\x03\x20\x01(\x0b2(.TikTok.MultiLiveContent.ReplyBizContentR\x0fre\
    plyBizContent\x12U\n\x10permitBizContent\x18\x04\x20\x01(\x0b2).TikTok.M\
    ultiLiveContent.PermitBizContentR\x10permitBizContent\x12X\n\x11kickOutB\
    izContent\x18\x06\x20\x01(\x0b2*.TikTok.MultiLiveContent.KickOutBizConte\
    ntR\x11kickOutBizContent\x1a\xac\x02\n\x10InviteBizContent\x12L\n\x11anc\
    horSettingInfo\x18\x01\x20\x01(\x0b2\x1e.TikTok.LinkmicUserSettingInfoR\
    \x11anchorSettingInfo\x12\"\n\x0cinviteSource\x18\x02\x20\x01(\x03R\x0ci\
    nviteSource\x128\n\x10operatorUserInfo\x18\x03\x20\x01(\x0b2\x0c.TikTok.\
    UserR\x10operatorUserInfo\x124\n\x15operatorLinkAdminType\x18\x04\x20\
    \x01(\x03R\x15operatorLinkAdminType\x126\n\x0finviteeUserInfo\x18\x05\
    \x20\x01(\x0b2\x0c.TikTok.UserR\x0finviteeUserInfo\x1a\x93\x01\n\x0fRepl\
    yBizContent\x12\x1a\n\x08linkType\x18\x01\x20\x01(\x05R\x08linkType\x120\
    \n\x13isTurnOffInvitation\x18\x02\x20\x01(\x05R\x13isTurnOffInvitation\
    \x122\n\rreplyUserInfo\x18\x03\x20\x01(\x0b2\x0c.TikTok.UserR\rreplyUser\
    Info\x1a\xfa\x01\n\x10PermitBizContent\x12L\n\x11anchorSettingInfo\x18\
    \x01\x20\x01(\x0b2\x1e.TikTok.LinkmicUserSettingInfoR\x11anchorSettingIn\
    fo\x12(\n\x0fexpireTimestamp\x18\x02\x20\x01(\x03R\x0fexpireTimestamp\
    \x128\n\x10operatorUserInfo\x18\x03\x20\x01(\x0b2\x0c.TikTok.UserR\x10op\
    eratorUserInfo\x124\n\x15operatorLinkAdminType\x18\x04\x20\x01(\x03R\x15\
    operatorLinkAdminType\x1a\xc1\x01\n\x11KickOutBizContent\x128\n\x10opera\
    torUserInfo\x18\x01\x20\x01(\x0b2\x0c.TikTok.UserR\x10operatorUserInfo\
    \x124\n\x15operatorLinkAdminType\x18\x02\x20\x01(\x03R\x15operatorLinkAd\
    minType\x12<\n\x12kickPlayerUserInfo\x18\x03\x20\x01(\x0b2\x0c.TikTok.Us\
    erR\x12kickPlayerUserInfo\"\x8a\x03\n\rInviteContent\x12(\n\x07invitor\
    \x18\x01\x20\x01(\x0b2\x0e.TikTok.PlayerR\x07invitor\x12B\n\x11inviteeRt\
    cExtInfo\x18\x02\x20\x01(\x0b2\x14.TikTok.RTCExtraInfoR\x11inviteeRtcExt\
    Info\x12*\n\x10invitorLinkMicId\x18\x03\x20\x01(\tR\x10invitorLinkMicId\
    \x12*\n\x10inviteeLinkMicId\x18\x04\x20\x01(\tR\x10inviteeLinkMicId\x12\
    \x18\n\x07isOwner\x18\x05\x20\x01(\x08R\x07isOwner\x12\"\n\x03pos\x18\
    \x06\x20\x01(\x0b2\x10.TikTok.PositionR\x03pos\x12#\n\x03dsl\x18\x07\x20\
    \x01(\x0b2\x11.TikTok.DSLConfigR\x03dsl\x12&\n\x07invitee\x18\x08\x20\
    \x01(\x0b2\x0c.TikTok.UserR\x07invitee\x12(\n\x08operator\x18\t\x20\x01(\
    \x0b2\x0c.TikTok.UserR\x08operator\"d\n\x0cApplyContent\x12(\n\x07applie\
    r\x18\x01\x20\x01(\x0b2\x0e.TikTok.PlayerR\x07applier\x12*\n\x10applierL\
    inkMicId\x18\x02\x20\x01(\tR\x10applierLinkMicId\"\xfa\x02\n\x12PermitAp\
    plyContent\x12*\n\x08permiter\x18\x01\x20\x01(\x0b2\x0e.TikTok.PlayerR\
    \x08permiter\x12,\n\x11permiterLinkMicId\x18\x02\x20\x01(\tR\x11permiter\
    LinkMicId\x120\n\napplierPos\x18\x03\x20\x01(\x0b2\x10.TikTok.PositionR\
    \napplierPos\x125\n\x0breplyStatus\x18\x04\x20\x01(\x0e2\x13.TikTok.Repl\
    yStatusR\x0breplyStatus\x12#\n\x03dsl\x18\x05\x20\x01(\x0b2\x11.TikTok.D\
    SLConfigR\x03dsl\x12&\n\x07applier\x18\x06\x20\x01(\x0b2\x0c.TikTok.User\
    R\x07applier\x12(\n\x08operator\x18\x07\x20\x01(\x0b2\x0c.TikTok.UserR\
    \x08operator\x12*\n\x10applierLinkMicId\x18\x08\x20\x01(\tR\x10applierLi\
    nkMicId\"\x93\x02\n\x12ReplyInviteContent\x12(\n\x07invitee\x18\x01\x20\
    \x01(\x0b2\x0e.TikTok.PlayerR\x07invitee\x125\n\x0breplyStatus\x18\x02\
    \x20\x01(\x0e2\x13.TikTok.ReplyStatusR\x0breplyStatus\x12*\n\x10inviteeL\
    inkMicId\x18\x03\x20\x01(\tR\x10inviteeLinkMicId\x120\n\ninviteePos\x18\
    \x04\x20\x01(\x0b2\x10.TikTok.PositionR\ninviteePos\x12>\n\x12inviteOper\
    atorUser\x18\x05\x20\x01(\x0b2\x0e.TikTok.PlayerR\x12inviteOperatorUser\
    \"y\n\x0eKickOutContent\x12*\n\x08offliner\x18\x01\x20\x01(\x0b2\x0e.Tik\
    Tok.PlayerR\x08offliner\x12;\n\rkickoutReason\x18\x02\x20\x01(\x0e2\x15.\
    TikTok.KickoutReasonR\rkickoutReason\"j\n\x12CancelApplyContent\x12(\n\
    \x07applier\x18\x01\x20\x01(\x0b2\x0e.TikTok.PlayerR\x07applier\x12*\n\
    \x10applierLinkMicId\x18\x02\x20\x01(\tR\x10applierLinkMicId\"\xe3\x01\n\
    \x13CancelInviteContent\x12(\n\x07invitor\x18\x01\x20\x01(\x0b2\x0e.TikT\
    ok.PlayerR\x07invitor\x12*\n\x10invitorLinkMicId\x18\x02\x20\x01(\tR\x10\
    invitorLinkMicId\x12*\n\x10inviteeLinkMicId\x18\x03\x20\x01(\tR\x10invit\
    eeLinkMicId\x12\x20\n\x0binviteSeqId\x18\x04\x20\x01(\x03R\x0binviteSeqI\
    d\x12(\n\x07invitee\x18\x05\x20\x01(\x0b2\x0e.TikTok.PlayerR\x07invitee\
    \"X\n\x0cLeaveContent\x12&\n\x06leaver\x18\x01\x20\x01(\x0b2\x0e.TikTok.\
    PlayerR\x06leaver\x12\x20\n\x0bleaveReason\x18\x02\x20\x01(\x03R\x0bleav\
    eReason\"`\n\x14FinishChannelContent\x12$\n\x05owner\x18\x01\x20\x01(\
    \x0b2\x0e.TikTok.PlayerR\x05owner\x12\"\n\x0cfinishReason\x18\x02\x20\
    \x01(\x03R\x0cfinishReason\"w\n\x11JoinDirectContent\x121\n\x06joiner\
    \x18\x01\x20\x01(\x0b2\x19.TikTok.LinkLayerListUserR\x06joiner\x12/\n\
    \x08allUsers\x18\x02\x20\x01(\x0b2\x13.TikTok.AllListUserR\x08allUsers\"\
    \x92\x01\n\x15LeaveJoinGroupContent\x12/\n\x08operator\x18\x01\x20\x01(\
    \x0b2\x13.TikTok.GroupPlayerR\x08operator\x12&\n\x0egroupChannelId\x18\
    \x02\x20\x01(\x03R\x0egroupChannelId\x12\x20\n\x0bleaveSource\x18\x03\
    \x20\x01(\tR\x0bleaveSource\"\xa3\x02\n\x16PermitJoinGroupContent\x12/\n\
    \x08approver\x18\x01\x20\x01(\x0b2\x13.TikTok.GroupPlayerR\x08approver\
    \x125\n\x0bagreeStatus\x18\x02\x20\x01(\x0e2\x13.TikTok.AgreeStatusR\x0b\
    agreeStatus\x12$\n\x04type\x18\x03\x20\x01(\x0e2\x10.TikTok.TextTypeR\
    \x04type\x12@\n\x10groupExtInfoList\x18\x04\x20\x03(\x0b2\x14.TikTok.RTC\
    ExtraInfoR\x10groupExtInfoList\x129\n\tgroupUser\x18\x05\x20\x01(\x0b2\
    \x1b.TikTok.GroupChannelAllUserR\tgroupUser\"\xa4\x01\n\x16CancelJoinGro\
    upContent\x123\n\nleaverList\x18\x01\x20\x03(\x0b2\x13.TikTok.GroupPlaye\
    rR\nleaverList\x12/\n\x08operator\x18\x02\x20\x01(\x0b2\x13.TikTok.Group\
    PlayerR\x08operator\x12$\n\x04type\x18\x03\x20\x01(\x0e2\x10.TikTok.Text\
    TypeR\x04type\"\x94\x01\n\x15P2PGroupChangeContent\x12@\n\x10groupExtInf\
    oList\x18\x01\x20\x03(\x0b2\x14.TikTok.RTCExtraInfoR\x10groupExtInfoList\
    \x129\n\tgroupUser\x18\x02\x20\x01(\x0b2\x1b.TikTok.GroupChannelAllUserR\
    \tgroupUser\"\xfd\x13\n\x0fBusinessContent\x12\x1e\n\noverLength\x18\x01\
    \x20\x01(\x03R\noverLength\x12D\n\x10multiLiveContent\x18d\x20\x01(\x0b2\
    \x18.TikTok.MultiLiveContentR\x10multiLiveContent\x12L\n\rcohostContent\
    \x18\xc8\x01\x20\x01(\x0b2%.TikTok.BusinessContent.CohostContentR\rcohos\
    tContent\x1an\n\rCohostContent\x12]\n\x13joinGroupBizContent\x18\x01\x20\
    \x01(\x0b2+.TikTok.BusinessContent.JoinGroupBizContentR\x13joinGroupBizC\
    ontent\x1a\xde\x02\n\x13JoinGroupBizContent\x124\n\x15fromRoomAgeRestric\
    ted\x18\x01\x20\x01(\x05R\x15fromRoomAgeRestricted\x125\n\x07fromTag\x18\
    \x02\x20\x01(\x0b2\x1b.TikTok.BusinessContent.TagR\x07fromTag\x12D\n\x06\
    dialog\x18\x03\x20\x01(\x0b2,.TikTok.BusinessContent.PerceptionDialogInf\
    oR\x06dialog\x127\n\npunishInfo\x18\x04\x20\x01(\x0b2\x17.TikTok.PunishE\
    ventInfoR\npunishInfo\x12[\n\x11joinGroupMsgExtra\x18e\x20\x01(\x0b2-.Ti\
    kTok.BusinessContent.JoinGroupMessageExtraR\x11joinGroupMsgExtra\x1aU\n\
    \x03Tag\x12\x18\n\x07tagType\x18\x01\x20\x01(\x05R\x07tagType\x12\x1a\n\
    \x08tagValue\x18\x02\x20\x01(\tR\x08tagValue\x12\x18\n\x07tagText\x18\
    \x03\x20\x01(\tR\x07tagText\x1a\xd0\x04\n\x14PerceptionDialogInfo\x12\
    \x1a\n\x08iconType\x18\x01\x20\x01(\x03R\x08iconType\x12\"\n\x05title\
    \x18\x02\x20\x01(\x0b2\x0c.TikTok.TextR\x05title\x12(\n\x08subTitle\x18\
    \x03\x20\x01(\x0b2\x0c.TikTok.TextR\x08subTitle\x128\n\x10adviceActionTe\
    xt\x18\x04\x20\x01(\x0b2\x0c.TikTok.TextR\x10adviceActionText\x12:\n\x11\
    defaultActionText\x18\x05\x20\x01(\x0b2\x0c.TikTok.TextR\x11defaultActio\
    nText\x12.\n\x12violationDetailUrl\x18\x06\x20\x01(\tR\x12violationDetai\
    lUrl\x12\x14\n\x05scene\x18\x07\x20\x01(\x05R\x05scene\x12\"\n\x0ctarget\
    UserId\x18\x08\x20\x01(\x03R\x0ctargetUserId\x12\"\n\x0ctargetRoomId\x18\
    \t\x20\x01(\x03R\x0ctargetRoomId\x12$\n\rcountDownTime\x18\n\x20\x01(\
    \x03R\rcountDownTime\x12\"\n\x0cshowFeedback\x18\x0b\x20\x01(\x08R\x0csh\
    owFeedback\x12b\n\x13feedbackOptionsList\x18\x0c\x20\x03(\x0b20.TikTok.B\
    usinessContent.PerceptionFeedbackOptionR\x13feedbackOptionsList\x12\x1c\
    \n\tpolicyTip\x18\r\x20\x01(\x03R\tpolicyTip\x1aJ\n\x18PerceptionFeedbac\
    kOption\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x1e\n\ncontentKe\
    y\x18\x02\x20\x01(\tR\ncontentKey\x1a\x98\x07\n\x15JoinGroupMessageExtra\
    \x12\x1e\n\nsourceType\x18\x01\x20\x01(\x03R\nsourceType\x12N\n\x05extra\
    \x18\x02\x20\x01(\x0b28.TikTok.BusinessContent.JoinGroupMessageExtra.Riv\
    alExtraR\x05extra\x12`\n\x0eotherUsersList\x18\x03\x20\x03(\x0b28.TikTok\
    .BusinessContent.JoinGroupMessageExtra.RivalExtraR\x0eotherUsersList\x1a\
    \xac\x05\n\nRivalExtra\x12\x1c\n\tuserCount\x18\x04\x20\x01(\x03R\tuserC\
    ount\x12/\n\x0bavatarThumb\x18\x05\x20\x01(\x0b2\r.TikTok.ImageR\x0bavat\
    arThumb\x12\x1c\n\tdisplayId\x18\x06\x20\x01(\tR\tdisplayId\x12{\n\x12au\
    thenticationInfo\x18\x07\x20\x01(\x0b2K.TikTok.BusinessContent.JoinGroup\
    MessageExtra.RivalExtra.AuthenticationInfoR\x12authenticationInfo\x12\
    \x1a\n\x08nickname\x18\x08\x20\x01(\tR\x08nickname\x12\"\n\x0cfollowStat\
    us\x18\t\x20\x01(\x03R\x0cfollowStatus\x129\n\x07hashtag\x18\n\x20\x01(\
    \x0b2\x1f.TikTok.BusinessContent.HashtagR\x07hashtag\x12E\n\x0btopHostIn\
    fo\x18\x0b\x20\x01(\x0b2#.TikTok.BusinessContent.TopHostInfoR\x0btopHost\
    Info\x12\x16\n\x06userId\x18\x0c\x20\x01(\x03R\x06userId\x12&\n\x0eisBes\
    tTeammate\x18\r\x20\x01(\x08R\x0eisBestTeammate\x1a\xb1\x01\n\x12Authent\
    icationInfo\x12\"\n\x0ccustomVerify\x18\x01\x20\x01(\tR\x0ccustomVerify\
    \x126\n\x16enterpriseVerifyReason\x18\x02\x20\x01(\tR\x16enterpriseVerif\
    yReason\x12?\n\x13authenticationBadge\x18\x03\x20\x01(\x0b2\r.TikTok.Ima\
    geR\x13authenticationBadge\x1a\x8c\x01\n\x07Hashtag\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x03R\x02id\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\
    \x12#\n\x05image\x18\x03\x20\x01(\x0b2\r.TikTok.ImageR\x05image\x126\n\t\
    namespace\x18\x04\x20\x01(\x0e2\x18.TikTok.HashtagNamespaceR\tnamespace\
    \x1aE\n\x0bTopHostInfo\x12\x1a\n\x08rankType\x18\x01\x20\x01(\tR\x08rank\
    Type\x12\x1a\n\x08topIndex\x18\x02\x20\x01(\x03R\x08topIndex\"\xa4\x01\n\
    \x10JoinGroupContent\x129\n\tgroupUser\x18\x01\x20\x01(\x0b2\x1b.TikTok.\
    GroupChannelAllUserR\tgroupUser\x12/\n\x08joinUser\x18\x02\x20\x01(\x0b2\
    \x13.TikTok.GroupPlayerR\x08joinUser\x12$\n\x04type\x18\x03\x20\x01(\x0e\
    2\x10.TikTok.TextTypeR\x04typeB.\n*io.github.jwdeveloper.tiktok.messages\
    .dataP\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(149);
            messages.push(Common::generated_message_descriptor_data());
            messages.push(Text::generated_message_descriptor_data());
            messages.push(Image::generated_message_descriptor_data());
            messages.push(BadgeStruct::generated_message_descriptor_data());
            messages.push(GiftStruct::generated_message_descriptor_data());
            messages.push(User::generated_message_descriptor_data());
            messages.push(Emote::generated_message_descriptor_data());
            messages.push(PunishEventInfo::generated_message_descriptor_data());
            messages.push(MsgFilter::generated_message_descriptor_data());
            messages.push(UserIdentity::generated_message_descriptor_data());
            messages.push(Goal::generated_message_descriptor_data());
            messages.push(Indicator::generated_message_descriptor_data());
            messages.push(Ranking::generated_message_descriptor_data());
            messages.push(TikTokColor::generated_message_descriptor_data());
            messages.push(ValueLabel::generated_message_descriptor_data());
            messages.push(MessageDetails::generated_message_descriptor_data());
            messages.push(UserContainer::generated_message_descriptor_data());
            messages.push(DataContainer::generated_message_descriptor_data());
            messages.push(TimeStampContainer::generated_message_descriptor_data());
            messages.push(MemberMessageData::generated_message_descriptor_data());
            messages.push(LinkMicArmiesItems::generated_message_descriptor_data());
            messages.push(PollStartContent::generated_message_descriptor_data());
            messages.push(PollEndContent::generated_message_descriptor_data());
            messages.push(PollOptionInfo::generated_message_descriptor_data());
            messages.push(VoteUser::generated_message_descriptor_data());
            messages.push(PollUpdateVotesContent::generated_message_descriptor_data());
            messages.push(UserFanTicket::generated_message_descriptor_data());
            messages.push(FanTicketRoomNoticeContent::generated_message_descriptor_data());
            messages.push(LinkerAcceptNoticeContent::generated_message_descriptor_data());
            messages.push(LinkerCancelContent::generated_message_descriptor_data());
            messages.push(ListUser::generated_message_descriptor_data());
            messages.push(LinkerCloseContent::generated_message_descriptor_data());
            messages.push(LinkerCreateContent::generated_message_descriptor_data());
            messages.push(LinkerEnterContent::generated_message_descriptor_data());
            messages.push(LinkerInviteContent::generated_message_descriptor_data());
            messages.push(LinkerKickOutContent::generated_message_descriptor_data());
            messages.push(LinkerLeaveContent::generated_message_descriptor_data());
            messages.push(LinkerLinkedListChangeContent::generated_message_descriptor_data());
            messages.push(CohostListChangeContent::generated_message_descriptor_data());
            messages.push(LinkerListChangeContent::generated_message_descriptor_data());
            messages.push(LinkerMediaChangeContent::generated_message_descriptor_data());
            messages.push(LinkerMicIdxUpdateContent::generated_message_descriptor_data());
            messages.push(LinkerMuteContent::generated_message_descriptor_data());
            messages.push(LinkerRandomMatchContent::generated_message_descriptor_data());
            messages.push(LinkerReplyContent::generated_message_descriptor_data());
            messages.push(LinkerSetting::generated_message_descriptor_data());
            messages.push(LinkerSysKickOutContent::generated_message_descriptor_data());
            messages.push(LinkmicUserToastContent::generated_message_descriptor_data());
            messages.push(LinkerUpdateUserContent::generated_message_descriptor_data());
            messages.push(LinkerUpdateUserSettingContent::generated_message_descriptor_data());
            messages.push(LinkerWaitingListChangeContent::generated_message_descriptor_data());
            messages.push(LinkmicUserSettingInfo::generated_message_descriptor_data());
            messages.push(Player::generated_message_descriptor_data());
            messages.push(AllListUser::generated_message_descriptor_data());
            messages.push(LinkLayerListUser::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(LinkPosition::generated_message_descriptor_data());
            messages.push(GroupPlayer::generated_message_descriptor_data());
            messages.push(DSLConfig::generated_message_descriptor_data());
            messages.push(GroupChannelAllUser::generated_message_descriptor_data());
            messages.push(GroupChannelUser::generated_message_descriptor_data());
            messages.push(RTCExtraInfo::generated_message_descriptor_data());
            messages.push(CreateChannelContent::generated_message_descriptor_data());
            messages.push(ListChangeContent::generated_message_descriptor_data());
            messages.push(MultiLiveContent::generated_message_descriptor_data());
            messages.push(InviteContent::generated_message_descriptor_data());
            messages.push(ApplyContent::generated_message_descriptor_data());
            messages.push(PermitApplyContent::generated_message_descriptor_data());
            messages.push(ReplyInviteContent::generated_message_descriptor_data());
            messages.push(KickOutContent::generated_message_descriptor_data());
            messages.push(CancelApplyContent::generated_message_descriptor_data());
            messages.push(CancelInviteContent::generated_message_descriptor_data());
            messages.push(LeaveContent::generated_message_descriptor_data());
            messages.push(FinishChannelContent::generated_message_descriptor_data());
            messages.push(JoinDirectContent::generated_message_descriptor_data());
            messages.push(LeaveJoinGroupContent::generated_message_descriptor_data());
            messages.push(PermitJoinGroupContent::generated_message_descriptor_data());
            messages.push(CancelJoinGroupContent::generated_message_descriptor_data());
            messages.push(P2PGroupChangeContent::generated_message_descriptor_data());
            messages.push(BusinessContent::generated_message_descriptor_data());
            messages.push(JoinGroupContent::generated_message_descriptor_data());
            messages.push(common::LiveMessageSEI::generated_message_descriptor_data());
            messages.push(common::LiveMessageID::generated_message_descriptor_data());
            messages.push(text::TextPiece::generated_message_descriptor_data());
            messages.push(text::TextFormat::generated_message_descriptor_data());
            messages.push(text::TextPieceGift::generated_message_descriptor_data());
            messages.push(text::TextPiecePatternRef::generated_message_descriptor_data());
            messages.push(text::TextPieceUser::generated_message_descriptor_data());
            messages.push(badge_struct::CombineBadge::generated_message_descriptor_data());
            messages.push(badge_struct::ProfileContent::generated_message_descriptor_data());
            messages.push(badge_struct::ProjectionConfig::generated_message_descriptor_data());
            messages.push(badge_struct::NumberConfig::generated_message_descriptor_data());
            messages.push(badge_struct::ProfileCardPanel::generated_message_descriptor_data());
            messages.push(badge_struct::CombineBadgeBackground::generated_message_descriptor_data());
            messages.push(badge_struct::ImageBadge::generated_message_descriptor_data());
            messages.push(badge_struct::TextBadge::generated_message_descriptor_data());
            messages.push(badge_struct::IconConfig::generated_message_descriptor_data());
            messages.push(badge_struct::StringBadge::generated_message_descriptor_data());
            messages.push(gift_struct::GiftPanelBanner::generated_message_descriptor_data());
            messages.push(gift_struct::GiftRandomEffectInfo::generated_message_descriptor_data());
            messages.push(gift_struct::RandomGiftBubble::generated_message_descriptor_data());
            messages.push(gift_struct::RandomGiftPanelBanner::generated_message_descriptor_data());
            messages.push(user::LiveEventInfo::generated_message_descriptor_data());
            messages.push(user::ActivityInfo::generated_message_descriptor_data());
            messages.push(user::AnchorLevel::generated_message_descriptor_data());
            messages.push(user::AuthenticationInfo::generated_message_descriptor_data());
            messages.push(user::AuthorStats::generated_message_descriptor_data());
            messages.push(user::Border::generated_message_descriptor_data());
            messages.push(user::ComboBadgeInfo::generated_message_descriptor_data());
            messages.push(user::EcommerceEntrance::generated_message_descriptor_data());
            messages.push(user::FansClub::generated_message_descriptor_data());
            messages.push(user::FansClubInfo::generated_message_descriptor_data());
            messages.push(user::FollowInfo::generated_message_descriptor_data());
            messages.push(user::OwnRoom::generated_message_descriptor_data());
            messages.push(user::PayGrade::generated_message_descriptor_data());
            messages.push(user::SubscribeBadge::generated_message_descriptor_data());
            messages.push(user::SubscribeInfo::generated_message_descriptor_data());
            messages.push(user::UserAttr::generated_message_descriptor_data());
            messages.push(user::UserStats::generated_message_descriptor_data());
            messages.push(user::live_event_info::WalletPackage::generated_message_descriptor_data());
            messages.push(user::ecommerce_entrance::ShopEntranceInfo::generated_message_descriptor_data());
            messages.push(user::ecommerce_entrance::ShowcaseEntranceInfo::generated_message_descriptor_data());
            messages.push(user::ecommerce_entrance::shop_entrance_info::StoreLabel::generated_message_descriptor_data());
            messages.push(user::ecommerce_entrance::shop_entrance_info::store_label::StoreOfficialLabel::generated_message_descriptor_data());
            messages.push(user::ecommerce_entrance::shop_entrance_info::store_label::store_official_label::ShopLabelImage::generated_message_descriptor_data());
            messages.push(user::fans_club::FansClubData::generated_message_descriptor_data());
            messages.push(user::pay_grade::GradeIcon::generated_message_descriptor_data());
            messages.push(goal::GoalStats::generated_message_descriptor_data());
            messages.push(goal::GoalContributor::generated_message_descriptor_data());
            messages.push(link_mic_armies_items::LinkMicArmiesGroup::generated_message_descriptor_data());
            messages.push(linker_reply_content::LinkmicInfo::generated_message_descriptor_data());
            messages.push(rtcextra_info::RTCEngineConfig::generated_message_descriptor_data());
            messages.push(rtcextra_info::RTCLiveVideoParam::generated_message_descriptor_data());
            messages.push(rtcextra_info::RTCVideoParam::generated_message_descriptor_data());
            messages.push(rtcextra_info::RTCBitrateMap::generated_message_descriptor_data());
            messages.push(multi_live_content::InviteBizContent::generated_message_descriptor_data());
            messages.push(multi_live_content::ReplyBizContent::generated_message_descriptor_data());
            messages.push(multi_live_content::PermitBizContent::generated_message_descriptor_data());
            messages.push(multi_live_content::KickOutBizContent::generated_message_descriptor_data());
            messages.push(business_content::CohostContent::generated_message_descriptor_data());
            messages.push(business_content::JoinGroupBizContent::generated_message_descriptor_data());
            messages.push(business_content::Tag::generated_message_descriptor_data());
            messages.push(business_content::PerceptionDialogInfo::generated_message_descriptor_data());
            messages.push(business_content::PerceptionFeedbackOption::generated_message_descriptor_data());
            messages.push(business_content::JoinGroupMessageExtra::generated_message_descriptor_data());
            messages.push(business_content::Hashtag::generated_message_descriptor_data());
            messages.push(business_content::TopHostInfo::generated_message_descriptor_data());
            messages.push(business_content::join_group_message_extra::RivalExtra::generated_message_descriptor_data());
            messages.push(business_content::join_group_message_extra::rival_extra::AuthenticationInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(12);
            enums.push(common::IMDispatchStrategy::generated_enum_descriptor_data());
            enums.push(badge_struct::DataCase::generated_enum_descriptor_data());
            enums.push(badge_struct::BadgeDisplayType::generated_enum_descriptor_data());
            enums.push(badge_struct::Position::generated_enum_descriptor_data());
            enums.push(user::live_event_info::EventPayMethod::generated_enum_descriptor_data());
            enums.push(user::ecommerce_entrance::CreatorType::generated_enum_descriptor_data());
            enums.push(user::ecommerce_entrance::EntranceType::generated_enum_descriptor_data());
            enums.push(user::ecommerce_entrance::shop_entrance_info::store_label::StoreBrandLabelType::generated_enum_descriptor_data());
            enums.push(user::fans_club::PreferntialType::generated_enum_descriptor_data());
            enums.push(user::fans_club::fans_club_data::BadgeIcon::generated_enum_descriptor_data());
            enums.push(user::fans_club::fans_club_data::UserFansClubStatus::generated_enum_descriptor_data());
            enums.push(list_user::LinkType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}