// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `webcast.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:TikTok.WebcastPushFrame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastPushFrame {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.SeqId)
    pub SeqId: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.LogId)
    pub LogId: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.Service)
    pub Service: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.Method)
    pub Method: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.headers)
    pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.PayloadEncoding)
    pub PayloadEncoding: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.PayloadType)
    pub PayloadType: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastPushFrame.Payload)
    pub Payload: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastPushFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastPushFrame {
    fn default() -> &'a WebcastPushFrame {
        <WebcastPushFrame as ::protobuf::Message>::default_instance()
    }
}

impl WebcastPushFrame {
    pub fn new() -> WebcastPushFrame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SeqId",
            |m: &WebcastPushFrame| { &m.SeqId },
            |m: &mut WebcastPushFrame| { &mut m.SeqId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LogId",
            |m: &WebcastPushFrame| { &m.LogId },
            |m: &mut WebcastPushFrame| { &mut m.LogId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Service",
            |m: &WebcastPushFrame| { &m.Service },
            |m: &mut WebcastPushFrame| { &mut m.Service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Method",
            |m: &WebcastPushFrame| { &m.Method },
            |m: &mut WebcastPushFrame| { &mut m.Method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "headers",
            |m: &WebcastPushFrame| { &m.headers },
            |m: &mut WebcastPushFrame| { &mut m.headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PayloadEncoding",
            |m: &WebcastPushFrame| { &m.PayloadEncoding },
            |m: &mut WebcastPushFrame| { &mut m.PayloadEncoding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PayloadType",
            |m: &WebcastPushFrame| { &m.PayloadType },
            |m: &mut WebcastPushFrame| { &mut m.PayloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Payload",
            |m: &WebcastPushFrame| { &m.Payload },
            |m: &mut WebcastPushFrame| { &mut m.Payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastPushFrame>(
            "WebcastPushFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastPushFrame {
    const NAME: &'static str = "WebcastPushFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.SeqId = is.read_uint64()?;
                },
                16 => {
                    self.LogId = is.read_uint64()?;
                },
                24 => {
                    self.Service = is.read_uint64()?;
                },
                32 => {
                    self.Method = is.read_uint64()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.headers.insert(key, value);
                },
                50 => {
                    self.PayloadEncoding = is.read_string()?;
                },
                58 => {
                    self.PayloadType = is.read_string()?;
                },
                66 => {
                    self.Payload = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.SeqId != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.SeqId);
        }
        if self.LogId != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.LogId);
        }
        if self.Service != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.Service);
        }
        if self.Method != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.Method);
        }
        for (k, v) in &self.headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.PayloadEncoding.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.PayloadEncoding);
        }
        if !self.PayloadType.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.PayloadType);
        }
        if !self.Payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.Payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.SeqId != 0 {
            os.write_uint64(1, self.SeqId)?;
        }
        if self.LogId != 0 {
            os.write_uint64(2, self.LogId)?;
        }
        if self.Service != 0 {
            os.write_uint64(3, self.Service)?;
        }
        if self.Method != 0 {
            os.write_uint64(4, self.Method)?;
        }
        for (k, v) in &self.headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.PayloadEncoding.is_empty() {
            os.write_string(6, &self.PayloadEncoding)?;
        }
        if !self.PayloadType.is_empty() {
            os.write_string(7, &self.PayloadType)?;
        }
        if !self.Payload.is_empty() {
            os.write_bytes(8, &self.Payload)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastPushFrame {
        WebcastPushFrame::new()
    }

    fn clear(&mut self) {
        self.SeqId = 0;
        self.LogId = 0;
        self.Service = 0;
        self.Method = 0;
        self.headers.clear();
        self.PayloadEncoding.clear();
        self.PayloadType.clear();
        self.Payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastPushFrame {
        static instance: ::protobuf::rt::Lazy<WebcastPushFrame> = ::protobuf::rt::Lazy::new();
        instance.get(WebcastPushFrame::new)
    }
}

impl ::protobuf::MessageFull for WebcastPushFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastPushFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastPushFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastPushFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastResponse {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.messages)
    pub messages: ::std::vec::Vec<webcast_response::Message>,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.cursor)
    pub cursor: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.fetchInterval)
    pub fetchInterval: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.now)
    pub now: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.internalExt)
    pub internalExt: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.fetchType)
    pub fetchType: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.routeParamsMap)
    pub routeParamsMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.heartBeatDuration)
    pub heartBeatDuration: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.needsAck)
    pub needsAck: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.pushServer)
    pub pushServer: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.isFirst)
    pub isFirst: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.historyCommentCursor)
    pub historyCommentCursor: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastResponse.historyNoMore)
    pub historyNoMore: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastResponse {
    fn default() -> &'a WebcastResponse {
        <WebcastResponse as ::protobuf::Message>::default_instance()
    }
}

impl WebcastResponse {
    pub fn new() -> WebcastResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &WebcastResponse| { &m.messages },
            |m: &mut WebcastResponse| { &mut m.messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &WebcastResponse| { &m.cursor },
            |m: &mut WebcastResponse| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fetchInterval",
            |m: &WebcastResponse| { &m.fetchInterval },
            |m: &mut WebcastResponse| { &mut m.fetchInterval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "now",
            |m: &WebcastResponse| { &m.now },
            |m: &mut WebcastResponse| { &mut m.now },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "internalExt",
            |m: &WebcastResponse| { &m.internalExt },
            |m: &mut WebcastResponse| { &mut m.internalExt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fetchType",
            |m: &WebcastResponse| { &m.fetchType },
            |m: &mut WebcastResponse| { &mut m.fetchType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "routeParamsMap",
            |m: &WebcastResponse| { &m.routeParamsMap },
            |m: &mut WebcastResponse| { &mut m.routeParamsMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "heartBeatDuration",
            |m: &WebcastResponse| { &m.heartBeatDuration },
            |m: &mut WebcastResponse| { &mut m.heartBeatDuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "needsAck",
            |m: &WebcastResponse| { &m.needsAck },
            |m: &mut WebcastResponse| { &mut m.needsAck },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushServer",
            |m: &WebcastResponse| { &m.pushServer },
            |m: &mut WebcastResponse| { &mut m.pushServer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isFirst",
            |m: &WebcastResponse| { &m.isFirst },
            |m: &mut WebcastResponse| { &mut m.isFirst },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "historyCommentCursor",
            |m: &WebcastResponse| { &m.historyCommentCursor },
            |m: &mut WebcastResponse| { &mut m.historyCommentCursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "historyNoMore",
            |m: &WebcastResponse| { &m.historyNoMore },
            |m: &mut WebcastResponse| { &mut m.historyNoMore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastResponse>(
            "WebcastResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastResponse {
    const NAME: &'static str = "WebcastResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                18 => {
                    self.cursor = is.read_string()?;
                },
                24 => {
                    self.fetchInterval = is.read_int64()?;
                },
                32 => {
                    self.now = is.read_int64()?;
                },
                42 => {
                    self.internalExt = is.read_string()?;
                },
                48 => {
                    self.fetchType = is.read_int32()?;
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.routeParamsMap.insert(key, value);
                },
                64 => {
                    self.heartBeatDuration = is.read_int64()?;
                },
                72 => {
                    self.needsAck = is.read_bool()?;
                },
                82 => {
                    self.pushServer = is.read_string()?;
                },
                88 => {
                    self.isFirst = is.read_bool()?;
                },
                98 => {
                    self.historyCommentCursor = is.read_string()?;
                },
                104 => {
                    self.historyNoMore = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        if self.fetchInterval != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.fetchInterval);
        }
        if self.now != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.now);
        }
        if !self.internalExt.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.internalExt);
        }
        if self.fetchType != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.fetchType);
        }
        for (k, v) in &self.routeParamsMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.heartBeatDuration != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.heartBeatDuration);
        }
        if self.needsAck != false {
            my_size += 1 + 1;
        }
        if !self.pushServer.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.pushServer);
        }
        if self.isFirst != false {
            my_size += 1 + 1;
        }
        if !self.historyCommentCursor.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.historyCommentCursor);
        }
        if self.historyNoMore != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        if self.fetchInterval != 0 {
            os.write_int64(3, self.fetchInterval)?;
        }
        if self.now != 0 {
            os.write_int64(4, self.now)?;
        }
        if !self.internalExt.is_empty() {
            os.write_string(5, &self.internalExt)?;
        }
        if self.fetchType != 0 {
            os.write_int32(6, self.fetchType)?;
        }
        for (k, v) in &self.routeParamsMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.heartBeatDuration != 0 {
            os.write_int64(8, self.heartBeatDuration)?;
        }
        if self.needsAck != false {
            os.write_bool(9, self.needsAck)?;
        }
        if !self.pushServer.is_empty() {
            os.write_string(10, &self.pushServer)?;
        }
        if self.isFirst != false {
            os.write_bool(11, self.isFirst)?;
        }
        if !self.historyCommentCursor.is_empty() {
            os.write_string(12, &self.historyCommentCursor)?;
        }
        if self.historyNoMore != false {
            os.write_bool(13, self.historyNoMore)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastResponse {
        WebcastResponse::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.cursor.clear();
        self.fetchInterval = 0;
        self.now = 0;
        self.internalExt.clear();
        self.fetchType = 0;
        self.routeParamsMap.clear();
        self.heartBeatDuration = 0;
        self.needsAck = false;
        self.pushServer.clear();
        self.isFirst = false;
        self.historyCommentCursor.clear();
        self.historyNoMore = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastResponse {
        static instance: ::protobuf::rt::Lazy<WebcastResponse> = ::protobuf::rt::Lazy::new();
        instance.get(WebcastResponse::new)
    }
}

impl ::protobuf::MessageFull for WebcastResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastResponse`
pub mod webcast_response {
    // @@protoc_insertion_point(message:TikTok.WebcastResponse.Message)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Message {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastResponse.Message.method)
        pub method: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastResponse.Message.payload)
        pub payload: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:TikTok.WebcastResponse.Message.msgId)
        pub msgId: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastResponse.Message.msgType)
        pub msgType: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastResponse.Message.offset)
        pub offset: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastResponse.Message.isHistory)
        pub isHistory: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastResponse.Message.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Message {
        fn default() -> &'a Message {
            <Message as ::protobuf::Message>::default_instance()
        }
    }

    impl Message {
        pub fn new() -> Message {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "method",
                |m: &Message| { &m.method },
                |m: &mut Message| { &mut m.method },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "payload",
                |m: &Message| { &m.payload },
                |m: &mut Message| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "msgId",
                |m: &Message| { &m.msgId },
                |m: &mut Message| { &mut m.msgId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "msgType",
                |m: &Message| { &m.msgType },
                |m: &mut Message| { &mut m.msgType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "offset",
                |m: &Message| { &m.offset },
                |m: &mut Message| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isHistory",
                |m: &Message| { &m.isHistory },
                |m: &mut Message| { &mut m.isHistory },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
                "WebcastResponse.Message",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Message {
        const NAME: &'static str = "Message";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.method = is.read_string()?;
                    },
                    18 => {
                        self.payload = is.read_bytes()?;
                    },
                    24 => {
                        self.msgId = is.read_int64()?;
                    },
                    32 => {
                        self.msgType = is.read_int32()?;
                    },
                    40 => {
                        self.offset = is.read_int64()?;
                    },
                    48 => {
                        self.isHistory = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.method.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.method);
            }
            if !self.payload.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.payload);
            }
            if self.msgId != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.msgId);
            }
            if self.msgType != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.msgType);
            }
            if self.offset != 0 {
                my_size += ::protobuf::rt::int64_size(5, self.offset);
            }
            if self.isHistory != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.method.is_empty() {
                os.write_string(1, &self.method)?;
            }
            if !self.payload.is_empty() {
                os.write_bytes(2, &self.payload)?;
            }
            if self.msgId != 0 {
                os.write_int64(3, self.msgId)?;
            }
            if self.msgType != 0 {
                os.write_int32(4, self.msgType)?;
            }
            if self.offset != 0 {
                os.write_int64(5, self.offset)?;
            }
            if self.isHistory != false {
                os.write_bool(6, self.isHistory)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Message {
            Message::new()
        }

        fn clear(&mut self) {
            self.method.clear();
            self.payload.clear();
            self.msgId = 0;
            self.msgType = 0;
            self.offset = 0;
            self.isHistory = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Message {
            static instance: Message = Message {
                method: ::std::string::String::new(),
                payload: ::std::vec::Vec::new(),
                msgId: 0,
                msgType: 0,
                offset: 0,
                isHistory: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Message {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastResponse.Message").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Message {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Message {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastGiftMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastGiftMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.giftId)
    pub giftId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.fanTicketCount)
    pub fanTicketCount: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.groupCount)
    pub groupCount: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.repeatCount)
    pub repeatCount: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.comboCount)
    pub comboCount: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.user)
    pub user: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.toUser)
    pub toUser: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.repeatEnd)
    pub repeatEnd: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.groupId)
    pub groupId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.incomeTaskgifts)
    pub incomeTaskgifts: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.roomFanTicketCount)
    pub roomFanTicketCount: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.gift)
    pub gift: ::protobuf::MessageField<super::data::GiftStruct>,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.logId)
    pub logId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.sendType)
    pub sendType: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.monitorExtra)
    pub monitorExtra: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.colorId)
    pub colorId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.isFirstSent)
    pub isFirstSent: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.orderId)
    pub orderId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.userIdentity)
    pub userIdentity: ::protobuf::MessageField<super::data::UserIdentity>,
    // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.userGiftReciever)
    pub userGiftReciever: ::protobuf::MessageField<webcast_gift_message::UserGiftReciever>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastGiftMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastGiftMessage {
    fn default() -> &'a WebcastGiftMessage {
        <WebcastGiftMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastGiftMessage {
    pub fn new() -> WebcastGiftMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastGiftMessage| { &m.common },
            |m: &mut WebcastGiftMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "giftId",
            |m: &WebcastGiftMessage| { &m.giftId },
            |m: &mut WebcastGiftMessage| { &mut m.giftId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fanTicketCount",
            |m: &WebcastGiftMessage| { &m.fanTicketCount },
            |m: &mut WebcastGiftMessage| { &mut m.fanTicketCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groupCount",
            |m: &WebcastGiftMessage| { &m.groupCount },
            |m: &mut WebcastGiftMessage| { &mut m.groupCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "repeatCount",
            |m: &WebcastGiftMessage| { &m.repeatCount },
            |m: &mut WebcastGiftMessage| { &mut m.repeatCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comboCount",
            |m: &WebcastGiftMessage| { &m.comboCount },
            |m: &mut WebcastGiftMessage| { &mut m.comboCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "user",
            |m: &WebcastGiftMessage| { &m.user },
            |m: &mut WebcastGiftMessage| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "toUser",
            |m: &WebcastGiftMessage| { &m.toUser },
            |m: &mut WebcastGiftMessage| { &mut m.toUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "repeatEnd",
            |m: &WebcastGiftMessage| { &m.repeatEnd },
            |m: &mut WebcastGiftMessage| { &mut m.repeatEnd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groupId",
            |m: &WebcastGiftMessage| { &m.groupId },
            |m: &mut WebcastGiftMessage| { &mut m.groupId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "incomeTaskgifts",
            |m: &WebcastGiftMessage| { &m.incomeTaskgifts },
            |m: &mut WebcastGiftMessage| { &mut m.incomeTaskgifts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomFanTicketCount",
            |m: &WebcastGiftMessage| { &m.roomFanTicketCount },
            |m: &mut WebcastGiftMessage| { &mut m.roomFanTicketCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::GiftStruct>(
            "gift",
            |m: &WebcastGiftMessage| { &m.gift },
            |m: &mut WebcastGiftMessage| { &mut m.gift },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logId",
            |m: &WebcastGiftMessage| { &m.logId },
            |m: &mut WebcastGiftMessage| { &mut m.logId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sendType",
            |m: &WebcastGiftMessage| { &m.sendType },
            |m: &mut WebcastGiftMessage| { &mut m.sendType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "monitorExtra",
            |m: &WebcastGiftMessage| { &m.monitorExtra },
            |m: &mut WebcastGiftMessage| { &mut m.monitorExtra },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "colorId",
            |m: &WebcastGiftMessage| { &m.colorId },
            |m: &mut WebcastGiftMessage| { &mut m.colorId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isFirstSent",
            |m: &WebcastGiftMessage| { &m.isFirstSent },
            |m: &mut WebcastGiftMessage| { &mut m.isFirstSent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "orderId",
            |m: &WebcastGiftMessage| { &m.orderId },
            |m: &mut WebcastGiftMessage| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::UserIdentity>(
            "userIdentity",
            |m: &WebcastGiftMessage| { &m.userIdentity },
            |m: &mut WebcastGiftMessage| { &mut m.userIdentity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_gift_message::UserGiftReciever>(
            "userGiftReciever",
            |m: &WebcastGiftMessage| { &m.userGiftReciever },
            |m: &mut WebcastGiftMessage| { &mut m.userGiftReciever },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastGiftMessage>(
            "WebcastGiftMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastGiftMessage {
    const NAME: &'static str = "WebcastGiftMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.giftId = is.read_int64()?;
                },
                24 => {
                    self.fanTicketCount = is.read_int64()?;
                },
                32 => {
                    self.groupCount = is.read_int32()?;
                },
                40 => {
                    self.repeatCount = is.read_int32()?;
                },
                48 => {
                    self.comboCount = is.read_int32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.toUser)?;
                },
                72 => {
                    self.repeatEnd = is.read_int32()?;
                },
                88 => {
                    self.groupId = is.read_int64()?;
                },
                96 => {
                    self.incomeTaskgifts = is.read_int64()?;
                },
                104 => {
                    self.roomFanTicketCount = is.read_int64()?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gift)?;
                },
                130 => {
                    self.logId = is.read_string()?;
                },
                136 => {
                    self.sendType = is.read_int64()?;
                },
                178 => {
                    self.monitorExtra = is.read_string()?;
                },
                192 => {
                    self.colorId = is.read_int64()?;
                },
                200 => {
                    self.isFirstSent = is.read_bool()?;
                },
                226 => {
                    self.orderId = is.read_string()?;
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userIdentity)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userGiftReciever)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.giftId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.giftId);
        }
        if self.fanTicketCount != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.fanTicketCount);
        }
        if self.groupCount != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.groupCount);
        }
        if self.repeatCount != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.repeatCount);
        }
        if self.comboCount != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.comboCount);
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.toUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.repeatEnd != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.repeatEnd);
        }
        if self.groupId != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.groupId);
        }
        if self.incomeTaskgifts != 0 {
            my_size += ::protobuf::rt::int64_size(12, self.incomeTaskgifts);
        }
        if self.roomFanTicketCount != 0 {
            my_size += ::protobuf::rt::int64_size(13, self.roomFanTicketCount);
        }
        if let Some(v) = self.gift.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.logId.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.logId);
        }
        if self.sendType != 0 {
            my_size += ::protobuf::rt::int64_size(17, self.sendType);
        }
        if !self.monitorExtra.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.monitorExtra);
        }
        if self.colorId != 0 {
            my_size += ::protobuf::rt::int64_size(24, self.colorId);
        }
        if self.isFirstSent != false {
            my_size += 2 + 1;
        }
        if !self.orderId.is_empty() {
            my_size += ::protobuf::rt::string_size(28, &self.orderId);
        }
        if let Some(v) = self.userIdentity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.userGiftReciever.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.giftId != 0 {
            os.write_int64(2, self.giftId)?;
        }
        if self.fanTicketCount != 0 {
            os.write_int64(3, self.fanTicketCount)?;
        }
        if self.groupCount != 0 {
            os.write_int32(4, self.groupCount)?;
        }
        if self.repeatCount != 0 {
            os.write_int32(5, self.repeatCount)?;
        }
        if self.comboCount != 0 {
            os.write_int32(6, self.comboCount)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.toUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.repeatEnd != 0 {
            os.write_int32(9, self.repeatEnd)?;
        }
        if self.groupId != 0 {
            os.write_int64(11, self.groupId)?;
        }
        if self.incomeTaskgifts != 0 {
            os.write_int64(12, self.incomeTaskgifts)?;
        }
        if self.roomFanTicketCount != 0 {
            os.write_int64(13, self.roomFanTicketCount)?;
        }
        if let Some(v) = self.gift.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if !self.logId.is_empty() {
            os.write_string(16, &self.logId)?;
        }
        if self.sendType != 0 {
            os.write_int64(17, self.sendType)?;
        }
        if !self.monitorExtra.is_empty() {
            os.write_string(22, &self.monitorExtra)?;
        }
        if self.colorId != 0 {
            os.write_int64(24, self.colorId)?;
        }
        if self.isFirstSent != false {
            os.write_bool(25, self.isFirstSent)?;
        }
        if !self.orderId.is_empty() {
            os.write_string(28, &self.orderId)?;
        }
        if let Some(v) = self.userIdentity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.userGiftReciever.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastGiftMessage {
        WebcastGiftMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.giftId = 0;
        self.fanTicketCount = 0;
        self.groupCount = 0;
        self.repeatCount = 0;
        self.comboCount = 0;
        self.user.clear();
        self.toUser.clear();
        self.repeatEnd = 0;
        self.groupId = 0;
        self.incomeTaskgifts = 0;
        self.roomFanTicketCount = 0;
        self.gift.clear();
        self.logId.clear();
        self.sendType = 0;
        self.monitorExtra.clear();
        self.colorId = 0;
        self.isFirstSent = false;
        self.orderId.clear();
        self.userIdentity.clear();
        self.userGiftReciever.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastGiftMessage {
        static instance: WebcastGiftMessage = WebcastGiftMessage {
            common: ::protobuf::MessageField::none(),
            giftId: 0,
            fanTicketCount: 0,
            groupCount: 0,
            repeatCount: 0,
            comboCount: 0,
            user: ::protobuf::MessageField::none(),
            toUser: ::protobuf::MessageField::none(),
            repeatEnd: 0,
            groupId: 0,
            incomeTaskgifts: 0,
            roomFanTicketCount: 0,
            gift: ::protobuf::MessageField::none(),
            logId: ::std::string::String::new(),
            sendType: 0,
            monitorExtra: ::std::string::String::new(),
            colorId: 0,
            isFirstSent: false,
            orderId: ::std::string::String::new(),
            userIdentity: ::protobuf::MessageField::none(),
            userGiftReciever: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastGiftMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastGiftMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastGiftMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastGiftMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastGiftMessage`
pub mod webcast_gift_message {
    // @@protoc_insertion_point(message:TikTok.WebcastGiftMessage.UserGiftReciever)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UserGiftReciever {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.UserGiftReciever.userId)
        pub userId: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.UserGiftReciever.deviceName)
        pub deviceName: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastGiftMessage.UserGiftReciever.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserGiftReciever {
        fn default() -> &'a UserGiftReciever {
            <UserGiftReciever as ::protobuf::Message>::default_instance()
        }
    }

    impl UserGiftReciever {
        pub fn new() -> UserGiftReciever {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userId",
                |m: &UserGiftReciever| { &m.userId },
                |m: &mut UserGiftReciever| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "deviceName",
                |m: &UserGiftReciever| { &m.deviceName },
                |m: &mut UserGiftReciever| { &mut m.deviceName },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserGiftReciever>(
                "WebcastGiftMessage.UserGiftReciever",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserGiftReciever {
        const NAME: &'static str = "UserGiftReciever";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.userId = is.read_int64()?;
                    },
                    82 => {
                        self.deviceName = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.userId != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.userId);
            }
            if !self.deviceName.is_empty() {
                my_size += ::protobuf::rt::string_size(10, &self.deviceName);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.userId != 0 {
                os.write_int64(1, self.userId)?;
            }
            if !self.deviceName.is_empty() {
                os.write_string(10, &self.deviceName)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserGiftReciever {
            UserGiftReciever::new()
        }

        fn clear(&mut self) {
            self.userId = 0;
            self.deviceName.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserGiftReciever {
            static instance: UserGiftReciever = UserGiftReciever {
                userId: 0,
                deviceName: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserGiftReciever {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastGiftMessage.UserGiftReciever").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserGiftReciever {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserGiftReciever {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastGiftMessage.GiftIMPriority)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GiftIMPriority {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.GiftIMPriority.queueSizesList)
        pub queueSizesList: ::std::vec::Vec<i64>,
        // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.GiftIMPriority.selfQueuePriority)
        pub selfQueuePriority: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.GiftIMPriority.priority)
        pub priority: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastGiftMessage.GiftIMPriority.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GiftIMPriority {
        fn default() -> &'a GiftIMPriority {
            <GiftIMPriority as ::protobuf::Message>::default_instance()
        }
    }

    impl GiftIMPriority {
        pub fn new() -> GiftIMPriority {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "queueSizesList",
                |m: &GiftIMPriority| { &m.queueSizesList },
                |m: &mut GiftIMPriority| { &mut m.queueSizesList },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "selfQueuePriority",
                |m: &GiftIMPriority| { &m.selfQueuePriority },
                |m: &mut GiftIMPriority| { &mut m.selfQueuePriority },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "priority",
                |m: &GiftIMPriority| { &m.priority },
                |m: &mut GiftIMPriority| { &mut m.priority },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GiftIMPriority>(
                "WebcastGiftMessage.GiftIMPriority",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GiftIMPriority {
        const NAME: &'static str = "GiftIMPriority";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int64_into(&mut self.queueSizesList)?;
                    },
                    8 => {
                        self.queueSizesList.push(is.read_int64()?);
                    },
                    16 => {
                        self.selfQueuePriority = is.read_int64()?;
                    },
                    24 => {
                        self.priority = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.queueSizesList {
                my_size += ::protobuf::rt::int64_size(1, *value);
            };
            if self.selfQueuePriority != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.selfQueuePriority);
            }
            if self.priority != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.priority);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.queueSizesList {
                os.write_int64(1, *v)?;
            };
            if self.selfQueuePriority != 0 {
                os.write_int64(2, self.selfQueuePriority)?;
            }
            if self.priority != 0 {
                os.write_int64(3, self.priority)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GiftIMPriority {
            GiftIMPriority::new()
        }

        fn clear(&mut self) {
            self.queueSizesList.clear();
            self.selfQueuePriority = 0;
            self.priority = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GiftIMPriority {
            static instance: GiftIMPriority = GiftIMPriority {
                queueSizesList: ::std::vec::Vec::new(),
                selfQueuePriority: 0,
                priority: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GiftIMPriority {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastGiftMessage.GiftIMPriority").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GiftIMPriority {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GiftIMPriority {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastGiftMessage.PublicAreaCommon)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PublicAreaCommon {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.PublicAreaCommon.userLabel)
        pub userLabel: ::protobuf::MessageField<super::super::data::Image>,
        // @@protoc_insertion_point(field:TikTok.WebcastGiftMessage.PublicAreaCommon.userConsumeInRoom)
        pub userConsumeInRoom: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastGiftMessage.PublicAreaCommon.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PublicAreaCommon {
        fn default() -> &'a PublicAreaCommon {
            <PublicAreaCommon as ::protobuf::Message>::default_instance()
        }
    }

    impl PublicAreaCommon {
        pub fn new() -> PublicAreaCommon {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Image>(
                "userLabel",
                |m: &PublicAreaCommon| { &m.userLabel },
                |m: &mut PublicAreaCommon| { &mut m.userLabel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userConsumeInRoom",
                |m: &PublicAreaCommon| { &m.userConsumeInRoom },
                |m: &mut PublicAreaCommon| { &mut m.userConsumeInRoom },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublicAreaCommon>(
                "WebcastGiftMessage.PublicAreaCommon",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PublicAreaCommon {
        const NAME: &'static str = "PublicAreaCommon";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.userLabel)?;
                    },
                    16 => {
                        self.userConsumeInRoom = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.userLabel.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.userConsumeInRoom != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.userConsumeInRoom);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.userLabel.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.userConsumeInRoom != 0 {
                os.write_int64(2, self.userConsumeInRoom)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PublicAreaCommon {
            PublicAreaCommon::new()
        }

        fn clear(&mut self) {
            self.userLabel.clear();
            self.userConsumeInRoom = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PublicAreaCommon {
            static instance: PublicAreaCommon = PublicAreaCommon {
                userLabel: ::protobuf::MessageField::none(),
                userConsumeInRoom: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PublicAreaCommon {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastGiftMessage.PublicAreaCommon").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PublicAreaCommon {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublicAreaCommon {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.RoomMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RoomMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.RoomMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.RoomMessage.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.RoomMessage.supprotLandscape)
    pub supprotLandscape: bool,
    // @@protoc_insertion_point(field:TikTok.RoomMessage.source)
    pub source: i64,
    // @@protoc_insertion_point(field:TikTok.RoomMessage.icon)
    pub icon: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.RoomMessage.scene)
    pub scene: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.RoomMessage.isWelcome)
    pub isWelcome: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.RoomMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoomMessage {
    fn default() -> &'a RoomMessage {
        <RoomMessage as ::protobuf::Message>::default_instance()
    }
}

impl RoomMessage {
    pub fn new() -> RoomMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &RoomMessage| { &m.common },
            |m: &mut RoomMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &RoomMessage| { &m.content },
            |m: &mut RoomMessage| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supprotLandscape",
            |m: &RoomMessage| { &m.supprotLandscape },
            |m: &mut RoomMessage| { &mut m.supprotLandscape },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &RoomMessage| { &m.source },
            |m: &mut RoomMessage| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "icon",
            |m: &RoomMessage| { &m.icon },
            |m: &mut RoomMessage| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scene",
            |m: &RoomMessage| { &m.scene },
            |m: &mut RoomMessage| { &mut m.scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isWelcome",
            |m: &RoomMessage| { &m.isWelcome },
            |m: &mut RoomMessage| { &mut m.isWelcome },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoomMessage>(
            "RoomMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoomMessage {
    const NAME: &'static str = "RoomMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    self.content = is.read_string()?;
                },
                24 => {
                    self.supprotLandscape = is.read_bool()?;
                },
                32 => {
                    self.source = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                },
                50 => {
                    self.scene = is.read_string()?;
                },
                56 => {
                    self.isWelcome = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        if self.supprotLandscape != false {
            my_size += 1 + 1;
        }
        if self.source != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.source);
        }
        if let Some(v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.scene.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.scene);
        }
        if self.isWelcome != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        if self.supprotLandscape != false {
            os.write_bool(3, self.supprotLandscape)?;
        }
        if self.source != 0 {
            os.write_int64(4, self.source)?;
        }
        if let Some(v) = self.icon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.scene.is_empty() {
            os.write_string(6, &self.scene)?;
        }
        if self.isWelcome != false {
            os.write_bool(7, self.isWelcome)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoomMessage {
        RoomMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.content.clear();
        self.supprotLandscape = false;
        self.source = 0;
        self.icon.clear();
        self.scene.clear();
        self.isWelcome = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoomMessage {
        static instance: RoomMessage = RoomMessage {
            common: ::protobuf::MessageField::none(),
            content: ::std::string::String::new(),
            supprotLandscape: false,
            source: 0,
            icon: ::protobuf::MessageField::none(),
            scene: ::std::string::String::new(),
            isWelcome: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoomMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoomMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoomMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastRoomMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastRoomMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastRoomMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomMessage.content)
    pub content: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastRoomMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastRoomMessage {
    fn default() -> &'a WebcastRoomMessage {
        <WebcastRoomMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastRoomMessage {
    pub fn new() -> WebcastRoomMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastRoomMessage| { &m.common },
            |m: &mut WebcastRoomMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &WebcastRoomMessage| { &m.content },
            |m: &mut WebcastRoomMessage| { &mut m.content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastRoomMessage>(
            "WebcastRoomMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastRoomMessage {
    const NAME: &'static str = "WebcastRoomMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    self.content = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastRoomMessage {
        WebcastRoomMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.content.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastRoomMessage {
        static instance: WebcastRoomMessage = WebcastRoomMessage {
            common: ::protobuf::MessageField::none(),
            content: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastRoomMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastRoomMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastRoomMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastRoomMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastBarrageMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastBarrageMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.event)
    pub event: ::protobuf::MessageField<webcast_barrage_message::BarrageEvent>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.msgType)
    pub msgType: ::protobuf::EnumOrUnknown<webcast_barrage_message::BarrageType>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.icon)
    pub icon: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.content)
    pub content: ::protobuf::MessageField<super::data::Text>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.duration)
    pub duration: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.background)
    pub background: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.rightIcon)
    pub rightIcon: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.userGradeParam)
    pub userGradeParam: ::protobuf::MessageField<webcast_barrage_message::BarrageTypeUserGradeParam>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.fansLevelParam)
    pub fansLevelParam: ::protobuf::MessageField<webcast_barrage_message::BarrageTypeFansLevelParam>,
    // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.subscribeGiftParam)
    pub subscribeGiftParam: ::protobuf::MessageField<webcast_barrage_message::BarrageTypeSubscribeGiftParam>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastBarrageMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastBarrageMessage {
    fn default() -> &'a WebcastBarrageMessage {
        <WebcastBarrageMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastBarrageMessage {
    pub fn new() -> WebcastBarrageMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastBarrageMessage| { &m.common },
            |m: &mut WebcastBarrageMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_barrage_message::BarrageEvent>(
            "event",
            |m: &WebcastBarrageMessage| { &m.event },
            |m: &mut WebcastBarrageMessage| { &mut m.event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msgType",
            |m: &WebcastBarrageMessage| { &m.msgType },
            |m: &mut WebcastBarrageMessage| { &mut m.msgType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "icon",
            |m: &WebcastBarrageMessage| { &m.icon },
            |m: &mut WebcastBarrageMessage| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "content",
            |m: &WebcastBarrageMessage| { &m.content },
            |m: &mut WebcastBarrageMessage| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &WebcastBarrageMessage| { &m.duration },
            |m: &mut WebcastBarrageMessage| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "background",
            |m: &WebcastBarrageMessage| { &m.background },
            |m: &mut WebcastBarrageMessage| { &mut m.background },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "rightIcon",
            |m: &WebcastBarrageMessage| { &m.rightIcon },
            |m: &mut WebcastBarrageMessage| { &mut m.rightIcon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_barrage_message::BarrageTypeUserGradeParam>(
            "userGradeParam",
            |m: &WebcastBarrageMessage| { &m.userGradeParam },
            |m: &mut WebcastBarrageMessage| { &mut m.userGradeParam },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_barrage_message::BarrageTypeFansLevelParam>(
            "fansLevelParam",
            |m: &WebcastBarrageMessage| { &m.fansLevelParam },
            |m: &mut WebcastBarrageMessage| { &mut m.fansLevelParam },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_barrage_message::BarrageTypeSubscribeGiftParam>(
            "subscribeGiftParam",
            |m: &WebcastBarrageMessage| { &m.subscribeGiftParam },
            |m: &mut WebcastBarrageMessage| { &mut m.subscribeGiftParam },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastBarrageMessage>(
            "WebcastBarrageMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastBarrageMessage {
    const NAME: &'static str = "WebcastBarrageMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event)?;
                },
                24 => {
                    self.msgType = is.read_enum_or_unknown()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.content)?;
                },
                48 => {
                    self.duration = is.read_int32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rightIcon)?;
                },
                802 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userGradeParam)?;
                },
                810 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fansLevelParam)?;
                },
                818 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subscribeGiftParam)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.msgType != ::protobuf::EnumOrUnknown::new(webcast_barrage_message::BarrageType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.msgType.value());
        }
        if let Some(v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.duration);
        }
        if let Some(v) = self.background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rightIcon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.userGradeParam.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fansLevelParam.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subscribeGiftParam.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.msgType != ::protobuf::EnumOrUnknown::new(webcast_barrage_message::BarrageType::UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.msgType))?;
        }
        if let Some(v) = self.icon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.content.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.duration != 0 {
            os.write_int32(6, self.duration)?;
        }
        if let Some(v) = self.background.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.rightIcon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.userGradeParam.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
        }
        if let Some(v) = self.fansLevelParam.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(101, v, os)?;
        }
        if let Some(v) = self.subscribeGiftParam.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(102, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastBarrageMessage {
        WebcastBarrageMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.event.clear();
        self.msgType = ::protobuf::EnumOrUnknown::new(webcast_barrage_message::BarrageType::UNKNOWN);
        self.icon.clear();
        self.content.clear();
        self.duration = 0;
        self.background.clear();
        self.rightIcon.clear();
        self.userGradeParam.clear();
        self.fansLevelParam.clear();
        self.subscribeGiftParam.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastBarrageMessage {
        static instance: WebcastBarrageMessage = WebcastBarrageMessage {
            common: ::protobuf::MessageField::none(),
            event: ::protobuf::MessageField::none(),
            msgType: ::protobuf::EnumOrUnknown::from_i32(0),
            icon: ::protobuf::MessageField::none(),
            content: ::protobuf::MessageField::none(),
            duration: 0,
            background: ::protobuf::MessageField::none(),
            rightIcon: ::protobuf::MessageField::none(),
            userGradeParam: ::protobuf::MessageField::none(),
            fansLevelParam: ::protobuf::MessageField::none(),
            subscribeGiftParam: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastBarrageMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastBarrageMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastBarrageMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastBarrageMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastBarrageMessage`
pub mod webcast_barrage_message {
    // @@protoc_insertion_point(message:TikTok.WebcastBarrageMessage.BarrageTypeUserGradeParam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BarrageTypeUserGradeParam {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeUserGradeParam.currentGrade)
        pub currentGrade: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeUserGradeParam.displayConfig)
        pub displayConfig: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeUserGradeParam.userId)
        pub userId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeUserGradeParam.user)
        pub user: ::protobuf::MessageField<super::super::data::User>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastBarrageMessage.BarrageTypeUserGradeParam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BarrageTypeUserGradeParam {
        fn default() -> &'a BarrageTypeUserGradeParam {
            <BarrageTypeUserGradeParam as ::protobuf::Message>::default_instance()
        }
    }

    impl BarrageTypeUserGradeParam {
        pub fn new() -> BarrageTypeUserGradeParam {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "currentGrade",
                |m: &BarrageTypeUserGradeParam| { &m.currentGrade },
                |m: &mut BarrageTypeUserGradeParam| { &mut m.currentGrade },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "displayConfig",
                |m: &BarrageTypeUserGradeParam| { &m.displayConfig },
                |m: &mut BarrageTypeUserGradeParam| { &mut m.displayConfig },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userId",
                |m: &BarrageTypeUserGradeParam| { &m.userId },
                |m: &mut BarrageTypeUserGradeParam| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::User>(
                "user",
                |m: &BarrageTypeUserGradeParam| { &m.user },
                |m: &mut BarrageTypeUserGradeParam| { &mut m.user },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BarrageTypeUserGradeParam>(
                "WebcastBarrageMessage.BarrageTypeUserGradeParam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BarrageTypeUserGradeParam {
        const NAME: &'static str = "BarrageTypeUserGradeParam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.currentGrade = is.read_int32()?;
                    },
                    16 => {
                        self.displayConfig = is.read_int32()?;
                    },
                    26 => {
                        self.userId = is.read_string()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.currentGrade != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.currentGrade);
            }
            if self.displayConfig != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.displayConfig);
            }
            if !self.userId.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.userId);
            }
            if let Some(v) = self.user.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.currentGrade != 0 {
                os.write_int32(1, self.currentGrade)?;
            }
            if self.displayConfig != 0 {
                os.write_int32(2, self.displayConfig)?;
            }
            if !self.userId.is_empty() {
                os.write_string(3, &self.userId)?;
            }
            if let Some(v) = self.user.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BarrageTypeUserGradeParam {
            BarrageTypeUserGradeParam::new()
        }

        fn clear(&mut self) {
            self.currentGrade = 0;
            self.displayConfig = 0;
            self.userId.clear();
            self.user.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BarrageTypeUserGradeParam {
            static instance: BarrageTypeUserGradeParam = BarrageTypeUserGradeParam {
                currentGrade: 0,
                displayConfig: 0,
                userId: ::std::string::String::new(),
                user: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BarrageTypeUserGradeParam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastBarrageMessage.BarrageTypeUserGradeParam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BarrageTypeUserGradeParam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BarrageTypeUserGradeParam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastBarrageMessage.BarrageTypeFansLevelParam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BarrageTypeFansLevelParam {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeFansLevelParam.currentGrade)
        pub currentGrade: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeFansLevelParam.displayConfig)
        pub displayConfig: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeFansLevelParam.user)
        pub user: ::protobuf::MessageField<super::super::data::User>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastBarrageMessage.BarrageTypeFansLevelParam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BarrageTypeFansLevelParam {
        fn default() -> &'a BarrageTypeFansLevelParam {
            <BarrageTypeFansLevelParam as ::protobuf::Message>::default_instance()
        }
    }

    impl BarrageTypeFansLevelParam {
        pub fn new() -> BarrageTypeFansLevelParam {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "currentGrade",
                |m: &BarrageTypeFansLevelParam| { &m.currentGrade },
                |m: &mut BarrageTypeFansLevelParam| { &mut m.currentGrade },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "displayConfig",
                |m: &BarrageTypeFansLevelParam| { &m.displayConfig },
                |m: &mut BarrageTypeFansLevelParam| { &mut m.displayConfig },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::User>(
                "user",
                |m: &BarrageTypeFansLevelParam| { &m.user },
                |m: &mut BarrageTypeFansLevelParam| { &mut m.user },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BarrageTypeFansLevelParam>(
                "WebcastBarrageMessage.BarrageTypeFansLevelParam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BarrageTypeFansLevelParam {
        const NAME: &'static str = "BarrageTypeFansLevelParam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.currentGrade = is.read_int32()?;
                    },
                    16 => {
                        self.displayConfig = is.read_int32()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.currentGrade != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.currentGrade);
            }
            if self.displayConfig != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.displayConfig);
            }
            if let Some(v) = self.user.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.currentGrade != 0 {
                os.write_int32(1, self.currentGrade)?;
            }
            if self.displayConfig != 0 {
                os.write_int32(2, self.displayConfig)?;
            }
            if let Some(v) = self.user.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BarrageTypeFansLevelParam {
            BarrageTypeFansLevelParam::new()
        }

        fn clear(&mut self) {
            self.currentGrade = 0;
            self.displayConfig = 0;
            self.user.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BarrageTypeFansLevelParam {
            static instance: BarrageTypeFansLevelParam = BarrageTypeFansLevelParam {
                currentGrade: 0,
                displayConfig: 0,
                user: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BarrageTypeFansLevelParam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastBarrageMessage.BarrageTypeFansLevelParam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BarrageTypeFansLevelParam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BarrageTypeFansLevelParam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastBarrageMessage.BarrageTypeSubscribeGiftParam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BarrageTypeSubscribeGiftParam {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeSubscribeGiftParam.giftSubCount)
        pub giftSubCount: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageTypeSubscribeGiftParam.showGiftSubCount)
        pub showGiftSubCount: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastBarrageMessage.BarrageTypeSubscribeGiftParam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BarrageTypeSubscribeGiftParam {
        fn default() -> &'a BarrageTypeSubscribeGiftParam {
            <BarrageTypeSubscribeGiftParam as ::protobuf::Message>::default_instance()
        }
    }

    impl BarrageTypeSubscribeGiftParam {
        pub fn new() -> BarrageTypeSubscribeGiftParam {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "giftSubCount",
                |m: &BarrageTypeSubscribeGiftParam| { &m.giftSubCount },
                |m: &mut BarrageTypeSubscribeGiftParam| { &mut m.giftSubCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "showGiftSubCount",
                |m: &BarrageTypeSubscribeGiftParam| { &m.showGiftSubCount },
                |m: &mut BarrageTypeSubscribeGiftParam| { &mut m.showGiftSubCount },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BarrageTypeSubscribeGiftParam>(
                "WebcastBarrageMessage.BarrageTypeSubscribeGiftParam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BarrageTypeSubscribeGiftParam {
        const NAME: &'static str = "BarrageTypeSubscribeGiftParam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.giftSubCount = is.read_int64()?;
                    },
                    16 => {
                        self.showGiftSubCount = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.giftSubCount != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.giftSubCount);
            }
            if self.showGiftSubCount != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.giftSubCount != 0 {
                os.write_int64(1, self.giftSubCount)?;
            }
            if self.showGiftSubCount != false {
                os.write_bool(2, self.showGiftSubCount)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BarrageTypeSubscribeGiftParam {
            BarrageTypeSubscribeGiftParam::new()
        }

        fn clear(&mut self) {
            self.giftSubCount = 0;
            self.showGiftSubCount = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BarrageTypeSubscribeGiftParam {
            static instance: BarrageTypeSubscribeGiftParam = BarrageTypeSubscribeGiftParam {
                giftSubCount: 0,
                showGiftSubCount: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BarrageTypeSubscribeGiftParam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastBarrageMessage.BarrageTypeSubscribeGiftParam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BarrageTypeSubscribeGiftParam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BarrageTypeSubscribeGiftParam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastBarrageMessage.BarrageEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BarrageEvent {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastBarrageMessage.BarrageEvent.eventName)
        pub eventName: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastBarrageMessage.BarrageEvent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BarrageEvent {
        fn default() -> &'a BarrageEvent {
            <BarrageEvent as ::protobuf::Message>::default_instance()
        }
    }

    impl BarrageEvent {
        pub fn new() -> BarrageEvent {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "eventName",
                |m: &BarrageEvent| { &m.eventName },
                |m: &mut BarrageEvent| { &mut m.eventName },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BarrageEvent>(
                "WebcastBarrageMessage.BarrageEvent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BarrageEvent {
        const NAME: &'static str = "BarrageEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.eventName = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.eventName.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.eventName);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.eventName.is_empty() {
                os.write_string(1, &self.eventName)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BarrageEvent {
            BarrageEvent::new()
        }

        fn clear(&mut self) {
            self.eventName.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BarrageEvent {
            static instance: BarrageEvent = BarrageEvent {
                eventName: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BarrageEvent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastBarrageMessage.BarrageEvent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BarrageEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BarrageEvent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TikTok.WebcastBarrageMessage.BarrageType)
    pub enum BarrageType {
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.ECOMORDERING)
        ECOMORDERING = 1,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.ECOMBUYING)
        ECOMBUYING = 2,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.NORMAL)
        NORMAL = 3,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.SUBSCRIBE)
        SUBSCRIBE = 4,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.EVENTVIEW)
        EVENTVIEW = 5,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.EVENTREGISTERED)
        EVENTREGISTERED = 6,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.SUBSCRIBEGIFT)
        SUBSCRIBEGIFT = 7,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.USERUPGRADE)
        USERUPGRADE = 8,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.GRADEUSERENTRANCENOTIFICATION)
        GRADEUSERENTRANCENOTIFICATION = 9,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.FANSLEVELUPGRADE)
        FANSLEVELUPGRADE = 10,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.FANSLEVELENTRANCE)
        FANSLEVELENTRANCE = 11,
        // @@protoc_insertion_point(enum_value:TikTok.WebcastBarrageMessage.BarrageType.GAMEPARTNERSHIP)
        GAMEPARTNERSHIP = 12,
    }

    impl ::protobuf::Enum for BarrageType {
        const NAME: &'static str = "BarrageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BarrageType> {
            match value {
                0 => ::std::option::Option::Some(BarrageType::UNKNOWN),
                1 => ::std::option::Option::Some(BarrageType::ECOMORDERING),
                2 => ::std::option::Option::Some(BarrageType::ECOMBUYING),
                3 => ::std::option::Option::Some(BarrageType::NORMAL),
                4 => ::std::option::Option::Some(BarrageType::SUBSCRIBE),
                5 => ::std::option::Option::Some(BarrageType::EVENTVIEW),
                6 => ::std::option::Option::Some(BarrageType::EVENTREGISTERED),
                7 => ::std::option::Option::Some(BarrageType::SUBSCRIBEGIFT),
                8 => ::std::option::Option::Some(BarrageType::USERUPGRADE),
                9 => ::std::option::Option::Some(BarrageType::GRADEUSERENTRANCENOTIFICATION),
                10 => ::std::option::Option::Some(BarrageType::FANSLEVELUPGRADE),
                11 => ::std::option::Option::Some(BarrageType::FANSLEVELENTRANCE),
                12 => ::std::option::Option::Some(BarrageType::GAMEPARTNERSHIP),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BarrageType> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(BarrageType::UNKNOWN),
                "ECOMORDERING" => ::std::option::Option::Some(BarrageType::ECOMORDERING),
                "ECOMBUYING" => ::std::option::Option::Some(BarrageType::ECOMBUYING),
                "NORMAL" => ::std::option::Option::Some(BarrageType::NORMAL),
                "SUBSCRIBE" => ::std::option::Option::Some(BarrageType::SUBSCRIBE),
                "EVENTVIEW" => ::std::option::Option::Some(BarrageType::EVENTVIEW),
                "EVENTREGISTERED" => ::std::option::Option::Some(BarrageType::EVENTREGISTERED),
                "SUBSCRIBEGIFT" => ::std::option::Option::Some(BarrageType::SUBSCRIBEGIFT),
                "USERUPGRADE" => ::std::option::Option::Some(BarrageType::USERUPGRADE),
                "GRADEUSERENTRANCENOTIFICATION" => ::std::option::Option::Some(BarrageType::GRADEUSERENTRANCENOTIFICATION),
                "FANSLEVELUPGRADE" => ::std::option::Option::Some(BarrageType::FANSLEVELUPGRADE),
                "FANSLEVELENTRANCE" => ::std::option::Option::Some(BarrageType::FANSLEVELENTRANCE),
                "GAMEPARTNERSHIP" => ::std::option::Option::Some(BarrageType::GAMEPARTNERSHIP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BarrageType] = &[
            BarrageType::UNKNOWN,
            BarrageType::ECOMORDERING,
            BarrageType::ECOMBUYING,
            BarrageType::NORMAL,
            BarrageType::SUBSCRIBE,
            BarrageType::EVENTVIEW,
            BarrageType::EVENTREGISTERED,
            BarrageType::SUBSCRIBEGIFT,
            BarrageType::USERUPGRADE,
            BarrageType::GRADEUSERENTRANCENOTIFICATION,
            BarrageType::FANSLEVELUPGRADE,
            BarrageType::FANSLEVELENTRANCE,
            BarrageType::GAMEPARTNERSHIP,
        ];
    }

    impl ::protobuf::EnumFull for BarrageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebcastBarrageMessage.BarrageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BarrageType {
        fn default() -> Self {
            BarrageType::UNKNOWN
        }
    }

    impl BarrageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BarrageType>("WebcastBarrageMessage.BarrageType")
        }
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastCaptionMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastCaptionMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastCaptionMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastCaptionMessage.timeStamp)
    pub timeStamp: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastCaptionMessage.captionData)
    pub captionData: ::protobuf::MessageField<webcast_caption_message::CaptionData>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastCaptionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastCaptionMessage {
    fn default() -> &'a WebcastCaptionMessage {
        <WebcastCaptionMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastCaptionMessage {
    pub fn new() -> WebcastCaptionMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastCaptionMessage| { &m.common },
            |m: &mut WebcastCaptionMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timeStamp",
            |m: &WebcastCaptionMessage| { &m.timeStamp },
            |m: &mut WebcastCaptionMessage| { &mut m.timeStamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_caption_message::CaptionData>(
            "captionData",
            |m: &WebcastCaptionMessage| { &m.captionData },
            |m: &mut WebcastCaptionMessage| { &mut m.captionData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastCaptionMessage>(
            "WebcastCaptionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastCaptionMessage {
    const NAME: &'static str = "WebcastCaptionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.timeStamp = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.captionData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.timeStamp != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.timeStamp);
        }
        if let Some(v) = self.captionData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.timeStamp != 0 {
            os.write_uint64(2, self.timeStamp)?;
        }
        if let Some(v) = self.captionData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastCaptionMessage {
        WebcastCaptionMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.timeStamp = 0;
        self.captionData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastCaptionMessage {
        static instance: WebcastCaptionMessage = WebcastCaptionMessage {
            common: ::protobuf::MessageField::none(),
            timeStamp: 0,
            captionData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastCaptionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastCaptionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastCaptionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastCaptionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastCaptionMessage`
pub mod webcast_caption_message {
    // @@protoc_insertion_point(message:TikTok.WebcastCaptionMessage.CaptionData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CaptionData {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastCaptionMessage.CaptionData.language)
        pub language: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastCaptionMessage.CaptionData.text)
        pub text: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastCaptionMessage.CaptionData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CaptionData {
        fn default() -> &'a CaptionData {
            <CaptionData as ::protobuf::Message>::default_instance()
        }
    }

    impl CaptionData {
        pub fn new() -> CaptionData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "language",
                |m: &CaptionData| { &m.language },
                |m: &mut CaptionData| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "text",
                |m: &CaptionData| { &m.text },
                |m: &mut CaptionData| { &mut m.text },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CaptionData>(
                "WebcastCaptionMessage.CaptionData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CaptionData {
        const NAME: &'static str = "CaptionData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = is.read_string()?;
                    },
                    18 => {
                        self.text = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.language.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.language);
            }
            if !self.text.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.text);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.language.is_empty() {
                os.write_string(1, &self.language)?;
            }
            if !self.text.is_empty() {
                os.write_string(2, &self.text)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CaptionData {
            CaptionData::new()
        }

        fn clear(&mut self) {
            self.language.clear();
            self.text.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CaptionData {
            static instance: CaptionData = CaptionData {
                language: ::std::string::String::new(),
                text: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CaptionData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastCaptionMessage.CaptionData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CaptionData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CaptionData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastChatMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.user)
    pub user: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.visibleToSender)
    pub visibleToSender: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.backgroundImage)
    pub backgroundImage: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.fullScreenTextColor)
    pub fullScreenTextColor: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.backgroundImageV2)
    pub backgroundImageV2: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.giftImage)
    pub giftImage: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.inputType)
    pub inputType: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.atUser)
    pub atUser: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.emotesList)
    pub emotesList: ::std::vec::Vec<webcast_chat_message::EmoteWithIndex>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.contentLanguage)
    pub contentLanguage: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.quickChatScene)
    pub quickChatScene: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.communityFlaggedStatus)
    pub communityFlaggedStatus: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.UserIdentity)
    pub UserIdentity: ::protobuf::MessageField<super::data::UserIdentity>,
    // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.CommentQualityScores)
    pub CommentQualityScores: ::std::collections::HashMap<i32, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastChatMessage {
    fn default() -> &'a WebcastChatMessage {
        <WebcastChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastChatMessage {
    pub fn new() -> WebcastChatMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastChatMessage| { &m.common },
            |m: &mut WebcastChatMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "user",
            |m: &WebcastChatMessage| { &m.user },
            |m: &mut WebcastChatMessage| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &WebcastChatMessage| { &m.content },
            |m: &mut WebcastChatMessage| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visibleToSender",
            |m: &WebcastChatMessage| { &m.visibleToSender },
            |m: &mut WebcastChatMessage| { &mut m.visibleToSender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "backgroundImage",
            |m: &WebcastChatMessage| { &m.backgroundImage },
            |m: &mut WebcastChatMessage| { &mut m.backgroundImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fullScreenTextColor",
            |m: &WebcastChatMessage| { &m.fullScreenTextColor },
            |m: &mut WebcastChatMessage| { &mut m.fullScreenTextColor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "backgroundImageV2",
            |m: &WebcastChatMessage| { &m.backgroundImageV2 },
            |m: &mut WebcastChatMessage| { &mut m.backgroundImageV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "giftImage",
            |m: &WebcastChatMessage| { &m.giftImage },
            |m: &mut WebcastChatMessage| { &mut m.giftImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputType",
            |m: &WebcastChatMessage| { &m.inputType },
            |m: &mut WebcastChatMessage| { &mut m.inputType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "atUser",
            |m: &WebcastChatMessage| { &m.atUser },
            |m: &mut WebcastChatMessage| { &mut m.atUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "emotesList",
            |m: &WebcastChatMessage| { &m.emotesList },
            |m: &mut WebcastChatMessage| { &mut m.emotesList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contentLanguage",
            |m: &WebcastChatMessage| { &m.contentLanguage },
            |m: &mut WebcastChatMessage| { &mut m.contentLanguage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "quickChatScene",
            |m: &WebcastChatMessage| { &m.quickChatScene },
            |m: &mut WebcastChatMessage| { &mut m.quickChatScene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "communityFlaggedStatus",
            |m: &WebcastChatMessage| { &m.communityFlaggedStatus },
            |m: &mut WebcastChatMessage| { &mut m.communityFlaggedStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::UserIdentity>(
            "UserIdentity",
            |m: &WebcastChatMessage| { &m.UserIdentity },
            |m: &mut WebcastChatMessage| { &mut m.UserIdentity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "CommentQualityScores",
            |m: &WebcastChatMessage| { &m.CommentQualityScores },
            |m: &mut WebcastChatMessage| { &mut m.CommentQualityScores },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastChatMessage>(
            "WebcastChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastChatMessage {
    const NAME: &'static str = "WebcastChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                26 => {
                    self.content = is.read_string()?;
                },
                32 => {
                    self.visibleToSender = is.read_bool()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backgroundImage)?;
                },
                50 => {
                    self.fullScreenTextColor = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backgroundImageV2)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.giftImage)?;
                },
                88 => {
                    self.inputType = is.read_int32()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.atUser)?;
                },
                106 => {
                    self.emotesList.push(is.read_message()?);
                },
                114 => {
                    self.contentLanguage = is.read_string()?;
                },
                128 => {
                    self.quickChatScene = is.read_int32()?;
                },
                136 => {
                    self.communityFlaggedStatus = is.read_int32()?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.UserIdentity)?;
                },
                154 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int32()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.CommentQualityScores.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.content);
        }
        if self.visibleToSender != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.backgroundImage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.fullScreenTextColor.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.fullScreenTextColor);
        }
        if let Some(v) = self.backgroundImageV2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.giftImage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.inputType != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.inputType);
        }
        if let Some(v) = self.atUser.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.emotesList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.contentLanguage.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.contentLanguage);
        }
        if self.quickChatScene != 0 {
            my_size += ::protobuf::rt::int32_size(16, self.quickChatScene);
        }
        if self.communityFlaggedStatus != 0 {
            my_size += ::protobuf::rt::int32_size(17, self.communityFlaggedStatus);
        }
        if let Some(v) = self.UserIdentity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.CommentQualityScores {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.content.is_empty() {
            os.write_string(3, &self.content)?;
        }
        if self.visibleToSender != false {
            os.write_bool(4, self.visibleToSender)?;
        }
        if let Some(v) = self.backgroundImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.fullScreenTextColor.is_empty() {
            os.write_string(6, &self.fullScreenTextColor)?;
        }
        if let Some(v) = self.backgroundImageV2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.giftImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.inputType != 0 {
            os.write_int32(11, self.inputType)?;
        }
        if let Some(v) = self.atUser.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.emotesList {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if !self.contentLanguage.is_empty() {
            os.write_string(14, &self.contentLanguage)?;
        }
        if self.quickChatScene != 0 {
            os.write_int32(16, self.quickChatScene)?;
        }
        if self.communityFlaggedStatus != 0 {
            os.write_int32(17, self.communityFlaggedStatus)?;
        }
        if let Some(v) = self.UserIdentity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        for (k, v) in &self.CommentQualityScores {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(154)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int32(1, *k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastChatMessage {
        WebcastChatMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.user.clear();
        self.content.clear();
        self.visibleToSender = false;
        self.backgroundImage.clear();
        self.fullScreenTextColor.clear();
        self.backgroundImageV2.clear();
        self.giftImage.clear();
        self.inputType = 0;
        self.atUser.clear();
        self.emotesList.clear();
        self.contentLanguage.clear();
        self.quickChatScene = 0;
        self.communityFlaggedStatus = 0;
        self.UserIdentity.clear();
        self.CommentQualityScores.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastChatMessage {
        static instance: ::protobuf::rt::Lazy<WebcastChatMessage> = ::protobuf::rt::Lazy::new();
        instance.get(WebcastChatMessage::new)
    }
}

impl ::protobuf::MessageFull for WebcastChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastChatMessage`
pub mod webcast_chat_message {
    // @@protoc_insertion_point(message:TikTok.WebcastChatMessage.EmoteWithIndex)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EmoteWithIndex {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.EmoteWithIndex.index)
        pub index: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastChatMessage.EmoteWithIndex.emote)
        pub emote: ::protobuf::MessageField<super::super::data::Emote>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastChatMessage.EmoteWithIndex.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EmoteWithIndex {
        fn default() -> &'a EmoteWithIndex {
            <EmoteWithIndex as ::protobuf::Message>::default_instance()
        }
    }

    impl EmoteWithIndex {
        pub fn new() -> EmoteWithIndex {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "index",
                |m: &EmoteWithIndex| { &m.index },
                |m: &mut EmoteWithIndex| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Emote>(
                "emote",
                |m: &EmoteWithIndex| { &m.emote },
                |m: &mut EmoteWithIndex| { &mut m.emote },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmoteWithIndex>(
                "WebcastChatMessage.EmoteWithIndex",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EmoteWithIndex {
        const NAME: &'static str = "EmoteWithIndex";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = is.read_int64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.emote)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.index != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.index);
            }
            if let Some(v) = self.emote.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.index != 0 {
                os.write_int64(1, self.index)?;
            }
            if let Some(v) = self.emote.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EmoteWithIndex {
            EmoteWithIndex::new()
        }

        fn clear(&mut self) {
            self.index = 0;
            self.emote.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EmoteWithIndex {
            static instance: EmoteWithIndex = EmoteWithIndex {
                index: 0,
                emote: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EmoteWithIndex {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastChatMessage.EmoteWithIndex").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EmoteWithIndex {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EmoteWithIndex {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastControlMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastControlMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.action)
    pub action: ::protobuf::EnumOrUnknown<super::enums::ControlAction>,
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.tips)
    pub tips: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.extra)
    pub extra: ::protobuf::MessageField<webcast_control_message::Extra>,
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.perceptionAudienceText)
    pub perceptionAudienceText: ::protobuf::MessageField<super::data::Text>,
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.punishInfo)
    pub punishInfo: ::protobuf::MessageField<super::data::PunishEventInfo>,
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.floatText)
    pub floatText: ::protobuf::MessageField<super::data::Text>,
    // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.floatStyle)
    pub floatStyle: i32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastControlMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastControlMessage {
    fn default() -> &'a WebcastControlMessage {
        <WebcastControlMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastControlMessage {
    pub fn new() -> WebcastControlMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastControlMessage| { &m.common },
            |m: &mut WebcastControlMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &WebcastControlMessage| { &m.action },
            |m: &mut WebcastControlMessage| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tips",
            |m: &WebcastControlMessage| { &m.tips },
            |m: &mut WebcastControlMessage| { &mut m.tips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_control_message::Extra>(
            "extra",
            |m: &WebcastControlMessage| { &m.extra },
            |m: &mut WebcastControlMessage| { &mut m.extra },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "perceptionAudienceText",
            |m: &WebcastControlMessage| { &m.perceptionAudienceText },
            |m: &mut WebcastControlMessage| { &mut m.perceptionAudienceText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::PunishEventInfo>(
            "punishInfo",
            |m: &WebcastControlMessage| { &m.punishInfo },
            |m: &mut WebcastControlMessage| { &mut m.punishInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "floatText",
            |m: &WebcastControlMessage| { &m.floatText },
            |m: &mut WebcastControlMessage| { &mut m.floatText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "floatStyle",
            |m: &WebcastControlMessage| { &m.floatStyle },
            |m: &mut WebcastControlMessage| { &mut m.floatStyle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastControlMessage>(
            "WebcastControlMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastControlMessage {
    const NAME: &'static str = "WebcastControlMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.action = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.tips = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extra)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.perceptionAudienceText)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.punishInfo)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.floatText)?;
                },
                72 => {
                    self.floatStyle = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(super::enums::ControlAction::ControlActionUNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.action.value());
        }
        if !self.tips.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.tips);
        }
        if let Some(v) = self.extra.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.perceptionAudienceText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.punishInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.floatText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.floatStyle != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.floatStyle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(super::enums::ControlAction::ControlActionUNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.action))?;
        }
        if !self.tips.is_empty() {
            os.write_string(3, &self.tips)?;
        }
        if let Some(v) = self.extra.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.perceptionAudienceText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.punishInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.floatText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.floatStyle != 0 {
            os.write_int32(9, self.floatStyle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastControlMessage {
        WebcastControlMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.action = ::protobuf::EnumOrUnknown::new(super::enums::ControlAction::ControlActionUNKNOWN);
        self.tips.clear();
        self.extra.clear();
        self.perceptionAudienceText.clear();
        self.punishInfo.clear();
        self.floatText.clear();
        self.floatStyle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastControlMessage {
        static instance: WebcastControlMessage = WebcastControlMessage {
            common: ::protobuf::MessageField::none(),
            action: ::protobuf::EnumOrUnknown::from_i32(0),
            tips: ::std::string::String::new(),
            extra: ::protobuf::MessageField::none(),
            perceptionAudienceText: ::protobuf::MessageField::none(),
            punishInfo: ::protobuf::MessageField::none(),
            floatText: ::protobuf::MessageField::none(),
            floatStyle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastControlMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastControlMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastControlMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastControlMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastControlMessage`
pub mod webcast_control_message {
    // @@protoc_insertion_point(message:TikTok.WebcastControlMessage.Extra)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Extra {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.banInfoUrl)
        pub banInfoUrl: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.reasonNo)
        pub reasonNo: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.title)
        pub title: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.violationReason)
        pub violationReason: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.content)
        pub content: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.gotItButton)
        pub gotItButton: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.banDetailButton)
        pub banDetailButton: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastControlMessage.Extra.source)
        pub source: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastControlMessage.Extra.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Extra {
        fn default() -> &'a Extra {
            <Extra as ::protobuf::Message>::default_instance()
        }
    }

    impl Extra {
        pub fn new() -> Extra {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "banInfoUrl",
                |m: &Extra| { &m.banInfoUrl },
                |m: &mut Extra| { &mut m.banInfoUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "reasonNo",
                |m: &Extra| { &m.reasonNo },
                |m: &mut Extra| { &mut m.reasonNo },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "title",
                |m: &Extra| { &m.title },
                |m: &mut Extra| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "violationReason",
                |m: &Extra| { &m.violationReason },
                |m: &mut Extra| { &mut m.violationReason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "content",
                |m: &Extra| { &m.content },
                |m: &mut Extra| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "gotItButton",
                |m: &Extra| { &m.gotItButton },
                |m: &mut Extra| { &mut m.gotItButton },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "banDetailButton",
                |m: &Extra| { &m.banDetailButton },
                |m: &mut Extra| { &mut m.banDetailButton },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "source",
                |m: &Extra| { &m.source },
                |m: &mut Extra| { &mut m.source },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Extra>(
                "WebcastControlMessage.Extra",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Extra {
        const NAME: &'static str = "Extra";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.banInfoUrl = is.read_string()?;
                    },
                    16 => {
                        self.reasonNo = is.read_int64()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.title)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.violationReason)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.content)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.gotItButton)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.banDetailButton)?;
                    },
                    66 => {
                        self.source = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.banInfoUrl.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.banInfoUrl);
            }
            if self.reasonNo != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.reasonNo);
            }
            if let Some(v) = self.title.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.violationReason.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.content.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.gotItButton.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.banDetailButton.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.source.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.source);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.banInfoUrl.is_empty() {
                os.write_string(1, &self.banInfoUrl)?;
            }
            if self.reasonNo != 0 {
                os.write_int64(2, self.reasonNo)?;
            }
            if let Some(v) = self.title.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.violationReason.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.content.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.gotItButton.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.banDetailButton.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if !self.source.is_empty() {
                os.write_string(8, &self.source)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Extra {
            Extra::new()
        }

        fn clear(&mut self) {
            self.banInfoUrl.clear();
            self.reasonNo = 0;
            self.title.clear();
            self.violationReason.clear();
            self.content.clear();
            self.gotItButton.clear();
            self.banDetailButton.clear();
            self.source.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Extra {
            static instance: Extra = Extra {
                banInfoUrl: ::std::string::String::new(),
                reasonNo: 0,
                title: ::protobuf::MessageField::none(),
                violationReason: ::protobuf::MessageField::none(),
                content: ::protobuf::MessageField::none(),
                gotItButton: ::protobuf::MessageField::none(),
                banDetailButton: ::protobuf::MessageField::none(),
                source: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Extra {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastControlMessage.Extra").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Extra {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Extra {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastEmoteChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastEmoteChatMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastEmoteChatMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastEmoteChatMessage.user)
    pub user: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastEmoteChatMessage.emoteList)
    pub emoteList: ::std::vec::Vec<super::data::Emote>,
    // @@protoc_insertion_point(field:TikTok.WebcastEmoteChatMessage.msgFilter)
    pub msgFilter: ::protobuf::MessageField<super::data::MsgFilter>,
    // @@protoc_insertion_point(field:TikTok.WebcastEmoteChatMessage.userIdentity)
    pub userIdentity: ::protobuf::MessageField<super::data::UserIdentity>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastEmoteChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastEmoteChatMessage {
    fn default() -> &'a WebcastEmoteChatMessage {
        <WebcastEmoteChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastEmoteChatMessage {
    pub fn new() -> WebcastEmoteChatMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastEmoteChatMessage| { &m.common },
            |m: &mut WebcastEmoteChatMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "user",
            |m: &WebcastEmoteChatMessage| { &m.user },
            |m: &mut WebcastEmoteChatMessage| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "emoteList",
            |m: &WebcastEmoteChatMessage| { &m.emoteList },
            |m: &mut WebcastEmoteChatMessage| { &mut m.emoteList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::MsgFilter>(
            "msgFilter",
            |m: &WebcastEmoteChatMessage| { &m.msgFilter },
            |m: &mut WebcastEmoteChatMessage| { &mut m.msgFilter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::UserIdentity>(
            "userIdentity",
            |m: &WebcastEmoteChatMessage| { &m.userIdentity },
            |m: &mut WebcastEmoteChatMessage| { &mut m.userIdentity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastEmoteChatMessage>(
            "WebcastEmoteChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastEmoteChatMessage {
    const NAME: &'static str = "WebcastEmoteChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                26 => {
                    self.emoteList.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.msgFilter)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userIdentity)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.emoteList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.msgFilter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.userIdentity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.emoteList {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.msgFilter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.userIdentity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastEmoteChatMessage {
        WebcastEmoteChatMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.user.clear();
        self.emoteList.clear();
        self.msgFilter.clear();
        self.userIdentity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastEmoteChatMessage {
        static instance: WebcastEmoteChatMessage = WebcastEmoteChatMessage {
            common: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            emoteList: ::std::vec::Vec::new(),
            msgFilter: ::protobuf::MessageField::none(),
            userIdentity: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastEmoteChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastEmoteChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastEmoteChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastEmoteChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastEnvelopeMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastEnvelopeMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.envelopeInfo)
    pub envelopeInfo: ::protobuf::MessageField<webcast_envelope_message::EnvelopeInfo>,
    // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.display)
    pub display: ::protobuf::EnumOrUnknown<super::enums::EnvelopeDisplay>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastEnvelopeMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastEnvelopeMessage {
    fn default() -> &'a WebcastEnvelopeMessage {
        <WebcastEnvelopeMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastEnvelopeMessage {
    pub fn new() -> WebcastEnvelopeMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastEnvelopeMessage| { &m.common },
            |m: &mut WebcastEnvelopeMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_envelope_message::EnvelopeInfo>(
            "envelopeInfo",
            |m: &WebcastEnvelopeMessage| { &m.envelopeInfo },
            |m: &mut WebcastEnvelopeMessage| { &mut m.envelopeInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display",
            |m: &WebcastEnvelopeMessage| { &m.display },
            |m: &mut WebcastEnvelopeMessage| { &mut m.display },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastEnvelopeMessage>(
            "WebcastEnvelopeMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastEnvelopeMessage {
    const NAME: &'static str = "WebcastEnvelopeMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.envelopeInfo)?;
                },
                24 => {
                    self.display = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.envelopeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.display != ::protobuf::EnumOrUnknown::new(super::enums::EnvelopeDisplay::EnvelopeDisplayUnknown) {
            my_size += ::protobuf::rt::int32_size(3, self.display.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.envelopeInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.display != ::protobuf::EnumOrUnknown::new(super::enums::EnvelopeDisplay::EnvelopeDisplayUnknown) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.display))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastEnvelopeMessage {
        WebcastEnvelopeMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.envelopeInfo.clear();
        self.display = ::protobuf::EnumOrUnknown::new(super::enums::EnvelopeDisplay::EnvelopeDisplayUnknown);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastEnvelopeMessage {
        static instance: WebcastEnvelopeMessage = WebcastEnvelopeMessage {
            common: ::protobuf::MessageField::none(),
            envelopeInfo: ::protobuf::MessageField::none(),
            display: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastEnvelopeMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastEnvelopeMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastEnvelopeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastEnvelopeMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastEnvelopeMessage`
pub mod webcast_envelope_message {
    // @@protoc_insertion_point(message:TikTok.WebcastEnvelopeMessage.EnvelopeInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EnvelopeInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.envelopeId)
        pub envelopeId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.businessType)
        pub businessType: ::protobuf::EnumOrUnknown<super::super::enums::EnvelopeBusinessType>,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.envelopeIdc)
        pub envelopeIdc: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.sendUserName)
        pub sendUserName: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.diamondCount)
        pub diamondCount: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.peopleCount)
        pub peopleCount: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.unpackAt)
        pub unpackAt: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.sendUserId)
        pub sendUserId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.sendUserAvatar)
        pub sendUserAvatar: ::protobuf::MessageField<super::super::data::Image>,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.createAt)
        pub createAt: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.roomId)
        pub roomId: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.followShowStatus)
        pub followShowStatus: ::protobuf::EnumOrUnknown<super::super::enums::EnvelopeFollowShowStatus>,
        // @@protoc_insertion_point(field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.skinId)
        pub skinId: i32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastEnvelopeMessage.EnvelopeInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EnvelopeInfo {
        fn default() -> &'a EnvelopeInfo {
            <EnvelopeInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl EnvelopeInfo {
        pub fn new() -> EnvelopeInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "envelopeId",
                |m: &EnvelopeInfo| { &m.envelopeId },
                |m: &mut EnvelopeInfo| { &mut m.envelopeId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "businessType",
                |m: &EnvelopeInfo| { &m.businessType },
                |m: &mut EnvelopeInfo| { &mut m.businessType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "envelopeIdc",
                |m: &EnvelopeInfo| { &m.envelopeIdc },
                |m: &mut EnvelopeInfo| { &mut m.envelopeIdc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sendUserName",
                |m: &EnvelopeInfo| { &m.sendUserName },
                |m: &mut EnvelopeInfo| { &mut m.sendUserName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "diamondCount",
                |m: &EnvelopeInfo| { &m.diamondCount },
                |m: &mut EnvelopeInfo| { &mut m.diamondCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "peopleCount",
                |m: &EnvelopeInfo| { &m.peopleCount },
                |m: &mut EnvelopeInfo| { &mut m.peopleCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "unpackAt",
                |m: &EnvelopeInfo| { &m.unpackAt },
                |m: &mut EnvelopeInfo| { &mut m.unpackAt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sendUserId",
                |m: &EnvelopeInfo| { &m.sendUserId },
                |m: &mut EnvelopeInfo| { &mut m.sendUserId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Image>(
                "sendUserAvatar",
                |m: &EnvelopeInfo| { &m.sendUserAvatar },
                |m: &mut EnvelopeInfo| { &mut m.sendUserAvatar },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "createAt",
                |m: &EnvelopeInfo| { &m.createAt },
                |m: &mut EnvelopeInfo| { &mut m.createAt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "roomId",
                |m: &EnvelopeInfo| { &m.roomId },
                |m: &mut EnvelopeInfo| { &mut m.roomId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "followShowStatus",
                |m: &EnvelopeInfo| { &m.followShowStatus },
                |m: &mut EnvelopeInfo| { &mut m.followShowStatus },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "skinId",
                |m: &EnvelopeInfo| { &m.skinId },
                |m: &mut EnvelopeInfo| { &mut m.skinId },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnvelopeInfo>(
                "WebcastEnvelopeMessage.EnvelopeInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EnvelopeInfo {
        const NAME: &'static str = "EnvelopeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.envelopeId = is.read_string()?;
                    },
                    16 => {
                        self.businessType = is.read_enum_or_unknown()?;
                    },
                    26 => {
                        self.envelopeIdc = is.read_string()?;
                    },
                    34 => {
                        self.sendUserName = is.read_string()?;
                    },
                    40 => {
                        self.diamondCount = is.read_int32()?;
                    },
                    48 => {
                        self.peopleCount = is.read_int32()?;
                    },
                    56 => {
                        self.unpackAt = is.read_int32()?;
                    },
                    66 => {
                        self.sendUserId = is.read_string()?;
                    },
                    74 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.sendUserAvatar)?;
                    },
                    82 => {
                        self.createAt = is.read_string()?;
                    },
                    90 => {
                        self.roomId = is.read_string()?;
                    },
                    96 => {
                        self.followShowStatus = is.read_enum_or_unknown()?;
                    },
                    104 => {
                        self.skinId = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.envelopeId.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.envelopeId);
            }
            if self.businessType != ::protobuf::EnumOrUnknown::new(super::super::enums::EnvelopeBusinessType::BusinessTypeUnknown) {
                my_size += ::protobuf::rt::int32_size(2, self.businessType.value());
            }
            if !self.envelopeIdc.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.envelopeIdc);
            }
            if !self.sendUserName.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.sendUserName);
            }
            if self.diamondCount != 0 {
                my_size += ::protobuf::rt::int32_size(5, self.diamondCount);
            }
            if self.peopleCount != 0 {
                my_size += ::protobuf::rt::int32_size(6, self.peopleCount);
            }
            if self.unpackAt != 0 {
                my_size += ::protobuf::rt::int32_size(7, self.unpackAt);
            }
            if !self.sendUserId.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.sendUserId);
            }
            if let Some(v) = self.sendUserAvatar.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.createAt.is_empty() {
                my_size += ::protobuf::rt::string_size(10, &self.createAt);
            }
            if !self.roomId.is_empty() {
                my_size += ::protobuf::rt::string_size(11, &self.roomId);
            }
            if self.followShowStatus != ::protobuf::EnumOrUnknown::new(super::super::enums::EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown) {
                my_size += ::protobuf::rt::int32_size(12, self.followShowStatus.value());
            }
            if self.skinId != 0 {
                my_size += ::protobuf::rt::int32_size(13, self.skinId);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.envelopeId.is_empty() {
                os.write_string(1, &self.envelopeId)?;
            }
            if self.businessType != ::protobuf::EnumOrUnknown::new(super::super::enums::EnvelopeBusinessType::BusinessTypeUnknown) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.businessType))?;
            }
            if !self.envelopeIdc.is_empty() {
                os.write_string(3, &self.envelopeIdc)?;
            }
            if !self.sendUserName.is_empty() {
                os.write_string(4, &self.sendUserName)?;
            }
            if self.diamondCount != 0 {
                os.write_int32(5, self.diamondCount)?;
            }
            if self.peopleCount != 0 {
                os.write_int32(6, self.peopleCount)?;
            }
            if self.unpackAt != 0 {
                os.write_int32(7, self.unpackAt)?;
            }
            if !self.sendUserId.is_empty() {
                os.write_string(8, &self.sendUserId)?;
            }
            if let Some(v) = self.sendUserAvatar.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            if !self.createAt.is_empty() {
                os.write_string(10, &self.createAt)?;
            }
            if !self.roomId.is_empty() {
                os.write_string(11, &self.roomId)?;
            }
            if self.followShowStatus != ::protobuf::EnumOrUnknown::new(super::super::enums::EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown) {
                os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.followShowStatus))?;
            }
            if self.skinId != 0 {
                os.write_int32(13, self.skinId)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EnvelopeInfo {
            EnvelopeInfo::new()
        }

        fn clear(&mut self) {
            self.envelopeId.clear();
            self.businessType = ::protobuf::EnumOrUnknown::new(super::super::enums::EnvelopeBusinessType::BusinessTypeUnknown);
            self.envelopeIdc.clear();
            self.sendUserName.clear();
            self.diamondCount = 0;
            self.peopleCount = 0;
            self.unpackAt = 0;
            self.sendUserId.clear();
            self.sendUserAvatar.clear();
            self.createAt.clear();
            self.roomId.clear();
            self.followShowStatus = ::protobuf::EnumOrUnknown::new(super::super::enums::EnvelopeFollowShowStatus::EnvelopeFollowShowUnknown);
            self.skinId = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EnvelopeInfo {
            static instance: EnvelopeInfo = EnvelopeInfo {
                envelopeId: ::std::string::String::new(),
                businessType: ::protobuf::EnumOrUnknown::from_i32(0),
                envelopeIdc: ::std::string::String::new(),
                sendUserName: ::std::string::String::new(),
                diamondCount: 0,
                peopleCount: 0,
                unpackAt: 0,
                sendUserId: ::std::string::String::new(),
                sendUserAvatar: ::protobuf::MessageField::none(),
                createAt: ::std::string::String::new(),
                roomId: ::std::string::String::new(),
                followShowStatus: ::protobuf::EnumOrUnknown::from_i32(0),
                skinId: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EnvelopeInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastEnvelopeMessage.EnvelopeInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EnvelopeInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EnvelopeInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastGoalUpdateMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastGoalUpdateMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.indicator)
    pub indicator: ::protobuf::MessageField<super::data::Indicator>,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.goal)
    pub goal: ::protobuf::MessageField<super::data::Goal>,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.contributorId)
    pub contributorId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.contributorAvatar)
    pub contributorAvatar: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.contributorDisplayId)
    pub contributorDisplayId: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.contributeCount)
    pub contributeCount: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.contributeScore)
    pub contributeScore: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.giftRepeatCount)
    pub giftRepeatCount: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.contributorIdStr)
    pub contributorIdStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.pin)
    pub pin: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastGoalUpdateMessage.unpin)
    pub unpin: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastGoalUpdateMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastGoalUpdateMessage {
    fn default() -> &'a WebcastGoalUpdateMessage {
        <WebcastGoalUpdateMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastGoalUpdateMessage {
    pub fn new() -> WebcastGoalUpdateMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastGoalUpdateMessage| { &m.common },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Indicator>(
            "indicator",
            |m: &WebcastGoalUpdateMessage| { &m.indicator },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.indicator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Goal>(
            "goal",
            |m: &WebcastGoalUpdateMessage| { &m.goal },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.goal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contributorId",
            |m: &WebcastGoalUpdateMessage| { &m.contributorId },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.contributorId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "contributorAvatar",
            |m: &WebcastGoalUpdateMessage| { &m.contributorAvatar },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.contributorAvatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contributorDisplayId",
            |m: &WebcastGoalUpdateMessage| { &m.contributorDisplayId },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.contributorDisplayId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contributeCount",
            |m: &WebcastGoalUpdateMessage| { &m.contributeCount },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.contributeCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contributeScore",
            |m: &WebcastGoalUpdateMessage| { &m.contributeScore },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.contributeScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "giftRepeatCount",
            |m: &WebcastGoalUpdateMessage| { &m.giftRepeatCount },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.giftRepeatCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contributorIdStr",
            |m: &WebcastGoalUpdateMessage| { &m.contributorIdStr },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.contributorIdStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pin",
            |m: &WebcastGoalUpdateMessage| { &m.pin },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.pin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unpin",
            |m: &WebcastGoalUpdateMessage| { &m.unpin },
            |m: &mut WebcastGoalUpdateMessage| { &mut m.unpin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastGoalUpdateMessage>(
            "WebcastGoalUpdateMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastGoalUpdateMessage {
    const NAME: &'static str = "WebcastGoalUpdateMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.indicator)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.goal)?;
                },
                32 => {
                    self.contributorId = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contributorAvatar)?;
                },
                50 => {
                    self.contributorDisplayId = is.read_string()?;
                },
                72 => {
                    self.contributeCount = is.read_int64()?;
                },
                80 => {
                    self.contributeScore = is.read_int64()?;
                },
                88 => {
                    self.giftRepeatCount = is.read_int64()?;
                },
                98 => {
                    self.contributorIdStr = is.read_string()?;
                },
                104 => {
                    self.pin = is.read_bool()?;
                },
                112 => {
                    self.unpin = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.indicator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.goal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.contributorId != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.contributorId);
        }
        if let Some(v) = self.contributorAvatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.contributorDisplayId.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.contributorDisplayId);
        }
        if self.contributeCount != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.contributeCount);
        }
        if self.contributeScore != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.contributeScore);
        }
        if self.giftRepeatCount != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.giftRepeatCount);
        }
        if !self.contributorIdStr.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.contributorIdStr);
        }
        if self.pin != false {
            my_size += 1 + 1;
        }
        if self.unpin != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.indicator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.goal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.contributorId != 0 {
            os.write_int64(4, self.contributorId)?;
        }
        if let Some(v) = self.contributorAvatar.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.contributorDisplayId.is_empty() {
            os.write_string(6, &self.contributorDisplayId)?;
        }
        if self.contributeCount != 0 {
            os.write_int64(9, self.contributeCount)?;
        }
        if self.contributeScore != 0 {
            os.write_int64(10, self.contributeScore)?;
        }
        if self.giftRepeatCount != 0 {
            os.write_int64(11, self.giftRepeatCount)?;
        }
        if !self.contributorIdStr.is_empty() {
            os.write_string(12, &self.contributorIdStr)?;
        }
        if self.pin != false {
            os.write_bool(13, self.pin)?;
        }
        if self.unpin != false {
            os.write_bool(14, self.unpin)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastGoalUpdateMessage {
        WebcastGoalUpdateMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.indicator.clear();
        self.goal.clear();
        self.contributorId = 0;
        self.contributorAvatar.clear();
        self.contributorDisplayId.clear();
        self.contributeCount = 0;
        self.contributeScore = 0;
        self.giftRepeatCount = 0;
        self.contributorIdStr.clear();
        self.pin = false;
        self.unpin = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastGoalUpdateMessage {
        static instance: WebcastGoalUpdateMessage = WebcastGoalUpdateMessage {
            common: ::protobuf::MessageField::none(),
            indicator: ::protobuf::MessageField::none(),
            goal: ::protobuf::MessageField::none(),
            contributorId: 0,
            contributorAvatar: ::protobuf::MessageField::none(),
            contributorDisplayId: ::std::string::String::new(),
            contributeCount: 0,
            contributeScore: 0,
            giftRepeatCount: 0,
            contributorIdStr: ::std::string::String::new(),
            pin: false,
            unpin: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastGoalUpdateMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastGoalUpdateMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastGoalUpdateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastGoalUpdateMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastImDeleteMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastImDeleteMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastImDeleteMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastImDeleteMessage.deleteMsgIdsList)
    pub deleteMsgIdsList: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:TikTok.WebcastImDeleteMessage.deleteUserIdsList)
    pub deleteUserIdsList: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastImDeleteMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastImDeleteMessage {
    fn default() -> &'a WebcastImDeleteMessage {
        <WebcastImDeleteMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastImDeleteMessage {
    pub fn new() -> WebcastImDeleteMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastImDeleteMessage| { &m.common },
            |m: &mut WebcastImDeleteMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deleteMsgIdsList",
            |m: &WebcastImDeleteMessage| { &m.deleteMsgIdsList },
            |m: &mut WebcastImDeleteMessage| { &mut m.deleteMsgIdsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deleteUserIdsList",
            |m: &WebcastImDeleteMessage| { &m.deleteUserIdsList },
            |m: &mut WebcastImDeleteMessage| { &mut m.deleteUserIdsList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastImDeleteMessage>(
            "WebcastImDeleteMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastImDeleteMessage {
    const NAME: &'static str = "WebcastImDeleteMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    is.read_repeated_packed_int64_into(&mut self.deleteMsgIdsList)?;
                },
                16 => {
                    self.deleteMsgIdsList.push(is.read_int64()?);
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.deleteUserIdsList)?;
                },
                24 => {
                    self.deleteUserIdsList.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.deleteMsgIdsList {
            my_size += ::protobuf::rt::int64_size(2, *value);
        };
        for value in &self.deleteUserIdsList {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.deleteMsgIdsList {
            os.write_int64(2, *v)?;
        };
        for v in &self.deleteUserIdsList {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastImDeleteMessage {
        WebcastImDeleteMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.deleteMsgIdsList.clear();
        self.deleteUserIdsList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastImDeleteMessage {
        static instance: WebcastImDeleteMessage = WebcastImDeleteMessage {
            common: ::protobuf::MessageField::none(),
            deleteMsgIdsList: ::std::vec::Vec::new(),
            deleteUserIdsList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastImDeleteMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastImDeleteMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastImDeleteMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastImDeleteMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastInRoomBannerMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastInRoomBannerMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastInRoomBannerMessage.header)
    pub header: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastInRoomBannerMessage.json)
    pub json: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastInRoomBannerMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastInRoomBannerMessage {
    fn default() -> &'a WebcastInRoomBannerMessage {
        <WebcastInRoomBannerMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastInRoomBannerMessage {
    pub fn new() -> WebcastInRoomBannerMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "header",
            |m: &WebcastInRoomBannerMessage| { &m.header },
            |m: &mut WebcastInRoomBannerMessage| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "json",
            |m: &WebcastInRoomBannerMessage| { &m.json },
            |m: &mut WebcastInRoomBannerMessage| { &mut m.json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastInRoomBannerMessage>(
            "WebcastInRoomBannerMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastInRoomBannerMessage {
    const NAME: &'static str = "WebcastInRoomBannerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.json = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.json.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.json.is_empty() {
            os.write_string(2, &self.json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastInRoomBannerMessage {
        WebcastInRoomBannerMessage::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastInRoomBannerMessage {
        static instance: WebcastInRoomBannerMessage = WebcastInRoomBannerMessage {
            header: ::protobuf::MessageField::none(),
            json: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastInRoomBannerMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastInRoomBannerMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastInRoomBannerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastInRoomBannerMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastLikeMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLikeMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLikeMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLikeMessage.count)
    pub count: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastLikeMessage.total)
    pub total: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastLikeMessage.user)
    pub user: ::protobuf::MessageField<super::data::User>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLikeMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLikeMessage {
    fn default() -> &'a WebcastLikeMessage {
        <WebcastLikeMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLikeMessage {
    pub fn new() -> WebcastLikeMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLikeMessage| { &m.common },
            |m: &mut WebcastLikeMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &WebcastLikeMessage| { &m.count },
            |m: &mut WebcastLikeMessage| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &WebcastLikeMessage| { &m.total },
            |m: &mut WebcastLikeMessage| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "user",
            |m: &WebcastLikeMessage| { &m.user },
            |m: &mut WebcastLikeMessage| { &mut m.user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLikeMessage>(
            "WebcastLikeMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLikeMessage {
    const NAME: &'static str = "WebcastLikeMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.count = is.read_int32()?;
                },
                24 => {
                    self.total = is.read_int32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.count);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.total);
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.count != 0 {
            os.write_int32(2, self.count)?;
        }
        if self.total != 0 {
            os.write_int32(3, self.total)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLikeMessage {
        WebcastLikeMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.count = 0;
        self.total = 0;
        self.user.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLikeMessage {
        static instance: WebcastLikeMessage = WebcastLikeMessage {
            common: ::protobuf::MessageField::none(),
            count: 0,
            total: 0,
            user: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLikeMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLikeMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLikeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLikeMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastRoomUserSeqMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastRoomUserSeqMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.ranksList)
    pub ranksList: ::std::vec::Vec<webcast_room_user_seq_message::Contributor>,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.total)
    pub total: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.popStr)
    pub popStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.seatsList)
    pub seatsList: ::std::vec::Vec<webcast_room_user_seq_message::Contributor>,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.popularity)
    pub popularity: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.totalUser)
    pub totalUser: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.anonymous)
    pub anonymous: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastRoomUserSeqMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastRoomUserSeqMessage {
    fn default() -> &'a WebcastRoomUserSeqMessage {
        <WebcastRoomUserSeqMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastRoomUserSeqMessage {
    pub fn new() -> WebcastRoomUserSeqMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastRoomUserSeqMessage| { &m.common },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ranksList",
            |m: &WebcastRoomUserSeqMessage| { &m.ranksList },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.ranksList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &WebcastRoomUserSeqMessage| { &m.total },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "popStr",
            |m: &WebcastRoomUserSeqMessage| { &m.popStr },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.popStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "seatsList",
            |m: &WebcastRoomUserSeqMessage| { &m.seatsList },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.seatsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "popularity",
            |m: &WebcastRoomUserSeqMessage| { &m.popularity },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.popularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "totalUser",
            |m: &WebcastRoomUserSeqMessage| { &m.totalUser },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.totalUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "anonymous",
            |m: &WebcastRoomUserSeqMessage| { &m.anonymous },
            |m: &mut WebcastRoomUserSeqMessage| { &mut m.anonymous },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastRoomUserSeqMessage>(
            "WebcastRoomUserSeqMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastRoomUserSeqMessage {
    const NAME: &'static str = "WebcastRoomUserSeqMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    self.ranksList.push(is.read_message()?);
                },
                24 => {
                    self.total = is.read_int64()?;
                },
                34 => {
                    self.popStr = is.read_string()?;
                },
                42 => {
                    self.seatsList.push(is.read_message()?);
                },
                48 => {
                    self.popularity = is.read_int64()?;
                },
                56 => {
                    self.totalUser = is.read_int32()?;
                },
                64 => {
                    self.anonymous = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ranksList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.total != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.total);
        }
        if !self.popStr.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.popStr);
        }
        for value in &self.seatsList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.popularity != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.popularity);
        }
        if self.totalUser != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.totalUser);
        }
        if self.anonymous != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.anonymous);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ranksList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.total != 0 {
            os.write_int64(3, self.total)?;
        }
        if !self.popStr.is_empty() {
            os.write_string(4, &self.popStr)?;
        }
        for v in &self.seatsList {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.popularity != 0 {
            os.write_int64(6, self.popularity)?;
        }
        if self.totalUser != 0 {
            os.write_int32(7, self.totalUser)?;
        }
        if self.anonymous != 0 {
            os.write_int64(8, self.anonymous)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastRoomUserSeqMessage {
        WebcastRoomUserSeqMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.ranksList.clear();
        self.total = 0;
        self.popStr.clear();
        self.seatsList.clear();
        self.popularity = 0;
        self.totalUser = 0;
        self.anonymous = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastRoomUserSeqMessage {
        static instance: WebcastRoomUserSeqMessage = WebcastRoomUserSeqMessage {
            common: ::protobuf::MessageField::none(),
            ranksList: ::std::vec::Vec::new(),
            total: 0,
            popStr: ::std::string::String::new(),
            seatsList: ::std::vec::Vec::new(),
            popularity: 0,
            totalUser: 0,
            anonymous: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastRoomUserSeqMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastRoomUserSeqMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastRoomUserSeqMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastRoomUserSeqMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastRoomUserSeqMessage`
pub mod webcast_room_user_seq_message {
    // @@protoc_insertion_point(message:TikTok.WebcastRoomUserSeqMessage.Contributor)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Contributor {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.Contributor.score)
        pub score: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.Contributor.user)
        pub user: ::protobuf::MessageField<super::super::data::User>,
        // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.Contributor.rank)
        pub rank: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastRoomUserSeqMessage.Contributor.delta)
        pub delta: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastRoomUserSeqMessage.Contributor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Contributor {
        fn default() -> &'a Contributor {
            <Contributor as ::protobuf::Message>::default_instance()
        }
    }

    impl Contributor {
        pub fn new() -> Contributor {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "score",
                |m: &Contributor| { &m.score },
                |m: &mut Contributor| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::User>(
                "user",
                |m: &Contributor| { &m.user },
                |m: &mut Contributor| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rank",
                |m: &Contributor| { &m.rank },
                |m: &mut Contributor| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "delta",
                |m: &Contributor| { &m.delta },
                |m: &mut Contributor| { &mut m.delta },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Contributor>(
                "WebcastRoomUserSeqMessage.Contributor",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Contributor {
        const NAME: &'static str = "Contributor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.score = is.read_int32()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                    },
                    24 => {
                        self.rank = is.read_int32()?;
                    },
                    32 => {
                        self.delta = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.score != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.score);
            }
            if let Some(v) = self.user.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.rank != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.rank);
            }
            if self.delta != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.delta);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.score != 0 {
                os.write_int32(1, self.score)?;
            }
            if let Some(v) = self.user.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.rank != 0 {
                os.write_int32(3, self.rank)?;
            }
            if self.delta != 0 {
                os.write_int64(4, self.delta)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Contributor {
            Contributor::new()
        }

        fn clear(&mut self) {
            self.score = 0;
            self.user.clear();
            self.rank = 0;
            self.delta = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Contributor {
            static instance: Contributor = Contributor {
                score: 0,
                user: ::protobuf::MessageField::none(),
                rank: 0,
                delta: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Contributor {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastRoomUserSeqMessage.Contributor").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Contributor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Contributor {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastSocialMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastSocialMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.user)
    pub user: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.shareType)
    pub shareType: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.action)
    pub action: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.shareTarget)
    pub shareTarget: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.followCount)
    pub followCount: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.shareDisplayStyle)
    pub shareDisplayStyle: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastSocialMessage.shareCount)
    pub shareCount: i32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastSocialMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastSocialMessage {
    fn default() -> &'a WebcastSocialMessage {
        <WebcastSocialMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastSocialMessage {
    pub fn new() -> WebcastSocialMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastSocialMessage| { &m.common },
            |m: &mut WebcastSocialMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "user",
            |m: &WebcastSocialMessage| { &m.user },
            |m: &mut WebcastSocialMessage| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shareType",
            |m: &WebcastSocialMessage| { &m.shareType },
            |m: &mut WebcastSocialMessage| { &mut m.shareType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &WebcastSocialMessage| { &m.action },
            |m: &mut WebcastSocialMessage| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shareTarget",
            |m: &WebcastSocialMessage| { &m.shareTarget },
            |m: &mut WebcastSocialMessage| { &mut m.shareTarget },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "followCount",
            |m: &WebcastSocialMessage| { &m.followCount },
            |m: &mut WebcastSocialMessage| { &mut m.followCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shareDisplayStyle",
            |m: &WebcastSocialMessage| { &m.shareDisplayStyle },
            |m: &mut WebcastSocialMessage| { &mut m.shareDisplayStyle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shareCount",
            |m: &WebcastSocialMessage| { &m.shareCount },
            |m: &mut WebcastSocialMessage| { &mut m.shareCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastSocialMessage>(
            "WebcastSocialMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastSocialMessage {
    const NAME: &'static str = "WebcastSocialMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                24 => {
                    self.shareType = is.read_int64()?;
                },
                32 => {
                    self.action = is.read_int64()?;
                },
                42 => {
                    self.shareTarget = is.read_string()?;
                },
                48 => {
                    self.followCount = is.read_int32()?;
                },
                56 => {
                    self.shareDisplayStyle = is.read_int64()?;
                },
                64 => {
                    self.shareCount = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.shareType != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.shareType);
        }
        if self.action != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.action);
        }
        if !self.shareTarget.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.shareTarget);
        }
        if self.followCount != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.followCount);
        }
        if self.shareDisplayStyle != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.shareDisplayStyle);
        }
        if self.shareCount != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.shareCount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.shareType != 0 {
            os.write_int64(3, self.shareType)?;
        }
        if self.action != 0 {
            os.write_int64(4, self.action)?;
        }
        if !self.shareTarget.is_empty() {
            os.write_string(5, &self.shareTarget)?;
        }
        if self.followCount != 0 {
            os.write_int32(6, self.followCount)?;
        }
        if self.shareDisplayStyle != 0 {
            os.write_int64(7, self.shareDisplayStyle)?;
        }
        if self.shareCount != 0 {
            os.write_int32(8, self.shareCount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastSocialMessage {
        WebcastSocialMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.user.clear();
        self.shareType = 0;
        self.action = 0;
        self.shareTarget.clear();
        self.followCount = 0;
        self.shareDisplayStyle = 0;
        self.shareCount = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastSocialMessage {
        static instance: WebcastSocialMessage = WebcastSocialMessage {
            common: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            shareType: 0,
            action: 0,
            shareTarget: ::std::string::String::new(),
            followCount: 0,
            shareDisplayStyle: 0,
            shareCount: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastSocialMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastSocialMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastSocialMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastSocialMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastSubNotifyMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastSubNotifyMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.user)
    pub user: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.subMonth)
    pub subMonth: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.subscribeType)
    pub subscribeType: ::protobuf::EnumOrUnknown<super::enums::SubscribeType>,
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.oldSubscribeStatus)
    pub oldSubscribeStatus: ::protobuf::EnumOrUnknown<super::enums::OldSubscribeStatus>,
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.subscribingStatus)
    pub subscribingStatus: ::protobuf::EnumOrUnknown<super::enums::SubscribingStatus>,
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.isSend)
    pub isSend: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastSubNotifyMessage.isCustom)
    pub isCustom: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastSubNotifyMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastSubNotifyMessage {
    fn default() -> &'a WebcastSubNotifyMessage {
        <WebcastSubNotifyMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastSubNotifyMessage {
    pub fn new() -> WebcastSubNotifyMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastSubNotifyMessage| { &m.common },
            |m: &mut WebcastSubNotifyMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "user",
            |m: &WebcastSubNotifyMessage| { &m.user },
            |m: &mut WebcastSubNotifyMessage| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subMonth",
            |m: &WebcastSubNotifyMessage| { &m.subMonth },
            |m: &mut WebcastSubNotifyMessage| { &mut m.subMonth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscribeType",
            |m: &WebcastSubNotifyMessage| { &m.subscribeType },
            |m: &mut WebcastSubNotifyMessage| { &mut m.subscribeType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oldSubscribeStatus",
            |m: &WebcastSubNotifyMessage| { &m.oldSubscribeStatus },
            |m: &mut WebcastSubNotifyMessage| { &mut m.oldSubscribeStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscribingStatus",
            |m: &WebcastSubNotifyMessage| { &m.subscribingStatus },
            |m: &mut WebcastSubNotifyMessage| { &mut m.subscribingStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isSend",
            |m: &WebcastSubNotifyMessage| { &m.isSend },
            |m: &mut WebcastSubNotifyMessage| { &mut m.isSend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isCustom",
            |m: &WebcastSubNotifyMessage| { &m.isCustom },
            |m: &mut WebcastSubNotifyMessage| { &mut m.isCustom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastSubNotifyMessage>(
            "WebcastSubNotifyMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastSubNotifyMessage {
    const NAME: &'static str = "WebcastSubNotifyMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                32 => {
                    self.subMonth = is.read_int64()?;
                },
                40 => {
                    self.subscribeType = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.oldSubscribeStatus = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.subscribingStatus = is.read_enum_or_unknown()?;
                },
                72 => {
                    self.isSend = is.read_bool()?;
                },
                80 => {
                    self.isCustom = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.subMonth != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.subMonth);
        }
        if self.subscribeType != ::protobuf::EnumOrUnknown::new(super::enums::SubscribeType::SUBSCRIBETYPE_ONCE) {
            my_size += ::protobuf::rt::int32_size(5, self.subscribeType.value());
        }
        if self.oldSubscribeStatus != ::protobuf::EnumOrUnknown::new(super::enums::OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST) {
            my_size += ::protobuf::rt::int32_size(6, self.oldSubscribeStatus.value());
        }
        if self.subscribingStatus != ::protobuf::EnumOrUnknown::new(super::enums::SubscribingStatus::SUBSCRIBINGSTATUS_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(8, self.subscribingStatus.value());
        }
        if self.isSend != false {
            my_size += 1 + 1;
        }
        if self.isCustom != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.subMonth != 0 {
            os.write_int64(4, self.subMonth)?;
        }
        if self.subscribeType != ::protobuf::EnumOrUnknown::new(super::enums::SubscribeType::SUBSCRIBETYPE_ONCE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.subscribeType))?;
        }
        if self.oldSubscribeStatus != ::protobuf::EnumOrUnknown::new(super::enums::OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.oldSubscribeStatus))?;
        }
        if self.subscribingStatus != ::protobuf::EnumOrUnknown::new(super::enums::SubscribingStatus::SUBSCRIBINGSTATUS_UNKNOWN) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.subscribingStatus))?;
        }
        if self.isSend != false {
            os.write_bool(9, self.isSend)?;
        }
        if self.isCustom != false {
            os.write_bool(10, self.isCustom)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastSubNotifyMessage {
        WebcastSubNotifyMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.user.clear();
        self.subMonth = 0;
        self.subscribeType = ::protobuf::EnumOrUnknown::new(super::enums::SubscribeType::SUBSCRIBETYPE_ONCE);
        self.oldSubscribeStatus = ::protobuf::EnumOrUnknown::new(super::enums::OldSubscribeStatus::OLDSUBSCRIBESTATUS_FIRST);
        self.subscribingStatus = ::protobuf::EnumOrUnknown::new(super::enums::SubscribingStatus::SUBSCRIBINGSTATUS_UNKNOWN);
        self.isSend = false;
        self.isCustom = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastSubNotifyMessage {
        static instance: WebcastSubNotifyMessage = WebcastSubNotifyMessage {
            common: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            subMonth: 0,
            subscribeType: ::protobuf::EnumOrUnknown::from_i32(0),
            oldSubscribeStatus: ::protobuf::EnumOrUnknown::from_i32(0),
            subscribingStatus: ::protobuf::EnumOrUnknown::from_i32(0),
            isSend: false,
            isCustom: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastSubNotifyMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastSubNotifyMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastSubNotifyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastSubNotifyMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastRankUpdateMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastRankUpdateMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.updatesList)
    pub updatesList: ::std::vec::Vec<webcast_rank_update_message::RankUpdate>,
    // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.groupType)
    pub groupType: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.priority)
    pub priority: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.tabsList)
    pub tabsList: ::std::vec::Vec<webcast_rank_update_message::RankTabInfo>,
    // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.isAnimationLoopPlay)
    pub isAnimationLoopPlay: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.animationLoopForOff)
    pub animationLoopForOff: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastRankUpdateMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastRankUpdateMessage {
    fn default() -> &'a WebcastRankUpdateMessage {
        <WebcastRankUpdateMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastRankUpdateMessage {
    pub fn new() -> WebcastRankUpdateMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastRankUpdateMessage| { &m.common },
            |m: &mut WebcastRankUpdateMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "updatesList",
            |m: &WebcastRankUpdateMessage| { &m.updatesList },
            |m: &mut WebcastRankUpdateMessage| { &mut m.updatesList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groupType",
            |m: &WebcastRankUpdateMessage| { &m.groupType },
            |m: &mut WebcastRankUpdateMessage| { &mut m.groupType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "priority",
            |m: &WebcastRankUpdateMessage| { &m.priority },
            |m: &mut WebcastRankUpdateMessage| { &mut m.priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tabsList",
            |m: &WebcastRankUpdateMessage| { &m.tabsList },
            |m: &mut WebcastRankUpdateMessage| { &mut m.tabsList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isAnimationLoopPlay",
            |m: &WebcastRankUpdateMessage| { &m.isAnimationLoopPlay },
            |m: &mut WebcastRankUpdateMessage| { &mut m.isAnimationLoopPlay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "animationLoopForOff",
            |m: &WebcastRankUpdateMessage| { &m.animationLoopForOff },
            |m: &mut WebcastRankUpdateMessage| { &mut m.animationLoopForOff },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastRankUpdateMessage>(
            "WebcastRankUpdateMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastRankUpdateMessage {
    const NAME: &'static str = "WebcastRankUpdateMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    self.updatesList.push(is.read_message()?);
                },
                24 => {
                    self.groupType = is.read_int64()?;
                },
                40 => {
                    self.priority = is.read_int64()?;
                },
                50 => {
                    self.tabsList.push(is.read_message()?);
                },
                56 => {
                    self.isAnimationLoopPlay = is.read_bool()?;
                },
                64 => {
                    self.animationLoopForOff = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.updatesList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.groupType != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.groupType);
        }
        if self.priority != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.priority);
        }
        for value in &self.tabsList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.isAnimationLoopPlay != false {
            my_size += 1 + 1;
        }
        if self.animationLoopForOff != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.updatesList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.groupType != 0 {
            os.write_int64(3, self.groupType)?;
        }
        if self.priority != 0 {
            os.write_int64(5, self.priority)?;
        }
        for v in &self.tabsList {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.isAnimationLoopPlay != false {
            os.write_bool(7, self.isAnimationLoopPlay)?;
        }
        if self.animationLoopForOff != false {
            os.write_bool(8, self.animationLoopForOff)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastRankUpdateMessage {
        WebcastRankUpdateMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.updatesList.clear();
        self.groupType = 0;
        self.priority = 0;
        self.tabsList.clear();
        self.isAnimationLoopPlay = false;
        self.animationLoopForOff = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastRankUpdateMessage {
        static instance: WebcastRankUpdateMessage = WebcastRankUpdateMessage {
            common: ::protobuf::MessageField::none(),
            updatesList: ::std::vec::Vec::new(),
            groupType: 0,
            priority: 0,
            tabsList: ::std::vec::Vec::new(),
            isAnimationLoopPlay: false,
            animationLoopForOff: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastRankUpdateMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastRankUpdateMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastRankUpdateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastRankUpdateMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastRankUpdateMessage`
pub mod webcast_rank_update_message {
    // @@protoc_insertion_point(message:TikTok.WebcastRankUpdateMessage.RankTabInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankTabInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankTabInfo.rankType)
        pub rankType: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankTabInfo.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankTabInfo.titleText)
        pub titleText: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankTabInfo.listLynxType)
        pub listLynxType: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastRankUpdateMessage.RankTabInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankTabInfo {
        fn default() -> &'a RankTabInfo {
            <RankTabInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl RankTabInfo {
        pub fn new() -> RankTabInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rankType",
                |m: &RankTabInfo| { &m.rankType },
                |m: &mut RankTabInfo| { &mut m.rankType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &RankTabInfo| { &m.title },
                |m: &mut RankTabInfo| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "titleText",
                |m: &RankTabInfo| { &m.titleText },
                |m: &mut RankTabInfo| { &mut m.titleText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "listLynxType",
                |m: &RankTabInfo| { &m.listLynxType },
                |m: &mut RankTabInfo| { &mut m.listLynxType },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankTabInfo>(
                "WebcastRankUpdateMessage.RankTabInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RankTabInfo {
        const NAME: &'static str = "RankTabInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rankType = is.read_int64()?;
                    },
                    18 => {
                        self.title = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.titleText)?;
                    },
                    32 => {
                        self.listLynxType = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.rankType != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.rankType);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.title);
            }
            if let Some(v) = self.titleText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.listLynxType != 0 {
                my_size += ::protobuf::rt::int64_size(4, self.listLynxType);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.rankType != 0 {
                os.write_int64(1, self.rankType)?;
            }
            if !self.title.is_empty() {
                os.write_string(2, &self.title)?;
            }
            if let Some(v) = self.titleText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.listLynxType != 0 {
                os.write_int64(4, self.listLynxType)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankTabInfo {
            RankTabInfo::new()
        }

        fn clear(&mut self) {
            self.rankType = 0;
            self.title.clear();
            self.titleText.clear();
            self.listLynxType = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankTabInfo {
            static instance: RankTabInfo = RankTabInfo {
                rankType: 0,
                title: ::std::string::String::new(),
                titleText: ::protobuf::MessageField::none(),
                listLynxType: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RankTabInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastRankUpdateMessage.RankTabInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RankTabInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RankTabInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastRankUpdateMessage.RankUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankUpdate {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.rankType)
        pub rankType: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.ownerRank)
        pub ownerRank: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.defaultContent)
        pub defaultContent: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.showEntranceAnimation)
        pub showEntranceAnimation: bool,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.countdown)
        pub countdown: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.relatedTabRankType)
        pub relatedTabRankType: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.requestFirstShowType)
        pub requestFirstShowType: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.supportedVersion)
        pub supportedVersion: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastRankUpdateMessage.RankUpdate.owneronrank)
        pub owneronrank: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastRankUpdateMessage.RankUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankUpdate {
        fn default() -> &'a RankUpdate {
            <RankUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl RankUpdate {
        pub fn new() -> RankUpdate {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rankType",
                |m: &RankUpdate| { &m.rankType },
                |m: &mut RankUpdate| { &mut m.rankType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ownerRank",
                |m: &RankUpdate| { &m.ownerRank },
                |m: &mut RankUpdate| { &mut m.ownerRank },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "defaultContent",
                |m: &RankUpdate| { &m.defaultContent },
                |m: &mut RankUpdate| { &mut m.defaultContent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "showEntranceAnimation",
                |m: &RankUpdate| { &m.showEntranceAnimation },
                |m: &mut RankUpdate| { &mut m.showEntranceAnimation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "countdown",
                |m: &RankUpdate| { &m.countdown },
                |m: &mut RankUpdate| { &mut m.countdown },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "relatedTabRankType",
                |m: &RankUpdate| { &m.relatedTabRankType },
                |m: &mut RankUpdate| { &mut m.relatedTabRankType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "requestFirstShowType",
                |m: &RankUpdate| { &m.requestFirstShowType },
                |m: &mut RankUpdate| { &mut m.requestFirstShowType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "supportedVersion",
                |m: &RankUpdate| { &m.supportedVersion },
                |m: &mut RankUpdate| { &mut m.supportedVersion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "owneronrank",
                |m: &RankUpdate| { &m.owneronrank },
                |m: &mut RankUpdate| { &mut m.owneronrank },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankUpdate>(
                "WebcastRankUpdateMessage.RankUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RankUpdate {
        const NAME: &'static str = "RankUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rankType = is.read_int64()?;
                    },
                    16 => {
                        self.ownerRank = is.read_int64()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.defaultContent)?;
                    },
                    40 => {
                        self.showEntranceAnimation = is.read_bool()?;
                    },
                    48 => {
                        self.countdown = is.read_int64()?;
                    },
                    64 => {
                        self.relatedTabRankType = is.read_int64()?;
                    },
                    72 => {
                        self.requestFirstShowType = is.read_int64()?;
                    },
                    80 => {
                        self.supportedVersion = is.read_int64()?;
                    },
                    88 => {
                        self.owneronrank = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.rankType != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.rankType);
            }
            if self.ownerRank != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.ownerRank);
            }
            if let Some(v) = self.defaultContent.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.showEntranceAnimation != false {
                my_size += 1 + 1;
            }
            if self.countdown != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.countdown);
            }
            if self.relatedTabRankType != 0 {
                my_size += ::protobuf::rt::int64_size(8, self.relatedTabRankType);
            }
            if self.requestFirstShowType != 0 {
                my_size += ::protobuf::rt::int64_size(9, self.requestFirstShowType);
            }
            if self.supportedVersion != 0 {
                my_size += ::protobuf::rt::int64_size(10, self.supportedVersion);
            }
            if self.owneronrank != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.rankType != 0 {
                os.write_int64(1, self.rankType)?;
            }
            if self.ownerRank != 0 {
                os.write_int64(2, self.ownerRank)?;
            }
            if let Some(v) = self.defaultContent.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if self.showEntranceAnimation != false {
                os.write_bool(5, self.showEntranceAnimation)?;
            }
            if self.countdown != 0 {
                os.write_int64(6, self.countdown)?;
            }
            if self.relatedTabRankType != 0 {
                os.write_int64(8, self.relatedTabRankType)?;
            }
            if self.requestFirstShowType != 0 {
                os.write_int64(9, self.requestFirstShowType)?;
            }
            if self.supportedVersion != 0 {
                os.write_int64(10, self.supportedVersion)?;
            }
            if self.owneronrank != false {
                os.write_bool(11, self.owneronrank)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankUpdate {
            RankUpdate::new()
        }

        fn clear(&mut self) {
            self.rankType = 0;
            self.ownerRank = 0;
            self.defaultContent.clear();
            self.showEntranceAnimation = false;
            self.countdown = 0;
            self.relatedTabRankType = 0;
            self.requestFirstShowType = 0;
            self.supportedVersion = 0;
            self.owneronrank = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankUpdate {
            static instance: RankUpdate = RankUpdate {
                rankType: 0,
                ownerRank: 0,
                defaultContent: ::protobuf::MessageField::none(),
                showEntranceAnimation: false,
                countdown: 0,
                relatedTabRankType: 0,
                requestFirstShowType: 0,
                supportedVersion: 0,
                owneronrank: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RankUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastRankUpdateMessage.RankUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RankUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RankUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastMemberMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastMemberMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.user)
    pub user: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.memberCount)
    pub memberCount: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.operator)
    pub operator: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.isSetToAdmin)
    pub isSetToAdmin: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.isTopUser)
    pub isTopUser: bool,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.rankScore)
    pub rankScore: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.topUserNo)
    pub topUserNo: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.enterType)
    pub enterType: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.action)
    pub action: ::protobuf::EnumOrUnknown<super::enums::MemberMessageAction>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.actionDescription)
    pub actionDescription: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.userId)
    pub userId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.effectConfig)
    pub effectConfig: ::protobuf::MessageField<webcast_member_message::EffectConfig>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.popStr)
    pub popStr: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.enterEffectConfig)
    pub enterEffectConfig: ::protobuf::MessageField<webcast_member_message::EffectConfig>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.backgroundImage)
    pub backgroundImage: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.backgroundImageV2)
    pub backgroundImageV2: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.anchorDisplayText)
    pub anchorDisplayText: ::protobuf::MessageField<super::data::Text>,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.clientEnterSource)
    pub clientEnterSource: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.clientEnterType)
    pub clientEnterType: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.clientLiveReason)
    pub clientLiveReason: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.actionDuration)
    pub actionDuration: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.userShareType)
    pub userShareType: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastMemberMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastMemberMessage {
    fn default() -> &'a WebcastMemberMessage {
        <WebcastMemberMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastMemberMessage {
    pub fn new() -> WebcastMemberMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastMemberMessage| { &m.common },
            |m: &mut WebcastMemberMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "user",
            |m: &WebcastMemberMessage| { &m.user },
            |m: &mut WebcastMemberMessage| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "memberCount",
            |m: &WebcastMemberMessage| { &m.memberCount },
            |m: &mut WebcastMemberMessage| { &mut m.memberCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "operator",
            |m: &WebcastMemberMessage| { &m.operator },
            |m: &mut WebcastMemberMessage| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isSetToAdmin",
            |m: &WebcastMemberMessage| { &m.isSetToAdmin },
            |m: &mut WebcastMemberMessage| { &mut m.isSetToAdmin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isTopUser",
            |m: &WebcastMemberMessage| { &m.isTopUser },
            |m: &mut WebcastMemberMessage| { &mut m.isTopUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rankScore",
            |m: &WebcastMemberMessage| { &m.rankScore },
            |m: &mut WebcastMemberMessage| { &mut m.rankScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topUserNo",
            |m: &WebcastMemberMessage| { &m.topUserNo },
            |m: &mut WebcastMemberMessage| { &mut m.topUserNo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enterType",
            |m: &WebcastMemberMessage| { &m.enterType },
            |m: &mut WebcastMemberMessage| { &mut m.enterType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &WebcastMemberMessage| { &m.action },
            |m: &mut WebcastMemberMessage| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actionDescription",
            |m: &WebcastMemberMessage| { &m.actionDescription },
            |m: &mut WebcastMemberMessage| { &mut m.actionDescription },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &WebcastMemberMessage| { &m.userId },
            |m: &mut WebcastMemberMessage| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_member_message::EffectConfig>(
            "effectConfig",
            |m: &WebcastMemberMessage| { &m.effectConfig },
            |m: &mut WebcastMemberMessage| { &mut m.effectConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "popStr",
            |m: &WebcastMemberMessage| { &m.popStr },
            |m: &mut WebcastMemberMessage| { &mut m.popStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_member_message::EffectConfig>(
            "enterEffectConfig",
            |m: &WebcastMemberMessage| { &m.enterEffectConfig },
            |m: &mut WebcastMemberMessage| { &mut m.enterEffectConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "backgroundImage",
            |m: &WebcastMemberMessage| { &m.backgroundImage },
            |m: &mut WebcastMemberMessage| { &mut m.backgroundImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "backgroundImageV2",
            |m: &WebcastMemberMessage| { &m.backgroundImageV2 },
            |m: &mut WebcastMemberMessage| { &mut m.backgroundImageV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "anchorDisplayText",
            |m: &WebcastMemberMessage| { &m.anchorDisplayText },
            |m: &mut WebcastMemberMessage| { &mut m.anchorDisplayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clientEnterSource",
            |m: &WebcastMemberMessage| { &m.clientEnterSource },
            |m: &mut WebcastMemberMessage| { &mut m.clientEnterSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clientEnterType",
            |m: &WebcastMemberMessage| { &m.clientEnterType },
            |m: &mut WebcastMemberMessage| { &mut m.clientEnterType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clientLiveReason",
            |m: &WebcastMemberMessage| { &m.clientLiveReason },
            |m: &mut WebcastMemberMessage| { &mut m.clientLiveReason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actionDuration",
            |m: &WebcastMemberMessage| { &m.actionDuration },
            |m: &mut WebcastMemberMessage| { &mut m.actionDuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userShareType",
            |m: &WebcastMemberMessage| { &m.userShareType },
            |m: &mut WebcastMemberMessage| { &mut m.userShareType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastMemberMessage>(
            "WebcastMemberMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastMemberMessage {
    const NAME: &'static str = "WebcastMemberMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                24 => {
                    self.memberCount = is.read_int32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operator)?;
                },
                40 => {
                    self.isSetToAdmin = is.read_bool()?;
                },
                48 => {
                    self.isTopUser = is.read_bool()?;
                },
                56 => {
                    self.rankScore = is.read_int64()?;
                },
                64 => {
                    self.topUserNo = is.read_int64()?;
                },
                72 => {
                    self.enterType = is.read_int64()?;
                },
                80 => {
                    self.action = is.read_enum_or_unknown()?;
                },
                90 => {
                    self.actionDescription = is.read_string()?;
                },
                96 => {
                    self.userId = is.read_int64()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.effectConfig)?;
                },
                114 => {
                    self.popStr = is.read_string()?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.enterEffectConfig)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backgroundImage)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backgroundImageV2)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.anchorDisplayText)?;
                },
                154 => {
                    self.clientEnterSource = is.read_string()?;
                },
                162 => {
                    self.clientEnterType = is.read_string()?;
                },
                170 => {
                    self.clientLiveReason = is.read_string()?;
                },
                176 => {
                    self.actionDuration = is.read_int64()?;
                },
                186 => {
                    self.userShareType = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.memberCount != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.memberCount);
        }
        if let Some(v) = self.operator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.isSetToAdmin != false {
            my_size += 1 + 1;
        }
        if self.isTopUser != false {
            my_size += 1 + 1;
        }
        if self.rankScore != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.rankScore);
        }
        if self.topUserNo != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.topUserNo);
        }
        if self.enterType != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.enterType);
        }
        if self.action != ::protobuf::EnumOrUnknown::new(super::enums::MemberMessageAction::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(10, self.action.value());
        }
        if !self.actionDescription.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.actionDescription);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(12, self.userId);
        }
        if let Some(v) = self.effectConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.popStr.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.popStr);
        }
        if let Some(v) = self.enterEffectConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.backgroundImage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.backgroundImageV2.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.anchorDisplayText.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.clientEnterSource.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.clientEnterSource);
        }
        if !self.clientEnterType.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.clientEnterType);
        }
        if !self.clientLiveReason.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.clientLiveReason);
        }
        if self.actionDuration != 0 {
            my_size += ::protobuf::rt::int64_size(22, self.actionDuration);
        }
        if !self.userShareType.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.userShareType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.memberCount != 0 {
            os.write_int32(3, self.memberCount)?;
        }
        if let Some(v) = self.operator.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.isSetToAdmin != false {
            os.write_bool(5, self.isSetToAdmin)?;
        }
        if self.isTopUser != false {
            os.write_bool(6, self.isTopUser)?;
        }
        if self.rankScore != 0 {
            os.write_int64(7, self.rankScore)?;
        }
        if self.topUserNo != 0 {
            os.write_int64(8, self.topUserNo)?;
        }
        if self.enterType != 0 {
            os.write_int64(9, self.enterType)?;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(super::enums::MemberMessageAction::UNKNOWN) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.action))?;
        }
        if !self.actionDescription.is_empty() {
            os.write_string(11, &self.actionDescription)?;
        }
        if self.userId != 0 {
            os.write_int64(12, self.userId)?;
        }
        if let Some(v) = self.effectConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if !self.popStr.is_empty() {
            os.write_string(14, &self.popStr)?;
        }
        if let Some(v) = self.enterEffectConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.backgroundImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.backgroundImageV2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.anchorDisplayText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if !self.clientEnterSource.is_empty() {
            os.write_string(19, &self.clientEnterSource)?;
        }
        if !self.clientEnterType.is_empty() {
            os.write_string(20, &self.clientEnterType)?;
        }
        if !self.clientLiveReason.is_empty() {
            os.write_string(21, &self.clientLiveReason)?;
        }
        if self.actionDuration != 0 {
            os.write_int64(22, self.actionDuration)?;
        }
        if !self.userShareType.is_empty() {
            os.write_string(23, &self.userShareType)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastMemberMessage {
        WebcastMemberMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.user.clear();
        self.memberCount = 0;
        self.operator.clear();
        self.isSetToAdmin = false;
        self.isTopUser = false;
        self.rankScore = 0;
        self.topUserNo = 0;
        self.enterType = 0;
        self.action = ::protobuf::EnumOrUnknown::new(super::enums::MemberMessageAction::UNKNOWN);
        self.actionDescription.clear();
        self.userId = 0;
        self.effectConfig.clear();
        self.popStr.clear();
        self.enterEffectConfig.clear();
        self.backgroundImage.clear();
        self.backgroundImageV2.clear();
        self.anchorDisplayText.clear();
        self.clientEnterSource.clear();
        self.clientEnterType.clear();
        self.clientLiveReason.clear();
        self.actionDuration = 0;
        self.userShareType.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastMemberMessage {
        static instance: WebcastMemberMessage = WebcastMemberMessage {
            common: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            memberCount: 0,
            operator: ::protobuf::MessageField::none(),
            isSetToAdmin: false,
            isTopUser: false,
            rankScore: 0,
            topUserNo: 0,
            enterType: 0,
            action: ::protobuf::EnumOrUnknown::from_i32(0),
            actionDescription: ::std::string::String::new(),
            userId: 0,
            effectConfig: ::protobuf::MessageField::none(),
            popStr: ::std::string::String::new(),
            enterEffectConfig: ::protobuf::MessageField::none(),
            backgroundImage: ::protobuf::MessageField::none(),
            backgroundImageV2: ::protobuf::MessageField::none(),
            anchorDisplayText: ::protobuf::MessageField::none(),
            clientEnterSource: ::std::string::String::new(),
            clientEnterType: ::std::string::String::new(),
            clientLiveReason: ::std::string::String::new(),
            actionDuration: 0,
            userShareType: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastMemberMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastMemberMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastMemberMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastMemberMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastMemberMessage`
pub mod webcast_member_message {
    // @@protoc_insertion_point(message:TikTok.WebcastMemberMessage.EffectConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EffectConfig {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.type)
        pub type_: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.icon)
        pub icon: ::protobuf::MessageField<super::super::data::Image>,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.avatarPos)
        pub avatarPos: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.text)
        pub text: ::protobuf::MessageField<super::super::data::Text>,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.textIcon)
        pub textIcon: ::protobuf::MessageField<super::super::data::Image>,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.stayTime)
        pub stayTime: i32,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.animAssetId)
        pub animAssetId: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.badge)
        pub badge: ::protobuf::MessageField<super::super::data::Image>,
        // @@protoc_insertion_point(field:TikTok.WebcastMemberMessage.EffectConfig.flexSettingArrayList)
        pub flexSettingArrayList: ::std::vec::Vec<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastMemberMessage.EffectConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EffectConfig {
        fn default() -> &'a EffectConfig {
            <EffectConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl EffectConfig {
        pub fn new() -> EffectConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &EffectConfig| { &m.type_ },
                |m: &mut EffectConfig| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Image>(
                "icon",
                |m: &EffectConfig| { &m.icon },
                |m: &mut EffectConfig| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "avatarPos",
                |m: &EffectConfig| { &m.avatarPos },
                |m: &mut EffectConfig| { &mut m.avatarPos },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Text>(
                "text",
                |m: &EffectConfig| { &m.text },
                |m: &mut EffectConfig| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Image>(
                "textIcon",
                |m: &EffectConfig| { &m.textIcon },
                |m: &mut EffectConfig| { &mut m.textIcon },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "stayTime",
                |m: &EffectConfig| { &m.stayTime },
                |m: &mut EffectConfig| { &mut m.stayTime },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "animAssetId",
                |m: &EffectConfig| { &m.animAssetId },
                |m: &mut EffectConfig| { &mut m.animAssetId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Image>(
                "badge",
                |m: &EffectConfig| { &m.badge },
                |m: &mut EffectConfig| { &mut m.badge },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "flexSettingArrayList",
                |m: &EffectConfig| { &m.flexSettingArrayList },
                |m: &mut EffectConfig| { &mut m.flexSettingArrayList },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EffectConfig>(
                "WebcastMemberMessage.EffectConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EffectConfig {
        const NAME: &'static str = "EffectConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = is.read_int64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                    },
                    24 => {
                        self.avatarPos = is.read_int64()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.text)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.textIcon)?;
                    },
                    48 => {
                        self.stayTime = is.read_int32()?;
                    },
                    56 => {
                        self.animAssetId = is.read_int64()?;
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.badge)?;
                    },
                    74 => {
                        is.read_repeated_packed_int64_into(&mut self.flexSettingArrayList)?;
                    },
                    72 => {
                        self.flexSettingArrayList.push(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.type_ != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.type_);
            }
            if let Some(v) = self.icon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.avatarPos != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.avatarPos);
            }
            if let Some(v) = self.text.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.textIcon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.stayTime != 0 {
                my_size += ::protobuf::rt::int32_size(6, self.stayTime);
            }
            if self.animAssetId != 0 {
                my_size += ::protobuf::rt::int64_size(7, self.animAssetId);
            }
            if let Some(v) = self.badge.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.flexSettingArrayList {
                my_size += ::protobuf::rt::int64_size(9, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.type_ != 0 {
                os.write_int64(1, self.type_)?;
            }
            if let Some(v) = self.icon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.avatarPos != 0 {
                os.write_int64(3, self.avatarPos)?;
            }
            if let Some(v) = self.text.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.textIcon.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if self.stayTime != 0 {
                os.write_int32(6, self.stayTime)?;
            }
            if self.animAssetId != 0 {
                os.write_int64(7, self.animAssetId)?;
            }
            if let Some(v) = self.badge.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            for v in &self.flexSettingArrayList {
                os.write_int64(9, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EffectConfig {
            EffectConfig::new()
        }

        fn clear(&mut self) {
            self.type_ = 0;
            self.icon.clear();
            self.avatarPos = 0;
            self.text.clear();
            self.textIcon.clear();
            self.stayTime = 0;
            self.animAssetId = 0;
            self.badge.clear();
            self.flexSettingArrayList.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EffectConfig {
            static instance: EffectConfig = EffectConfig {
                type_: 0,
                icon: ::protobuf::MessageField::none(),
                avatarPos: 0,
                text: ::protobuf::MessageField::none(),
                textIcon: ::protobuf::MessageField::none(),
                stayTime: 0,
                animAssetId: 0,
                badge: ::protobuf::MessageField::none(),
                flexSettingArrayList: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EffectConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastMemberMessage.EffectConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EffectConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EffectConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastPollMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastPollMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastPollMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastPollMessage.messageType)
    pub messageType: ::protobuf::EnumOrUnknown<super::enums::MessageType>,
    // @@protoc_insertion_point(field:TikTok.WebcastPollMessage.pollId)
    pub pollId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastPollMessage.startContent)
    pub startContent: ::protobuf::MessageField<super::data::PollStartContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastPollMessage.endContent)
    pub endContent: ::protobuf::MessageField<super::data::PollEndContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastPollMessage.updateContent)
    pub updateContent: ::protobuf::MessageField<super::data::PollUpdateVotesContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastPollMessage.pollKind)
    pub pollKind: i32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastPollMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastPollMessage {
    fn default() -> &'a WebcastPollMessage {
        <WebcastPollMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastPollMessage {
    pub fn new() -> WebcastPollMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastPollMessage| { &m.common },
            |m: &mut WebcastPollMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "messageType",
            |m: &WebcastPollMessage| { &m.messageType },
            |m: &mut WebcastPollMessage| { &mut m.messageType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pollId",
            |m: &WebcastPollMessage| { &m.pollId },
            |m: &mut WebcastPollMessage| { &mut m.pollId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::PollStartContent>(
            "startContent",
            |m: &WebcastPollMessage| { &m.startContent },
            |m: &mut WebcastPollMessage| { &mut m.startContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::PollEndContent>(
            "endContent",
            |m: &WebcastPollMessage| { &m.endContent },
            |m: &mut WebcastPollMessage| { &mut m.endContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::PollUpdateVotesContent>(
            "updateContent",
            |m: &WebcastPollMessage| { &m.updateContent },
            |m: &mut WebcastPollMessage| { &mut m.updateContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pollKind",
            |m: &WebcastPollMessage| { &m.pollKind },
            |m: &mut WebcastPollMessage| { &mut m.pollKind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastPollMessage>(
            "WebcastPollMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastPollMessage {
    const NAME: &'static str = "WebcastPollMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.messageType = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.pollId = is.read_int64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.startContent)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.endContent)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updateContent)?;
                },
                56 => {
                    self.pollKind = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.messageType != ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS) {
            my_size += ::protobuf::rt::int32_size(2, self.messageType.value());
        }
        if self.pollId != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.pollId);
        }
        if let Some(v) = self.startContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.endContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.updateContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.pollKind != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.pollKind);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.messageType != ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.messageType))?;
        }
        if self.pollId != 0 {
            os.write_int64(3, self.pollId)?;
        }
        if let Some(v) = self.startContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.endContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.updateContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.pollKind != 0 {
            os.write_int32(7, self.pollKind)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastPollMessage {
        WebcastPollMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.messageType = ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS);
        self.pollId = 0;
        self.startContent.clear();
        self.endContent.clear();
        self.updateContent.clear();
        self.pollKind = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastPollMessage {
        static instance: WebcastPollMessage = WebcastPollMessage {
            common: ::protobuf::MessageField::none(),
            messageType: ::protobuf::EnumOrUnknown::from_i32(0),
            pollId: 0,
            startContent: ::protobuf::MessageField::none(),
            endContent: ::protobuf::MessageField::none(),
            updateContent: ::protobuf::MessageField::none(),
            pollKind: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastPollMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastPollMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastPollMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastPollMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastQuestionNewMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastQuestionNewMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastQuestionNewMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastQuestionNewMessage.details)
    pub details: ::protobuf::MessageField<webcast_question_new_message::QuestionDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastQuestionNewMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastQuestionNewMessage {
    fn default() -> &'a WebcastQuestionNewMessage {
        <WebcastQuestionNewMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastQuestionNewMessage {
    pub fn new() -> WebcastQuestionNewMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastQuestionNewMessage| { &m.common },
            |m: &mut WebcastQuestionNewMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_question_new_message::QuestionDetails>(
            "details",
            |m: &WebcastQuestionNewMessage| { &m.details },
            |m: &mut WebcastQuestionNewMessage| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastQuestionNewMessage>(
            "WebcastQuestionNewMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastQuestionNewMessage {
    const NAME: &'static str = "WebcastQuestionNewMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.details)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastQuestionNewMessage {
        WebcastQuestionNewMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastQuestionNewMessage {
        static instance: WebcastQuestionNewMessage = WebcastQuestionNewMessage {
            common: ::protobuf::MessageField::none(),
            details: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastQuestionNewMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastQuestionNewMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastQuestionNewMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastQuestionNewMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastQuestionNewMessage`
pub mod webcast_question_new_message {
    // @@protoc_insertion_point(message:TikTok.WebcastQuestionNewMessage.QuestionDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QuestionDetails {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastQuestionNewMessage.QuestionDetails.id)
        pub id: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastQuestionNewMessage.QuestionDetails.text)
        pub text: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastQuestionNewMessage.QuestionDetails.timeStamp)
        pub timeStamp: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastQuestionNewMessage.QuestionDetails.user)
        pub user: ::protobuf::MessageField<super::super::data::User>,
        // @@protoc_insertion_point(field:TikTok.WebcastQuestionNewMessage.QuestionDetails.data1)
        pub data1: u32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastQuestionNewMessage.QuestionDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QuestionDetails {
        fn default() -> &'a QuestionDetails {
            <QuestionDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl QuestionDetails {
        pub fn new() -> QuestionDetails {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &QuestionDetails| { &m.id },
                |m: &mut QuestionDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "text",
                |m: &QuestionDetails| { &m.text },
                |m: &mut QuestionDetails| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timeStamp",
                |m: &QuestionDetails| { &m.timeStamp },
                |m: &mut QuestionDetails| { &mut m.timeStamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::User>(
                "user",
                |m: &QuestionDetails| { &m.user },
                |m: &mut QuestionDetails| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data1",
                |m: &QuestionDetails| { &m.data1 },
                |m: &mut QuestionDetails| { &mut m.data1 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuestionDetails>(
                "WebcastQuestionNewMessage.QuestionDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QuestionDetails {
        const NAME: &'static str = "QuestionDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_uint64()?;
                    },
                    18 => {
                        self.text = is.read_string()?;
                    },
                    32 => {
                        self.timeStamp = is.read_uint64()?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                    },
                    160 => {
                        self.data1 = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.id);
            }
            if !self.text.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.text);
            }
            if self.timeStamp != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.timeStamp);
            }
            if let Some(v) = self.user.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.data1 != 0 {
                my_size += ::protobuf::rt::uint32_size(20, self.data1);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_uint64(1, self.id)?;
            }
            if !self.text.is_empty() {
                os.write_string(2, &self.text)?;
            }
            if self.timeStamp != 0 {
                os.write_uint64(4, self.timeStamp)?;
            }
            if let Some(v) = self.user.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if self.data1 != 0 {
                os.write_uint32(20, self.data1)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QuestionDetails {
            QuestionDetails::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.text.clear();
            self.timeStamp = 0;
            self.user.clear();
            self.data1 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QuestionDetails {
            static instance: QuestionDetails = QuestionDetails {
                id: 0,
                text: ::std::string::String::new(),
                timeStamp: 0,
                user: ::protobuf::MessageField::none(),
                data1: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QuestionDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastQuestionNewMessage.QuestionDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QuestionDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QuestionDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastRankTextMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastRankTextMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastRankTextMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastRankTextMessage.scene)
    pub scene: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastRankTextMessage.ownerIdxBeforeUpdate)
    pub ownerIdxBeforeUpdate: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastRankTextMessage.ownerIdxAfterUpdate)
    pub ownerIdxAfterUpdate: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastRankTextMessage.selfGetBadgeMsg)
    pub selfGetBadgeMsg: ::protobuf::MessageField<super::data::Text>,
    // @@protoc_insertion_point(field:TikTok.WebcastRankTextMessage.otherGetBadgeMsg)
    pub otherGetBadgeMsg: ::protobuf::MessageField<super::data::Text>,
    // @@protoc_insertion_point(field:TikTok.WebcastRankTextMessage.curUserId)
    pub curUserId: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastRankTextMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastRankTextMessage {
    fn default() -> &'a WebcastRankTextMessage {
        <WebcastRankTextMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastRankTextMessage {
    pub fn new() -> WebcastRankTextMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastRankTextMessage| { &m.common },
            |m: &mut WebcastRankTextMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scene",
            |m: &WebcastRankTextMessage| { &m.scene },
            |m: &mut WebcastRankTextMessage| { &mut m.scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ownerIdxBeforeUpdate",
            |m: &WebcastRankTextMessage| { &m.ownerIdxBeforeUpdate },
            |m: &mut WebcastRankTextMessage| { &mut m.ownerIdxBeforeUpdate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ownerIdxAfterUpdate",
            |m: &WebcastRankTextMessage| { &m.ownerIdxAfterUpdate },
            |m: &mut WebcastRankTextMessage| { &mut m.ownerIdxAfterUpdate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "selfGetBadgeMsg",
            |m: &WebcastRankTextMessage| { &m.selfGetBadgeMsg },
            |m: &mut WebcastRankTextMessage| { &mut m.selfGetBadgeMsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "otherGetBadgeMsg",
            |m: &WebcastRankTextMessage| { &m.otherGetBadgeMsg },
            |m: &mut WebcastRankTextMessage| { &mut m.otherGetBadgeMsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "curUserId",
            |m: &WebcastRankTextMessage| { &m.curUserId },
            |m: &mut WebcastRankTextMessage| { &mut m.curUserId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastRankTextMessage>(
            "WebcastRankTextMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastRankTextMessage {
    const NAME: &'static str = "WebcastRankTextMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.scene = is.read_int32()?;
                },
                24 => {
                    self.ownerIdxBeforeUpdate = is.read_int64()?;
                },
                32 => {
                    self.ownerIdxAfterUpdate = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selfGetBadgeMsg)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.otherGetBadgeMsg)?;
                },
                56 => {
                    self.curUserId = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.scene != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.scene);
        }
        if self.ownerIdxBeforeUpdate != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.ownerIdxBeforeUpdate);
        }
        if self.ownerIdxAfterUpdate != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.ownerIdxAfterUpdate);
        }
        if let Some(v) = self.selfGetBadgeMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.otherGetBadgeMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.curUserId != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.curUserId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.scene != 0 {
            os.write_int32(2, self.scene)?;
        }
        if self.ownerIdxBeforeUpdate != 0 {
            os.write_int64(3, self.ownerIdxBeforeUpdate)?;
        }
        if self.ownerIdxAfterUpdate != 0 {
            os.write_int64(4, self.ownerIdxAfterUpdate)?;
        }
        if let Some(v) = self.selfGetBadgeMsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.otherGetBadgeMsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.curUserId != 0 {
            os.write_int64(7, self.curUserId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastRankTextMessage {
        WebcastRankTextMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.scene = 0;
        self.ownerIdxBeforeUpdate = 0;
        self.ownerIdxAfterUpdate = 0;
        self.selfGetBadgeMsg.clear();
        self.otherGetBadgeMsg.clear();
        self.curUserId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastRankTextMessage {
        static instance: WebcastRankTextMessage = WebcastRankTextMessage {
            common: ::protobuf::MessageField::none(),
            scene: 0,
            ownerIdxBeforeUpdate: 0,
            ownerIdxAfterUpdate: 0,
            selfGetBadgeMsg: ::protobuf::MessageField::none(),
            otherGetBadgeMsg: ::protobuf::MessageField::none(),
            curUserId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastRankTextMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastRankTextMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastRankTextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastRankTextMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastHourlyRankMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastHourlyRankMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.data)
    pub data: ::protobuf::MessageField<webcast_hourly_rank_message::RankContainer>,
    // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.data2)
    pub data2: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastHourlyRankMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastHourlyRankMessage {
    fn default() -> &'a WebcastHourlyRankMessage {
        <WebcastHourlyRankMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastHourlyRankMessage {
    pub fn new() -> WebcastHourlyRankMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastHourlyRankMessage| { &m.common },
            |m: &mut WebcastHourlyRankMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_hourly_rank_message::RankContainer>(
            "data",
            |m: &WebcastHourlyRankMessage| { &m.data },
            |m: &mut WebcastHourlyRankMessage| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data2",
            |m: &WebcastHourlyRankMessage| { &m.data2 },
            |m: &mut WebcastHourlyRankMessage| { &mut m.data2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastHourlyRankMessage>(
            "WebcastHourlyRankMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastHourlyRankMessage {
    const NAME: &'static str = "WebcastHourlyRankMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                24 => {
                    self.data2 = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.data2 != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.data2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.data2 != 0 {
            os.write_uint32(3, self.data2)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastHourlyRankMessage {
        WebcastHourlyRankMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.data.clear();
        self.data2 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastHourlyRankMessage {
        static instance: WebcastHourlyRankMessage = WebcastHourlyRankMessage {
            common: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            data2: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastHourlyRankMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastHourlyRankMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastHourlyRankMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastHourlyRankMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastHourlyRankMessage`
pub mod webcast_hourly_rank_message {
    // @@protoc_insertion_point(message:TikTok.WebcastHourlyRankMessage.RankContainer)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankContainer {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.data1)
        pub data1: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.rankingdata)
        pub rankingdata: ::protobuf::MessageField<rank_container::RankingData>,
        // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.data2)
        pub data2: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.rankings)
        pub rankings: ::protobuf::MessageField<super::super::data::Ranking>,
        // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.rankingdata2)
        pub rankingdata2: ::protobuf::MessageField<rank_container::RankingData2>,
        // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.data3)
        pub data3: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.data4)
        pub data4: u32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastHourlyRankMessage.RankContainer.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankContainer {
        fn default() -> &'a RankContainer {
            <RankContainer as ::protobuf::Message>::default_instance()
        }
    }

    impl RankContainer {
        pub fn new() -> RankContainer {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data1",
                |m: &RankContainer| { &m.data1 },
                |m: &mut RankContainer| { &mut m.data1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, rank_container::RankingData>(
                "rankingdata",
                |m: &RankContainer| { &m.rankingdata },
                |m: &mut RankContainer| { &mut m.rankingdata },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data2",
                |m: &RankContainer| { &m.data2 },
                |m: &mut RankContainer| { &mut m.data2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::Ranking>(
                "rankings",
                |m: &RankContainer| { &m.rankings },
                |m: &mut RankContainer| { &mut m.rankings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, rank_container::RankingData2>(
                "rankingdata2",
                |m: &RankContainer| { &m.rankingdata2 },
                |m: &mut RankContainer| { &mut m.rankingdata2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data3",
                |m: &RankContainer| { &m.data3 },
                |m: &mut RankContainer| { &mut m.data3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data4",
                |m: &RankContainer| { &m.data4 },
                |m: &mut RankContainer| { &mut m.data4 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankContainer>(
                "WebcastHourlyRankMessage.RankContainer",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RankContainer {
        const NAME: &'static str = "RankContainer";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.data1 = is.read_uint32()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankingdata)?;
                    },
                    24 => {
                        self.data2 = is.read_uint32()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankings)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankingdata2)?;
                    },
                    48 => {
                        self.data3 = is.read_uint32()?;
                    },
                    56 => {
                        self.data4 = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.data1 != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.data1);
            }
            if let Some(v) = self.rankingdata.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.data2 != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.data2);
            }
            if let Some(v) = self.rankings.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.rankingdata2.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.data3 != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.data3);
            }
            if self.data4 != 0 {
                my_size += ::protobuf::rt::uint32_size(7, self.data4);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.data1 != 0 {
                os.write_uint32(1, self.data1)?;
            }
            if let Some(v) = self.rankingdata.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if self.data2 != 0 {
                os.write_uint32(3, self.data2)?;
            }
            if let Some(v) = self.rankings.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.rankingdata2.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if self.data3 != 0 {
                os.write_uint32(6, self.data3)?;
            }
            if self.data4 != 0 {
                os.write_uint32(7, self.data4)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankContainer {
            RankContainer::new()
        }

        fn clear(&mut self) {
            self.data1 = 0;
            self.rankingdata.clear();
            self.data2 = 0;
            self.rankings.clear();
            self.rankingdata2.clear();
            self.data3 = 0;
            self.data4 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankContainer {
            static instance: RankContainer = RankContainer {
                data1: 0,
                rankingdata: ::protobuf::MessageField::none(),
                data2: 0,
                rankings: ::protobuf::MessageField::none(),
                rankingdata2: ::protobuf::MessageField::none(),
                data3: 0,
                data4: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RankContainer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastHourlyRankMessage.RankContainer").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RankContainer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RankContainer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `RankContainer`
    pub mod rank_container {
        // @@protoc_insertion_point(message:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RankingData {
            // message fields
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData.data1)
            pub data1: u32,
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData.rankdata)
            pub rankdata: ::protobuf::MessageField<super::super::super::data::Ranking>,
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData.data2)
            pub data2: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RankingData {
            fn default() -> &'a RankingData {
                <RankingData as ::protobuf::Message>::default_instance()
            }
        }

        impl RankingData {
            pub fn new() -> RankingData {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "data1",
                    |m: &RankingData| { &m.data1 },
                    |m: &mut RankingData| { &mut m.data1 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::data::Ranking>(
                    "rankdata",
                    |m: &RankingData| { &m.rankdata },
                    |m: &mut RankingData| { &mut m.rankdata },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "data2",
                    |m: &RankingData| { &m.data2 },
                    |m: &mut RankingData| { &mut m.data2 },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankingData>(
                    "WebcastHourlyRankMessage.RankContainer.RankingData",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RankingData {
            const NAME: &'static str = "RankingData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.data1 = is.read_uint32()?;
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankdata)?;
                        },
                        26 => {
                            self.data2 = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.data1 != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.data1);
                }
                if let Some(v) = self.rankdata.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if !self.data2.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.data2);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.data1 != 0 {
                    os.write_uint32(1, self.data1)?;
                }
                if let Some(v) = self.rankdata.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                if !self.data2.is_empty() {
                    os.write_string(3, &self.data2)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RankingData {
                RankingData::new()
            }

            fn clear(&mut self) {
                self.data1 = 0;
                self.rankdata.clear();
                self.data2.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RankingData {
                static instance: RankingData = RankingData {
                    data1: 0,
                    rankdata: ::protobuf::MessageField::none(),
                    data2: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for RankingData {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("WebcastHourlyRankMessage.RankContainer.RankingData").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RankingData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RankingData {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RankingData2 {
            // message fields
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2.data1)
            pub data1: u32,
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2.data2)
            pub data2: u32,
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2.rankdata)
            pub rankdata: ::protobuf::MessageField<super::super::super::data::Ranking>,
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2.data3)
            pub data3: ::std::string::String,
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2.data4)
            pub data4: u32,
            // @@protoc_insertion_point(field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2.data5)
            pub data5: u32,
            // special fields
            // @@protoc_insertion_point(special_field:TikTok.WebcastHourlyRankMessage.RankContainer.RankingData2.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RankingData2 {
            fn default() -> &'a RankingData2 {
                <RankingData2 as ::protobuf::Message>::default_instance()
            }
        }

        impl RankingData2 {
            pub fn new() -> RankingData2 {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "data1",
                    |m: &RankingData2| { &m.data1 },
                    |m: &mut RankingData2| { &mut m.data1 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "data2",
                    |m: &RankingData2| { &m.data2 },
                    |m: &mut RankingData2| { &mut m.data2 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::data::Ranking>(
                    "rankdata",
                    |m: &RankingData2| { &m.rankdata },
                    |m: &mut RankingData2| { &mut m.rankdata },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "data3",
                    |m: &RankingData2| { &m.data3 },
                    |m: &mut RankingData2| { &mut m.data3 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "data4",
                    |m: &RankingData2| { &m.data4 },
                    |m: &mut RankingData2| { &mut m.data4 },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "data5",
                    |m: &RankingData2| { &m.data5 },
                    |m: &mut RankingData2| { &mut m.data5 },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankingData2>(
                    "WebcastHourlyRankMessage.RankContainer.RankingData2",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RankingData2 {
            const NAME: &'static str = "RankingData2";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.data1 = is.read_uint32()?;
                        },
                        16 => {
                            self.data2 = is.read_uint32()?;
                        },
                        26 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankdata)?;
                        },
                        34 => {
                            self.data3 = is.read_string()?;
                        },
                        40 => {
                            self.data4 = is.read_uint32()?;
                        },
                        48 => {
                            self.data5 = is.read_uint32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.data1 != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.data1);
                }
                if self.data2 != 0 {
                    my_size += ::protobuf::rt::uint32_size(2, self.data2);
                }
                if let Some(v) = self.rankdata.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if !self.data3.is_empty() {
                    my_size += ::protobuf::rt::string_size(4, &self.data3);
                }
                if self.data4 != 0 {
                    my_size += ::protobuf::rt::uint32_size(5, self.data4);
                }
                if self.data5 != 0 {
                    my_size += ::protobuf::rt::uint32_size(6, self.data5);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.data1 != 0 {
                    os.write_uint32(1, self.data1)?;
                }
                if self.data2 != 0 {
                    os.write_uint32(2, self.data2)?;
                }
                if let Some(v) = self.rankdata.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                }
                if !self.data3.is_empty() {
                    os.write_string(4, &self.data3)?;
                }
                if self.data4 != 0 {
                    os.write_uint32(5, self.data4)?;
                }
                if self.data5 != 0 {
                    os.write_uint32(6, self.data5)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RankingData2 {
                RankingData2::new()
            }

            fn clear(&mut self) {
                self.data1 = 0;
                self.data2 = 0;
                self.rankdata.clear();
                self.data3.clear();
                self.data4 = 0;
                self.data5 = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RankingData2 {
                static instance: RankingData2 = RankingData2 {
                    data1: 0,
                    data2: 0,
                    rankdata: ::protobuf::MessageField::none(),
                    data3: ::std::string::String::new(),
                    data4: 0,
                    data5: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for RankingData2 {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("WebcastHourlyRankMessage.RankContainer.RankingData2").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RankingData2 {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RankingData2 {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkMicArmies)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkMicArmies {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.id)
    pub id: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.battleItems)
    pub battleItems: ::std::vec::Vec<super::data::LinkMicArmiesItems>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.id2)
    pub id2: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.timeStamp1)
    pub timeStamp1: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.timeStamp2)
    pub timeStamp2: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.battleStatus)
    pub battleStatus: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.data1)
    pub data1: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.data2)
    pub data2: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.data3)
    pub data3: u32,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.Image)
    pub Image: ::protobuf::MessageField<super::data::Image>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.data4)
    pub data4: u32,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicArmies.data5)
    pub data5: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicArmies.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkMicArmies {
    fn default() -> &'a WebcastLinkMicArmies {
        <WebcastLinkMicArmies as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkMicArmies {
    pub fn new() -> WebcastLinkMicArmies {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLinkMicArmies| { &m.common },
            |m: &mut WebcastLinkMicArmies| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WebcastLinkMicArmies| { &m.id },
            |m: &mut WebcastLinkMicArmies| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "battleItems",
            |m: &WebcastLinkMicArmies| { &m.battleItems },
            |m: &mut WebcastLinkMicArmies| { &mut m.battleItems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id2",
            |m: &WebcastLinkMicArmies| { &m.id2 },
            |m: &mut WebcastLinkMicArmies| { &mut m.id2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timeStamp1",
            |m: &WebcastLinkMicArmies| { &m.timeStamp1 },
            |m: &mut WebcastLinkMicArmies| { &mut m.timeStamp1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timeStamp2",
            |m: &WebcastLinkMicArmies| { &m.timeStamp2 },
            |m: &mut WebcastLinkMicArmies| { &mut m.timeStamp2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "battleStatus",
            |m: &WebcastLinkMicArmies| { &m.battleStatus },
            |m: &mut WebcastLinkMicArmies| { &mut m.battleStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data1",
            |m: &WebcastLinkMicArmies| { &m.data1 },
            |m: &mut WebcastLinkMicArmies| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data2",
            |m: &WebcastLinkMicArmies| { &m.data2 },
            |m: &mut WebcastLinkMicArmies| { &mut m.data2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data3",
            |m: &WebcastLinkMicArmies| { &m.data3 },
            |m: &mut WebcastLinkMicArmies| { &mut m.data3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Image>(
            "Image",
            |m: &WebcastLinkMicArmies| { &m.Image },
            |m: &mut WebcastLinkMicArmies| { &mut m.Image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data4",
            |m: &WebcastLinkMicArmies| { &m.data4 },
            |m: &mut WebcastLinkMicArmies| { &mut m.data4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data5",
            |m: &WebcastLinkMicArmies| { &m.data5 },
            |m: &mut WebcastLinkMicArmies| { &mut m.data5 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkMicArmies>(
            "WebcastLinkMicArmies",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkMicArmies {
    const NAME: &'static str = "WebcastLinkMicArmies";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                26 => {
                    self.battleItems.push(is.read_message()?);
                },
                32 => {
                    self.id2 = is.read_uint64()?;
                },
                40 => {
                    self.timeStamp1 = is.read_uint64()?;
                },
                48 => {
                    self.timeStamp2 = is.read_uint64()?;
                },
                56 => {
                    self.battleStatus = is.read_int32()?;
                },
                64 => {
                    self.data1 = is.read_uint64()?;
                },
                72 => {
                    self.data2 = is.read_uint64()?;
                },
                80 => {
                    self.data3 = is.read_uint32()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Image)?;
                },
                96 => {
                    self.data4 = is.read_uint32()?;
                },
                104 => {
                    self.data5 = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        for value in &self.battleItems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.id2 != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.id2);
        }
        if self.timeStamp1 != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.timeStamp1);
        }
        if self.timeStamp2 != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.timeStamp2);
        }
        if self.battleStatus != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.battleStatus);
        }
        if self.data1 != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.data1);
        }
        if self.data2 != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.data2);
        }
        if self.data3 != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.data3);
        }
        if let Some(v) = self.Image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.data4 != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.data4);
        }
        if self.data5 != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.data5);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        for v in &self.battleItems {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.id2 != 0 {
            os.write_uint64(4, self.id2)?;
        }
        if self.timeStamp1 != 0 {
            os.write_uint64(5, self.timeStamp1)?;
        }
        if self.timeStamp2 != 0 {
            os.write_uint64(6, self.timeStamp2)?;
        }
        if self.battleStatus != 0 {
            os.write_int32(7, self.battleStatus)?;
        }
        if self.data1 != 0 {
            os.write_uint64(8, self.data1)?;
        }
        if self.data2 != 0 {
            os.write_uint64(9, self.data2)?;
        }
        if self.data3 != 0 {
            os.write_uint32(10, self.data3)?;
        }
        if let Some(v) = self.Image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if self.data4 != 0 {
            os.write_uint32(12, self.data4)?;
        }
        if self.data5 != 0 {
            os.write_uint32(13, self.data5)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkMicArmies {
        WebcastLinkMicArmies::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.id = 0;
        self.battleItems.clear();
        self.id2 = 0;
        self.timeStamp1 = 0;
        self.timeStamp2 = 0;
        self.battleStatus = 0;
        self.data1 = 0;
        self.data2 = 0;
        self.data3 = 0;
        self.Image.clear();
        self.data4 = 0;
        self.data5 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkMicArmies {
        static instance: WebcastLinkMicArmies = WebcastLinkMicArmies {
            common: ::protobuf::MessageField::none(),
            id: 0,
            battleItems: ::std::vec::Vec::new(),
            id2: 0,
            timeStamp1: 0,
            timeStamp2: 0,
            battleStatus: 0,
            data1: 0,
            data2: 0,
            data3: 0,
            Image: ::protobuf::MessageField::none(),
            data4: 0,
            data5: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkMicArmies {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkMicArmies").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkMicArmies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkMicArmies {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattlePunishFinish)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkMicBattlePunishFinish {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.Header)
    pub Header: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.Id1)
    pub Id1: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.Timestamp)
    pub Timestamp: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.Data4)
    pub Data4: u32,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.Id2)
    pub Id2: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.Data6)
    pub Data6: ::protobuf::MessageField<webcast_link_mic_battle_punish_finish::LinkMicBattlePunishFinishData>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattlePunishFinish.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkMicBattlePunishFinish {
    fn default() -> &'a WebcastLinkMicBattlePunishFinish {
        <WebcastLinkMicBattlePunishFinish as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkMicBattlePunishFinish {
    pub fn new() -> WebcastLinkMicBattlePunishFinish {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "Header",
            |m: &WebcastLinkMicBattlePunishFinish| { &m.Header },
            |m: &mut WebcastLinkMicBattlePunishFinish| { &mut m.Header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Id1",
            |m: &WebcastLinkMicBattlePunishFinish| { &m.Id1 },
            |m: &mut WebcastLinkMicBattlePunishFinish| { &mut m.Id1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Timestamp",
            |m: &WebcastLinkMicBattlePunishFinish| { &m.Timestamp },
            |m: &mut WebcastLinkMicBattlePunishFinish| { &mut m.Timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Data4",
            |m: &WebcastLinkMicBattlePunishFinish| { &m.Data4 },
            |m: &mut WebcastLinkMicBattlePunishFinish| { &mut m.Data4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Id2",
            |m: &WebcastLinkMicBattlePunishFinish| { &m.Id2 },
            |m: &mut WebcastLinkMicBattlePunishFinish| { &mut m.Id2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_link_mic_battle_punish_finish::LinkMicBattlePunishFinishData>(
            "Data6",
            |m: &WebcastLinkMicBattlePunishFinish| { &m.Data6 },
            |m: &mut WebcastLinkMicBattlePunishFinish| { &mut m.Data6 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkMicBattlePunishFinish>(
            "WebcastLinkMicBattlePunishFinish",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkMicBattlePunishFinish {
    const NAME: &'static str = "WebcastLinkMicBattlePunishFinish";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Header)?;
                },
                16 => {
                    self.Id1 = is.read_uint64()?;
                },
                24 => {
                    self.Timestamp = is.read_uint64()?;
                },
                32 => {
                    self.Data4 = is.read_uint32()?;
                },
                40 => {
                    self.Id2 = is.read_uint64()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Data6)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.Id1 != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.Id1);
        }
        if self.Timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.Timestamp);
        }
        if self.Data4 != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.Data4);
        }
        if self.Id2 != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.Id2);
        }
        if let Some(v) = self.Data6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.Id1 != 0 {
            os.write_uint64(2, self.Id1)?;
        }
        if self.Timestamp != 0 {
            os.write_uint64(3, self.Timestamp)?;
        }
        if self.Data4 != 0 {
            os.write_uint32(4, self.Data4)?;
        }
        if self.Id2 != 0 {
            os.write_uint64(5, self.Id2)?;
        }
        if let Some(v) = self.Data6.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkMicBattlePunishFinish {
        WebcastLinkMicBattlePunishFinish::new()
    }

    fn clear(&mut self) {
        self.Header.clear();
        self.Id1 = 0;
        self.Timestamp = 0;
        self.Data4 = 0;
        self.Id2 = 0;
        self.Data6.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkMicBattlePunishFinish {
        static instance: WebcastLinkMicBattlePunishFinish = WebcastLinkMicBattlePunishFinish {
            Header: ::protobuf::MessageField::none(),
            Id1: 0,
            Timestamp: 0,
            Data4: 0,
            Id2: 0,
            Data6: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkMicBattlePunishFinish {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkMicBattlePunishFinish").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkMicBattlePunishFinish {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkMicBattlePunishFinish {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastLinkMicBattlePunishFinish`
pub mod webcast_link_mic_battle_punish_finish {
    // @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkMicBattlePunishFinishData {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.Id2)
        pub Id2: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.Timestamp)
        pub Timestamp: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.Data3)
        pub Data3: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.Id1)
        pub Id1: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.Data5)
        pub Data5: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.Data6)
        pub Data6: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.Data8)
        pub Data8: u32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkMicBattlePunishFinishData {
        fn default() -> &'a LinkMicBattlePunishFinishData {
            <LinkMicBattlePunishFinishData as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkMicBattlePunishFinishData {
        pub fn new() -> LinkMicBattlePunishFinishData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Id2",
                |m: &LinkMicBattlePunishFinishData| { &m.Id2 },
                |m: &mut LinkMicBattlePunishFinishData| { &mut m.Id2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Timestamp",
                |m: &LinkMicBattlePunishFinishData| { &m.Timestamp },
                |m: &mut LinkMicBattlePunishFinishData| { &mut m.Timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Data3",
                |m: &LinkMicBattlePunishFinishData| { &m.Data3 },
                |m: &mut LinkMicBattlePunishFinishData| { &mut m.Data3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Id1",
                |m: &LinkMicBattlePunishFinishData| { &m.Id1 },
                |m: &mut LinkMicBattlePunishFinishData| { &mut m.Id1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Data5",
                |m: &LinkMicBattlePunishFinishData| { &m.Data5 },
                |m: &mut LinkMicBattlePunishFinishData| { &mut m.Data5 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Data6",
                |m: &LinkMicBattlePunishFinishData| { &m.Data6 },
                |m: &mut LinkMicBattlePunishFinishData| { &mut m.Data6 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Data8",
                |m: &LinkMicBattlePunishFinishData| { &m.Data8 },
                |m: &mut LinkMicBattlePunishFinishData| { &mut m.Data8 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicBattlePunishFinishData>(
                "WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkMicBattlePunishFinishData {
        const NAME: &'static str = "LinkMicBattlePunishFinishData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.Id2 = is.read_uint64()?;
                    },
                    16 => {
                        self.Timestamp = is.read_uint64()?;
                    },
                    24 => {
                        self.Data3 = is.read_uint32()?;
                    },
                    32 => {
                        self.Id1 = is.read_uint64()?;
                    },
                    40 => {
                        self.Data5 = is.read_uint32()?;
                    },
                    48 => {
                        self.Data6 = is.read_uint32()?;
                    },
                    64 => {
                        self.Data8 = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.Id2 != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.Id2);
            }
            if self.Timestamp != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.Timestamp);
            }
            if self.Data3 != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.Data3);
            }
            if self.Id1 != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.Id1);
            }
            if self.Data5 != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.Data5);
            }
            if self.Data6 != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.Data6);
            }
            if self.Data8 != 0 {
                my_size += ::protobuf::rt::uint32_size(8, self.Data8);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.Id2 != 0 {
                os.write_uint64(1, self.Id2)?;
            }
            if self.Timestamp != 0 {
                os.write_uint64(2, self.Timestamp)?;
            }
            if self.Data3 != 0 {
                os.write_uint32(3, self.Data3)?;
            }
            if self.Id1 != 0 {
                os.write_uint64(4, self.Id1)?;
            }
            if self.Data5 != 0 {
                os.write_uint32(5, self.Data5)?;
            }
            if self.Data6 != 0 {
                os.write_uint32(6, self.Data6)?;
            }
            if self.Data8 != 0 {
                os.write_uint32(8, self.Data8)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkMicBattlePunishFinishData {
            LinkMicBattlePunishFinishData::new()
        }

        fn clear(&mut self) {
            self.Id2 = 0;
            self.Timestamp = 0;
            self.Data3 = 0;
            self.Id1 = 0;
            self.Data5 = 0;
            self.Data6 = 0;
            self.Data8 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkMicBattlePunishFinishData {
            static instance: LinkMicBattlePunishFinishData = LinkMicBattlePunishFinishData {
                Id2: 0,
                Timestamp: 0,
                Data3: 0,
                Id1: 0,
                Data5: 0,
                Data6: 0,
                Data8: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkMicBattlePunishFinishData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkMicBattlePunishFinish.LinkMicBattlePunishFinishData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkMicBattlePunishFinishData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkMicBattlePunishFinishData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkmicBattleTaskMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkmicBattleTaskMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.Header)
    pub Header: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.Data2)
    pub Data2: u32,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.Data3)
    pub Data3: ::protobuf::MessageField<webcast_linkmic_battle_task_message::LinkmicBattleTaskData>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.Data5)
    pub Data5: ::protobuf::MessageField<webcast_linkmic_battle_task_message::LinkmicBattleTaskData2>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkmicBattleTaskMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkmicBattleTaskMessage {
    fn default() -> &'a WebcastLinkmicBattleTaskMessage {
        <WebcastLinkmicBattleTaskMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkmicBattleTaskMessage {
    pub fn new() -> WebcastLinkmicBattleTaskMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "Header",
            |m: &WebcastLinkmicBattleTaskMessage| { &m.Header },
            |m: &mut WebcastLinkmicBattleTaskMessage| { &mut m.Header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Data2",
            |m: &WebcastLinkmicBattleTaskMessage| { &m.Data2 },
            |m: &mut WebcastLinkmicBattleTaskMessage| { &mut m.Data2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_linkmic_battle_task_message::LinkmicBattleTaskData>(
            "Data3",
            |m: &WebcastLinkmicBattleTaskMessage| { &m.Data3 },
            |m: &mut WebcastLinkmicBattleTaskMessage| { &mut m.Data3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_linkmic_battle_task_message::LinkmicBattleTaskData2>(
            "Data5",
            |m: &WebcastLinkmicBattleTaskMessage| { &m.Data5 },
            |m: &mut WebcastLinkmicBattleTaskMessage| { &mut m.Data5 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkmicBattleTaskMessage>(
            "WebcastLinkmicBattleTaskMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkmicBattleTaskMessage {
    const NAME: &'static str = "WebcastLinkmicBattleTaskMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Header)?;
                },
                16 => {
                    self.Data2 = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Data3)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Data5)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.Data2 != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.Data2);
        }
        if let Some(v) = self.Data3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.Data5.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.Data2 != 0 {
            os.write_uint32(2, self.Data2)?;
        }
        if let Some(v) = self.Data3.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.Data5.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkmicBattleTaskMessage {
        WebcastLinkmicBattleTaskMessage::new()
    }

    fn clear(&mut self) {
        self.Header.clear();
        self.Data2 = 0;
        self.Data3.clear();
        self.Data5.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkmicBattleTaskMessage {
        static instance: WebcastLinkmicBattleTaskMessage = WebcastLinkmicBattleTaskMessage {
            Header: ::protobuf::MessageField::none(),
            Data2: 0,
            Data3: ::protobuf::MessageField::none(),
            Data5: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkmicBattleTaskMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkmicBattleTaskMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkmicBattleTaskMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkmicBattleTaskMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastLinkmicBattleTaskMessage`
pub mod webcast_linkmic_battle_task_message {
    // @@protoc_insertion_point(message:TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkmicBattleTaskData {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData.Data1)
        pub Data1: ::protobuf::MessageField<BattleTaskData>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkmicBattleTaskData {
        fn default() -> &'a LinkmicBattleTaskData {
            <LinkmicBattleTaskData as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkmicBattleTaskData {
        pub fn new() -> LinkmicBattleTaskData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BattleTaskData>(
                "Data1",
                |m: &LinkmicBattleTaskData| { &m.Data1 },
                |m: &mut LinkmicBattleTaskData| { &mut m.Data1 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkmicBattleTaskData>(
                "WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkmicBattleTaskData {
        const NAME: &'static str = "LinkmicBattleTaskData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.Data1)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.Data1.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.Data1.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkmicBattleTaskData {
            LinkmicBattleTaskData::new()
        }

        fn clear(&mut self) {
            self.Data1.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkmicBattleTaskData {
            static instance: LinkmicBattleTaskData = LinkmicBattleTaskData {
                Data1: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkmicBattleTaskData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkmicBattleTaskData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkmicBattleTaskData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastLinkmicBattleTaskMessage.BattleTaskData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BattleTaskData {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.BattleTaskData.Data1)
        pub Data1: u32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkmicBattleTaskMessage.BattleTaskData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BattleTaskData {
        fn default() -> &'a BattleTaskData {
            <BattleTaskData as ::protobuf::Message>::default_instance()
        }
    }

    impl BattleTaskData {
        pub fn new() -> BattleTaskData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Data1",
                |m: &BattleTaskData| { &m.Data1 },
                |m: &mut BattleTaskData| { &mut m.Data1 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BattleTaskData>(
                "WebcastLinkmicBattleTaskMessage.BattleTaskData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BattleTaskData {
        const NAME: &'static str = "BattleTaskData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.Data1 = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.Data1 != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.Data1);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.Data1 != 0 {
                os.write_uint32(1, self.Data1)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BattleTaskData {
            BattleTaskData::new()
        }

        fn clear(&mut self) {
            self.Data1 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BattleTaskData {
            static instance: BattleTaskData = BattleTaskData {
                Data1: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BattleTaskData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkmicBattleTaskMessage.BattleTaskData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BattleTaskData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BattleTaskData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData2)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkmicBattleTaskData2 {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData2.Data1)
        pub Data1: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData2.Data2)
        pub Data2: u32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData2.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkmicBattleTaskData2 {
        fn default() -> &'a LinkmicBattleTaskData2 {
            <LinkmicBattleTaskData2 as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkmicBattleTaskData2 {
        pub fn new() -> LinkmicBattleTaskData2 {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Data1",
                |m: &LinkmicBattleTaskData2| { &m.Data1 },
                |m: &mut LinkmicBattleTaskData2| { &mut m.Data1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "Data2",
                |m: &LinkmicBattleTaskData2| { &m.Data2 },
                |m: &mut LinkmicBattleTaskData2| { &mut m.Data2 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkmicBattleTaskData2>(
                "WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData2",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkmicBattleTaskData2 {
        const NAME: &'static str = "LinkmicBattleTaskData2";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.Data1 = is.read_uint32()?;
                    },
                    16 => {
                        self.Data2 = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.Data1 != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.Data1);
            }
            if self.Data2 != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.Data2);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.Data1 != 0 {
                os.write_uint32(1, self.Data1)?;
            }
            if self.Data2 != 0 {
                os.write_uint32(2, self.Data2)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkmicBattleTaskData2 {
            LinkmicBattleTaskData2::new()
        }

        fn clear(&mut self) {
            self.Data1 = 0;
            self.Data2 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkmicBattleTaskData2 {
            static instance: LinkmicBattleTaskData2 = LinkmicBattleTaskData2 {
                Data1: 0,
                Data2: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkmicBattleTaskData2 {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData2").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkmicBattleTaskData2 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkmicBattleTaskData2 {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkMicBattle {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.id)
    pub id: u64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.battleConfig)
    pub battleConfig: ::protobuf::MessageField<webcast_link_mic_battle::LinkMicBattleConfig>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.data2)
    pub data2: u32,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.details)
    pub details: ::std::vec::Vec<webcast_link_mic_battle::LinkMicBattleDetails>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.teams1)
    pub teams1: ::std::vec::Vec<webcast_link_mic_battle::LinkMicBattleTeam>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.teams2)
    pub teams2: ::std::vec::Vec<webcast_link_mic_battle::LinkMicBattleTeam>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.teamData)
    pub teamData: ::std::vec::Vec<webcast_link_mic_battle::LinkMicBattleTeamData>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkMicBattle {
    fn default() -> &'a WebcastLinkMicBattle {
        <WebcastLinkMicBattle as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkMicBattle {
    pub fn new() -> WebcastLinkMicBattle {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLinkMicBattle| { &m.common },
            |m: &mut WebcastLinkMicBattle| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WebcastLinkMicBattle| { &m.id },
            |m: &mut WebcastLinkMicBattle| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_link_mic_battle::LinkMicBattleConfig>(
            "battleConfig",
            |m: &WebcastLinkMicBattle| { &m.battleConfig },
            |m: &mut WebcastLinkMicBattle| { &mut m.battleConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data2",
            |m: &WebcastLinkMicBattle| { &m.data2 },
            |m: &mut WebcastLinkMicBattle| { &mut m.data2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "details",
            |m: &WebcastLinkMicBattle| { &m.details },
            |m: &mut WebcastLinkMicBattle| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams1",
            |m: &WebcastLinkMicBattle| { &m.teams1 },
            |m: &mut WebcastLinkMicBattle| { &mut m.teams1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams2",
            |m: &WebcastLinkMicBattle| { &m.teams2 },
            |m: &mut WebcastLinkMicBattle| { &mut m.teams2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teamData",
            |m: &WebcastLinkMicBattle| { &m.teamData },
            |m: &mut WebcastLinkMicBattle| { &mut m.teamData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkMicBattle>(
            "WebcastLinkMicBattle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkMicBattle {
    const NAME: &'static str = "WebcastLinkMicBattle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.battleConfig)?;
                },
                32 => {
                    self.data2 = is.read_uint32()?;
                },
                42 => {
                    self.details.push(is.read_message()?);
                },
                74 => {
                    self.teams1.push(is.read_message()?);
                },
                82 => {
                    self.teams2.push(is.read_message()?);
                },
                106 => {
                    self.teamData.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        if let Some(v) = self.battleConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.data2 != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.data2);
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.teams1 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.teams2 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.teamData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        if let Some(v) = self.battleConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.data2 != 0 {
            os.write_uint32(4, self.data2)?;
        }
        for v in &self.details {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.teams1 {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.teams2 {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.teamData {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkMicBattle {
        WebcastLinkMicBattle::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.id = 0;
        self.battleConfig.clear();
        self.data2 = 0;
        self.details.clear();
        self.teams1.clear();
        self.teams2.clear();
        self.teamData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkMicBattle {
        static instance: WebcastLinkMicBattle = WebcastLinkMicBattle {
            common: ::protobuf::MessageField::none(),
            id: 0,
            battleConfig: ::protobuf::MessageField::none(),
            data2: 0,
            details: ::std::vec::Vec::new(),
            teams1: ::std::vec::Vec::new(),
            teams2: ::std::vec::Vec::new(),
            teamData: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkMicBattle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkMicBattle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkMicBattle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkMicBattle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastLinkMicBattle`
pub mod webcast_link_mic_battle {
    // @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattle.LinkMicBattleConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkMicBattleConfig {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleConfig.id1)
        pub id1: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleConfig.timestamp)
        pub timestamp: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleConfig.data1)
        pub data1: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleConfig.id2)
        pub id2: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleConfig.data2)
        pub data2: u32,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattle.LinkMicBattleConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkMicBattleConfig {
        fn default() -> &'a LinkMicBattleConfig {
            <LinkMicBattleConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkMicBattleConfig {
        pub fn new() -> LinkMicBattleConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id1",
                |m: &LinkMicBattleConfig| { &m.id1 },
                |m: &mut LinkMicBattleConfig| { &mut m.id1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timestamp",
                |m: &LinkMicBattleConfig| { &m.timestamp },
                |m: &mut LinkMicBattleConfig| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data1",
                |m: &LinkMicBattleConfig| { &m.data1 },
                |m: &mut LinkMicBattleConfig| { &mut m.data1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id2",
                |m: &LinkMicBattleConfig| { &m.id2 },
                |m: &mut LinkMicBattleConfig| { &mut m.id2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data2",
                |m: &LinkMicBattleConfig| { &m.data2 },
                |m: &mut LinkMicBattleConfig| { &mut m.data2 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicBattleConfig>(
                "WebcastLinkMicBattle.LinkMicBattleConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkMicBattleConfig {
        const NAME: &'static str = "LinkMicBattleConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id1 = is.read_uint64()?;
                    },
                    16 => {
                        self.timestamp = is.read_uint64()?;
                    },
                    24 => {
                        self.data1 = is.read_uint32()?;
                    },
                    32 => {
                        self.id2 = is.read_uint64()?;
                    },
                    40 => {
                        self.data2 = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id1 != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.id1);
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.timestamp);
            }
            if self.data1 != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.data1);
            }
            if self.id2 != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.id2);
            }
            if self.data2 != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.data2);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id1 != 0 {
                os.write_uint64(1, self.id1)?;
            }
            if self.timestamp != 0 {
                os.write_uint64(2, self.timestamp)?;
            }
            if self.data1 != 0 {
                os.write_uint32(3, self.data1)?;
            }
            if self.id2 != 0 {
                os.write_uint64(4, self.id2)?;
            }
            if self.data2 != 0 {
                os.write_uint32(5, self.data2)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkMicBattleConfig {
            LinkMicBattleConfig::new()
        }

        fn clear(&mut self) {
            self.id1 = 0;
            self.timestamp = 0;
            self.data1 = 0;
            self.id2 = 0;
            self.data2 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkMicBattleConfig {
            static instance: LinkMicBattleConfig = LinkMicBattleConfig {
                id1: 0,
                timestamp: 0,
                data1: 0,
                id2: 0,
                data2: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkMicBattleConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkMicBattle.LinkMicBattleConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkMicBattleConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkMicBattleConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattle.LinkMicBattleData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkMicBattleData {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleData.id)
        pub id: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleData.data1)
        pub data1: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleData.data2)
        pub data2: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleData.data3)
        pub data3: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleData.url)
        pub url: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattle.LinkMicBattleData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkMicBattleData {
        fn default() -> &'a LinkMicBattleData {
            <LinkMicBattleData as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkMicBattleData {
        pub fn new() -> LinkMicBattleData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &LinkMicBattleData| { &m.id },
                |m: &mut LinkMicBattleData| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data1",
                |m: &LinkMicBattleData| { &m.data1 },
                |m: &mut LinkMicBattleData| { &mut m.data1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data2",
                |m: &LinkMicBattleData| { &m.data2 },
                |m: &mut LinkMicBattleData| { &mut m.data2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data3",
                |m: &LinkMicBattleData| { &m.data3 },
                |m: &mut LinkMicBattleData| { &mut m.data3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "url",
                |m: &LinkMicBattleData| { &m.url },
                |m: &mut LinkMicBattleData| { &mut m.url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicBattleData>(
                "WebcastLinkMicBattle.LinkMicBattleData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkMicBattleData {
        const NAME: &'static str = "LinkMicBattleData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_uint64()?;
                    },
                    16 => {
                        self.data1 = is.read_uint32()?;
                    },
                    24 => {
                        self.data2 = is.read_uint32()?;
                    },
                    40 => {
                        self.data3 = is.read_uint32()?;
                    },
                    50 => {
                        self.url = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.id);
            }
            if self.data1 != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.data1);
            }
            if self.data2 != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.data2);
            }
            if self.data3 != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.data3);
            }
            if !self.url.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.url);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_uint64(1, self.id)?;
            }
            if self.data1 != 0 {
                os.write_uint32(2, self.data1)?;
            }
            if self.data2 != 0 {
                os.write_uint32(3, self.data2)?;
            }
            if self.data3 != 0 {
                os.write_uint32(5, self.data3)?;
            }
            if !self.url.is_empty() {
                os.write_string(6, &self.url)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkMicBattleData {
            LinkMicBattleData::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.data1 = 0;
            self.data2 = 0;
            self.data3 = 0;
            self.url.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkMicBattleData {
            static instance: LinkMicBattleData = LinkMicBattleData {
                id: 0,
                data1: 0,
                data2: 0,
                data3: 0,
                url: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkMicBattleData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkMicBattle.LinkMicBattleData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkMicBattleData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkMicBattleData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattle.LinkMicBattleDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkMicBattleDetails {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleDetails.id)
        pub id: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleDetails.details)
        pub details: ::protobuf::MessageField<LinkMicBattleData>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattle.LinkMicBattleDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkMicBattleDetails {
        fn default() -> &'a LinkMicBattleDetails {
            <LinkMicBattleDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkMicBattleDetails {
        pub fn new() -> LinkMicBattleDetails {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &LinkMicBattleDetails| { &m.id },
                |m: &mut LinkMicBattleDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkMicBattleData>(
                "details",
                |m: &LinkMicBattleDetails| { &m.details },
                |m: &mut LinkMicBattleDetails| { &mut m.details },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicBattleDetails>(
                "WebcastLinkMicBattle.LinkMicBattleDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkMicBattleDetails {
        const NAME: &'static str = "LinkMicBattleDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_uint64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.details)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.id);
            }
            if let Some(v) = self.details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_uint64(1, self.id)?;
            }
            if let Some(v) = self.details.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkMicBattleDetails {
            LinkMicBattleDetails::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.details.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkMicBattleDetails {
            static instance: LinkMicBattleDetails = LinkMicBattleDetails {
                id: 0,
                details: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkMicBattleDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkMicBattle.LinkMicBattleDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkMicBattleDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkMicBattleDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattle.LinkMicBattleTeam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkMicBattleTeam {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleTeam.id)
        pub id: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleTeam.users)
        pub users: ::std::vec::Vec<super::super::data::User>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattle.LinkMicBattleTeam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkMicBattleTeam {
        fn default() -> &'a LinkMicBattleTeam {
            <LinkMicBattleTeam as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkMicBattleTeam {
        pub fn new() -> LinkMicBattleTeam {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &LinkMicBattleTeam| { &m.id },
                |m: &mut LinkMicBattleTeam| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "users",
                |m: &LinkMicBattleTeam| { &m.users },
                |m: &mut LinkMicBattleTeam| { &mut m.users },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicBattleTeam>(
                "WebcastLinkMicBattle.LinkMicBattleTeam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkMicBattleTeam {
        const NAME: &'static str = "LinkMicBattleTeam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_uint64()?;
                    },
                    18 => {
                        self.users.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.id);
            }
            for value in &self.users {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_uint64(1, self.id)?;
            }
            for v in &self.users {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkMicBattleTeam {
            LinkMicBattleTeam::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.users.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkMicBattleTeam {
            static instance: LinkMicBattleTeam = LinkMicBattleTeam {
                id: 0,
                users: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkMicBattleTeam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkMicBattle.LinkMicBattleTeam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkMicBattleTeam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkMicBattleTeam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastLinkMicBattle.LinkMicBattleTeamData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkMicBattleTeamData {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleTeamData.teamId)
        pub teamId: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastLinkMicBattle.LinkMicBattleTeamData.data)
        pub data: ::protobuf::MessageField<LinkMicBattleData>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicBattle.LinkMicBattleTeamData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkMicBattleTeamData {
        fn default() -> &'a LinkMicBattleTeamData {
            <LinkMicBattleTeamData as ::protobuf::Message>::default_instance()
        }
    }

    impl LinkMicBattleTeamData {
        pub fn new() -> LinkMicBattleTeamData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "teamId",
                |m: &LinkMicBattleTeamData| { &m.teamId },
                |m: &mut LinkMicBattleTeamData| { &mut m.teamId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkMicBattleData>(
                "data",
                |m: &LinkMicBattleTeamData| { &m.data },
                |m: &mut LinkMicBattleTeamData| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkMicBattleTeamData>(
                "WebcastLinkMicBattle.LinkMicBattleTeamData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LinkMicBattleTeamData {
        const NAME: &'static str = "LinkMicBattleTeamData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.teamId = is.read_uint64()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.teamId != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.teamId);
            }
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.teamId != 0 {
                os.write_uint64(1, self.teamId)?;
            }
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkMicBattleTeamData {
            LinkMicBattleTeamData::new()
        }

        fn clear(&mut self) {
            self.teamId = 0;
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkMicBattleTeamData {
            static instance: LinkMicBattleTeamData = LinkMicBattleTeamData {
                teamId: 0,
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LinkMicBattleTeamData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastLinkMicBattle.LinkMicBattleTeamData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkMicBattleTeamData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LinkMicBattleTeamData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkMicFanTicketMethod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkMicFanTicketMethod {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicFanTicketMethod.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicFanTicketMethod.FanTicketRoomNotice)
    pub FanTicketRoomNotice: ::protobuf::MessageField<super::data::FanTicketRoomNoticeContent>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicFanTicketMethod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkMicFanTicketMethod {
    fn default() -> &'a WebcastLinkMicFanTicketMethod {
        <WebcastLinkMicFanTicketMethod as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkMicFanTicketMethod {
    pub fn new() -> WebcastLinkMicFanTicketMethod {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLinkMicFanTicketMethod| { &m.common },
            |m: &mut WebcastLinkMicFanTicketMethod| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::FanTicketRoomNoticeContent>(
            "FanTicketRoomNotice",
            |m: &WebcastLinkMicFanTicketMethod| { &m.FanTicketRoomNotice },
            |m: &mut WebcastLinkMicFanTicketMethod| { &mut m.FanTicketRoomNotice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkMicFanTicketMethod>(
            "WebcastLinkMicFanTicketMethod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkMicFanTicketMethod {
    const NAME: &'static str = "WebcastLinkMicFanTicketMethod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.FanTicketRoomNotice)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.FanTicketRoomNotice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.FanTicketRoomNotice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkMicFanTicketMethod {
        WebcastLinkMicFanTicketMethod::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.FanTicketRoomNotice.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkMicFanTicketMethod {
        static instance: WebcastLinkMicFanTicketMethod = WebcastLinkMicFanTicketMethod {
            common: ::protobuf::MessageField::none(),
            FanTicketRoomNotice: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkMicFanTicketMethod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkMicFanTicketMethod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkMicFanTicketMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkMicFanTicketMethod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkMicMethod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkMicMethod {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.messageType)
    pub messageType: ::protobuf::EnumOrUnknown<super::enums::MessageType>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.accessKey)
    pub accessKey: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.anchorLinkmicId)
    pub anchorLinkmicId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.userId)
    pub userId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.fanTicket)
    pub fanTicket: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.totalLinkMicFanTicket)
    pub totalLinkMicFanTicket: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.channelId)
    pub channelId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.layout)
    pub layout: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.vendor)
    pub vendor: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.dimension)
    pub dimension: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.theme)
    pub theme: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMicMethod.inviteUid)
    pub inviteUid: i64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMicMethod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkMicMethod {
    fn default() -> &'a WebcastLinkMicMethod {
        <WebcastLinkMicMethod as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkMicMethod {
    pub fn new() -> WebcastLinkMicMethod {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLinkMicMethod| { &m.common },
            |m: &mut WebcastLinkMicMethod| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "messageType",
            |m: &WebcastLinkMicMethod| { &m.messageType },
            |m: &mut WebcastLinkMicMethod| { &mut m.messageType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accessKey",
            |m: &WebcastLinkMicMethod| { &m.accessKey },
            |m: &mut WebcastLinkMicMethod| { &mut m.accessKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "anchorLinkmicId",
            |m: &WebcastLinkMicMethod| { &m.anchorLinkmicId },
            |m: &mut WebcastLinkMicMethod| { &mut m.anchorLinkmicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &WebcastLinkMicMethod| { &m.userId },
            |m: &mut WebcastLinkMicMethod| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fanTicket",
            |m: &WebcastLinkMicMethod| { &m.fanTicket },
            |m: &mut WebcastLinkMicMethod| { &mut m.fanTicket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "totalLinkMicFanTicket",
            |m: &WebcastLinkMicMethod| { &m.totalLinkMicFanTicket },
            |m: &mut WebcastLinkMicMethod| { &mut m.totalLinkMicFanTicket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channelId",
            |m: &WebcastLinkMicMethod| { &m.channelId },
            |m: &mut WebcastLinkMicMethod| { &mut m.channelId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "layout",
            |m: &WebcastLinkMicMethod| { &m.layout },
            |m: &mut WebcastLinkMicMethod| { &mut m.layout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vendor",
            |m: &WebcastLinkMicMethod| { &m.vendor },
            |m: &mut WebcastLinkMicMethod| { &mut m.vendor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dimension",
            |m: &WebcastLinkMicMethod| { &m.dimension },
            |m: &mut WebcastLinkMicMethod| { &mut m.dimension },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "theme",
            |m: &WebcastLinkMicMethod| { &m.theme },
            |m: &mut WebcastLinkMicMethod| { &mut m.theme },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inviteUid",
            |m: &WebcastLinkMicMethod| { &m.inviteUid },
            |m: &mut WebcastLinkMicMethod| { &mut m.inviteUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkMicMethod>(
            "WebcastLinkMicMethod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkMicMethod {
    const NAME: &'static str = "WebcastLinkMicMethod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.messageType = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.accessKey = is.read_string()?;
                },
                32 => {
                    self.anchorLinkmicId = is.read_int64()?;
                },
                40 => {
                    self.userId = is.read_int64()?;
                },
                48 => {
                    self.fanTicket = is.read_int64()?;
                },
                56 => {
                    self.totalLinkMicFanTicket = is.read_int64()?;
                },
                64 => {
                    self.channelId = is.read_int64()?;
                },
                72 => {
                    self.layout = is.read_int64()?;
                },
                80 => {
                    self.vendor = is.read_int64()?;
                },
                88 => {
                    self.dimension = is.read_int64()?;
                },
                98 => {
                    self.theme = is.read_string()?;
                },
                104 => {
                    self.inviteUid = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.messageType != ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS) {
            my_size += ::protobuf::rt::int32_size(2, self.messageType.value());
        }
        if !self.accessKey.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.accessKey);
        }
        if self.anchorLinkmicId != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.anchorLinkmicId);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.userId);
        }
        if self.fanTicket != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.fanTicket);
        }
        if self.totalLinkMicFanTicket != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.totalLinkMicFanTicket);
        }
        if self.channelId != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.channelId);
        }
        if self.layout != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.layout);
        }
        if self.vendor != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.vendor);
        }
        if self.dimension != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.dimension);
        }
        if !self.theme.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.theme);
        }
        if self.inviteUid != 0 {
            my_size += ::protobuf::rt::int64_size(13, self.inviteUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.messageType != ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.messageType))?;
        }
        if !self.accessKey.is_empty() {
            os.write_string(3, &self.accessKey)?;
        }
        if self.anchorLinkmicId != 0 {
            os.write_int64(4, self.anchorLinkmicId)?;
        }
        if self.userId != 0 {
            os.write_int64(5, self.userId)?;
        }
        if self.fanTicket != 0 {
            os.write_int64(6, self.fanTicket)?;
        }
        if self.totalLinkMicFanTicket != 0 {
            os.write_int64(7, self.totalLinkMicFanTicket)?;
        }
        if self.channelId != 0 {
            os.write_int64(8, self.channelId)?;
        }
        if self.layout != 0 {
            os.write_int64(9, self.layout)?;
        }
        if self.vendor != 0 {
            os.write_int64(10, self.vendor)?;
        }
        if self.dimension != 0 {
            os.write_int64(11, self.dimension)?;
        }
        if !self.theme.is_empty() {
            os.write_string(12, &self.theme)?;
        }
        if self.inviteUid != 0 {
            os.write_int64(13, self.inviteUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkMicMethod {
        WebcastLinkMicMethod::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.messageType = ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS);
        self.accessKey.clear();
        self.anchorLinkmicId = 0;
        self.userId = 0;
        self.fanTicket = 0;
        self.totalLinkMicFanTicket = 0;
        self.channelId = 0;
        self.layout = 0;
        self.vendor = 0;
        self.dimension = 0;
        self.theme.clear();
        self.inviteUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkMicMethod {
        static instance: WebcastLinkMicMethod = WebcastLinkMicMethod {
            common: ::protobuf::MessageField::none(),
            messageType: ::protobuf::EnumOrUnknown::from_i32(0),
            accessKey: ::std::string::String::new(),
            anchorLinkmicId: 0,
            userId: 0,
            fanTicket: 0,
            totalLinkMicFanTicket: 0,
            channelId: 0,
            layout: 0,
            vendor: 0,
            dimension: 0,
            theme: ::std::string::String::new(),
            inviteUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkMicMethod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkMicMethod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkMicMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkMicMethod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastLiveIntroMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLiveIntroMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.roomId)
    pub roomId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.auditStatus)
    pub auditStatus: ::protobuf::EnumOrUnknown<super::enums::AuditStatus>,
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.host)
    pub host: ::protobuf::MessageField<super::data::User>,
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.introMode)
    pub introMode: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.badges)
    pub badges: ::std::vec::Vec<super::data::BadgeStruct>,
    // @@protoc_insertion_point(field:TikTok.WebcastLiveIntroMessage.language)
    pub language: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLiveIntroMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLiveIntroMessage {
    fn default() -> &'a WebcastLiveIntroMessage {
        <WebcastLiveIntroMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLiveIntroMessage {
    pub fn new() -> WebcastLiveIntroMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLiveIntroMessage| { &m.common },
            |m: &mut WebcastLiveIntroMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roomId",
            |m: &WebcastLiveIntroMessage| { &m.roomId },
            |m: &mut WebcastLiveIntroMessage| { &mut m.roomId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auditStatus",
            |m: &WebcastLiveIntroMessage| { &m.auditStatus },
            |m: &mut WebcastLiveIntroMessage| { &mut m.auditStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &WebcastLiveIntroMessage| { &m.content },
            |m: &mut WebcastLiveIntroMessage| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::User>(
            "host",
            |m: &WebcastLiveIntroMessage| { &m.host },
            |m: &mut WebcastLiveIntroMessage| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "introMode",
            |m: &WebcastLiveIntroMessage| { &m.introMode },
            |m: &mut WebcastLiveIntroMessage| { &mut m.introMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "badges",
            |m: &WebcastLiveIntroMessage| { &m.badges },
            |m: &mut WebcastLiveIntroMessage| { &mut m.badges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &WebcastLiveIntroMessage| { &m.language },
            |m: &mut WebcastLiveIntroMessage| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLiveIntroMessage>(
            "WebcastLiveIntroMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLiveIntroMessage {
    const NAME: &'static str = "WebcastLiveIntroMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.roomId = is.read_int64()?;
                },
                24 => {
                    self.auditStatus = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.content = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.host)?;
                },
                48 => {
                    self.introMode = is.read_int32()?;
                },
                58 => {
                    self.badges.push(is.read_message()?);
                },
                66 => {
                    self.language = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.roomId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.roomId);
        }
        if self.auditStatus != ::protobuf::EnumOrUnknown::new(super::enums::AuditStatus::AUDITSTATUSUNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.auditStatus.value());
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.content);
        }
        if let Some(v) = self.host.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.introMode != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.introMode);
        }
        for value in &self.badges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.roomId != 0 {
            os.write_int64(2, self.roomId)?;
        }
        if self.auditStatus != ::protobuf::EnumOrUnknown::new(super::enums::AuditStatus::AUDITSTATUSUNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.auditStatus))?;
        }
        if !self.content.is_empty() {
            os.write_string(4, &self.content)?;
        }
        if let Some(v) = self.host.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.introMode != 0 {
            os.write_int32(6, self.introMode)?;
        }
        for v in &self.badges {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if !self.language.is_empty() {
            os.write_string(8, &self.language)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLiveIntroMessage {
        WebcastLiveIntroMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.roomId = 0;
        self.auditStatus = ::protobuf::EnumOrUnknown::new(super::enums::AuditStatus::AUDITSTATUSUNKNOWN);
        self.content.clear();
        self.host.clear();
        self.introMode = 0;
        self.badges.clear();
        self.language.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLiveIntroMessage {
        static instance: WebcastLiveIntroMessage = WebcastLiveIntroMessage {
            common: ::protobuf::MessageField::none(),
            roomId: 0,
            auditStatus: ::protobuf::EnumOrUnknown::from_i32(0),
            content: ::std::string::String::new(),
            host: ::protobuf::MessageField::none(),
            introMode: 0,
            badges: ::std::vec::Vec::new(),
            language: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLiveIntroMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLiveIntroMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLiveIntroMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLiveIntroMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastUnauthorizedMemberMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastUnauthorizedMemberMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastUnauthorizedMemberMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastUnauthorizedMemberMessage.action)
    pub action: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastUnauthorizedMemberMessage.nickNamePrefix)
    pub nickNamePrefix: ::protobuf::MessageField<super::data::Text>,
    // @@protoc_insertion_point(field:TikTok.WebcastUnauthorizedMemberMessage.nickName)
    pub nickName: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastUnauthorizedMemberMessage.enterText)
    pub enterText: ::protobuf::MessageField<super::data::Text>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastUnauthorizedMemberMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastUnauthorizedMemberMessage {
    fn default() -> &'a WebcastUnauthorizedMemberMessage {
        <WebcastUnauthorizedMemberMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastUnauthorizedMemberMessage {
    pub fn new() -> WebcastUnauthorizedMemberMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastUnauthorizedMemberMessage| { &m.common },
            |m: &mut WebcastUnauthorizedMemberMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &WebcastUnauthorizedMemberMessage| { &m.action },
            |m: &mut WebcastUnauthorizedMemberMessage| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "nickNamePrefix",
            |m: &WebcastUnauthorizedMemberMessage| { &m.nickNamePrefix },
            |m: &mut WebcastUnauthorizedMemberMessage| { &mut m.nickNamePrefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nickName",
            |m: &WebcastUnauthorizedMemberMessage| { &m.nickName },
            |m: &mut WebcastUnauthorizedMemberMessage| { &mut m.nickName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Text>(
            "enterText",
            |m: &WebcastUnauthorizedMemberMessage| { &m.enterText },
            |m: &mut WebcastUnauthorizedMemberMessage| { &mut m.enterText },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastUnauthorizedMemberMessage>(
            "WebcastUnauthorizedMemberMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastUnauthorizedMemberMessage {
    const NAME: &'static str = "WebcastUnauthorizedMemberMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.action = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nickNamePrefix)?;
                },
                34 => {
                    self.nickName = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.enterText)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.action != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.action);
        }
        if let Some(v) = self.nickNamePrefix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.nickName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.nickName);
        }
        if let Some(v) = self.enterText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.action != 0 {
            os.write_int32(2, self.action)?;
        }
        if let Some(v) = self.nickNamePrefix.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.nickName.is_empty() {
            os.write_string(4, &self.nickName)?;
        }
        if let Some(v) = self.enterText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastUnauthorizedMemberMessage {
        WebcastUnauthorizedMemberMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.action = 0;
        self.nickNamePrefix.clear();
        self.nickName.clear();
        self.enterText.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastUnauthorizedMemberMessage {
        static instance: WebcastUnauthorizedMemberMessage = WebcastUnauthorizedMemberMessage {
            common: ::protobuf::MessageField::none(),
            action: 0,
            nickNamePrefix: ::protobuf::MessageField::none(),
            nickName: ::std::string::String::new(),
            enterText: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastUnauthorizedMemberMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastUnauthorizedMemberMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastUnauthorizedMemberMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastUnauthorizedMemberMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastMsgDetectMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastMsgDetectMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.detectType)
    pub detectType: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.triggerCondition)
    pub triggerCondition: ::protobuf::MessageField<webcast_msg_detect_message::TriggerCondition>,
    // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.timeInfo)
    pub timeInfo: ::protobuf::MessageField<webcast_msg_detect_message::TimeInfo>,
    // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.triggerBy)
    pub triggerBy: i32,
    // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.fromRegion)
    pub fromRegion: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastMsgDetectMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastMsgDetectMessage {
    fn default() -> &'a WebcastMsgDetectMessage {
        <WebcastMsgDetectMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastMsgDetectMessage {
    pub fn new() -> WebcastMsgDetectMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastMsgDetectMessage| { &m.common },
            |m: &mut WebcastMsgDetectMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "detectType",
            |m: &WebcastMsgDetectMessage| { &m.detectType },
            |m: &mut WebcastMsgDetectMessage| { &mut m.detectType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_msg_detect_message::TriggerCondition>(
            "triggerCondition",
            |m: &WebcastMsgDetectMessage| { &m.triggerCondition },
            |m: &mut WebcastMsgDetectMessage| { &mut m.triggerCondition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_msg_detect_message::TimeInfo>(
            "timeInfo",
            |m: &WebcastMsgDetectMessage| { &m.timeInfo },
            |m: &mut WebcastMsgDetectMessage| { &mut m.timeInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "triggerBy",
            |m: &WebcastMsgDetectMessage| { &m.triggerBy },
            |m: &mut WebcastMsgDetectMessage| { &mut m.triggerBy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromRegion",
            |m: &WebcastMsgDetectMessage| { &m.fromRegion },
            |m: &mut WebcastMsgDetectMessage| { &mut m.fromRegion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastMsgDetectMessage>(
            "WebcastMsgDetectMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastMsgDetectMessage {
    const NAME: &'static str = "WebcastMsgDetectMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.detectType = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.triggerCondition)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeInfo)?;
                },
                40 => {
                    self.triggerBy = is.read_int32()?;
                },
                50 => {
                    self.fromRegion = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.detectType != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.detectType);
        }
        if let Some(v) = self.triggerCondition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.triggerBy != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.triggerBy);
        }
        if !self.fromRegion.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.fromRegion);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.detectType != 0 {
            os.write_int32(2, self.detectType)?;
        }
        if let Some(v) = self.triggerCondition.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.timeInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.triggerBy != 0 {
            os.write_int32(5, self.triggerBy)?;
        }
        if !self.fromRegion.is_empty() {
            os.write_string(6, &self.fromRegion)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastMsgDetectMessage {
        WebcastMsgDetectMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.detectType = 0;
        self.triggerCondition.clear();
        self.timeInfo.clear();
        self.triggerBy = 0;
        self.fromRegion.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastMsgDetectMessage {
        static instance: WebcastMsgDetectMessage = WebcastMsgDetectMessage {
            common: ::protobuf::MessageField::none(),
            detectType: 0,
            triggerCondition: ::protobuf::MessageField::none(),
            timeInfo: ::protobuf::MessageField::none(),
            triggerBy: 0,
            fromRegion: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastMsgDetectMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastMsgDetectMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastMsgDetectMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastMsgDetectMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastMsgDetectMessage`
pub mod webcast_msg_detect_message {
    // @@protoc_insertion_point(message:TikTok.WebcastMsgDetectMessage.TimeInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TimeInfo {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TimeInfo.clientStartMs)
        pub clientStartMs: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TimeInfo.apiRecvTimeMs)
        pub apiRecvTimeMs: i64,
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TimeInfo.apiSendToGoimMs)
        pub apiSendToGoimMs: i64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastMsgDetectMessage.TimeInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TimeInfo {
        fn default() -> &'a TimeInfo {
            <TimeInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl TimeInfo {
        pub fn new() -> TimeInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "clientStartMs",
                |m: &TimeInfo| { &m.clientStartMs },
                |m: &mut TimeInfo| { &mut m.clientStartMs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "apiRecvTimeMs",
                |m: &TimeInfo| { &m.apiRecvTimeMs },
                |m: &mut TimeInfo| { &mut m.apiRecvTimeMs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "apiSendToGoimMs",
                |m: &TimeInfo| { &m.apiSendToGoimMs },
                |m: &mut TimeInfo| { &mut m.apiSendToGoimMs },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeInfo>(
                "WebcastMsgDetectMessage.TimeInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TimeInfo {
        const NAME: &'static str = "TimeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.clientStartMs = is.read_int64()?;
                    },
                    16 => {
                        self.apiRecvTimeMs = is.read_int64()?;
                    },
                    24 => {
                        self.apiSendToGoimMs = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.clientStartMs != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.clientStartMs);
            }
            if self.apiRecvTimeMs != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.apiRecvTimeMs);
            }
            if self.apiSendToGoimMs != 0 {
                my_size += ::protobuf::rt::int64_size(3, self.apiSendToGoimMs);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.clientStartMs != 0 {
                os.write_int64(1, self.clientStartMs)?;
            }
            if self.apiRecvTimeMs != 0 {
                os.write_int64(2, self.apiRecvTimeMs)?;
            }
            if self.apiSendToGoimMs != 0 {
                os.write_int64(3, self.apiSendToGoimMs)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TimeInfo {
            TimeInfo::new()
        }

        fn clear(&mut self) {
            self.clientStartMs = 0;
            self.apiRecvTimeMs = 0;
            self.apiSendToGoimMs = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TimeInfo {
            static instance: TimeInfo = TimeInfo {
                clientStartMs: 0,
                apiRecvTimeMs: 0,
                apiSendToGoimMs: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TimeInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastMsgDetectMessage.TimeInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TimeInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TimeInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastMsgDetectMessage.TriggerCondition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TriggerCondition {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TriggerCondition.uplinkDetectHttp)
        pub uplinkDetectHttp: bool,
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TriggerCondition.uplinkDetectWebSocket)
        pub uplinkDetectWebSocket: bool,
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TriggerCondition.detectP2PMsg)
        pub detectP2PMsg: bool,
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TriggerCondition.detectRoomMsg)
        pub detectRoomMsg: bool,
        // @@protoc_insertion_point(field:TikTok.WebcastMsgDetectMessage.TriggerCondition.httpOptimize)
        pub httpOptimize: bool,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastMsgDetectMessage.TriggerCondition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TriggerCondition {
        fn default() -> &'a TriggerCondition {
            <TriggerCondition as ::protobuf::Message>::default_instance()
        }
    }

    impl TriggerCondition {
        pub fn new() -> TriggerCondition {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "uplinkDetectHttp",
                |m: &TriggerCondition| { &m.uplinkDetectHttp },
                |m: &mut TriggerCondition| { &mut m.uplinkDetectHttp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "uplinkDetectWebSocket",
                |m: &TriggerCondition| { &m.uplinkDetectWebSocket },
                |m: &mut TriggerCondition| { &mut m.uplinkDetectWebSocket },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "detectP2PMsg",
                |m: &TriggerCondition| { &m.detectP2PMsg },
                |m: &mut TriggerCondition| { &mut m.detectP2PMsg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "detectRoomMsg",
                |m: &TriggerCondition| { &m.detectRoomMsg },
                |m: &mut TriggerCondition| { &mut m.detectRoomMsg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "httpOptimize",
                |m: &TriggerCondition| { &m.httpOptimize },
                |m: &mut TriggerCondition| { &mut m.httpOptimize },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TriggerCondition>(
                "WebcastMsgDetectMessage.TriggerCondition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TriggerCondition {
        const NAME: &'static str = "TriggerCondition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.uplinkDetectHttp = is.read_bool()?;
                    },
                    16 => {
                        self.uplinkDetectWebSocket = is.read_bool()?;
                    },
                    24 => {
                        self.detectP2PMsg = is.read_bool()?;
                    },
                    32 => {
                        self.detectRoomMsg = is.read_bool()?;
                    },
                    40 => {
                        self.httpOptimize = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.uplinkDetectHttp != false {
                my_size += 1 + 1;
            }
            if self.uplinkDetectWebSocket != false {
                my_size += 1 + 1;
            }
            if self.detectP2PMsg != false {
                my_size += 1 + 1;
            }
            if self.detectRoomMsg != false {
                my_size += 1 + 1;
            }
            if self.httpOptimize != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.uplinkDetectHttp != false {
                os.write_bool(1, self.uplinkDetectHttp)?;
            }
            if self.uplinkDetectWebSocket != false {
                os.write_bool(2, self.uplinkDetectWebSocket)?;
            }
            if self.detectP2PMsg != false {
                os.write_bool(3, self.detectP2PMsg)?;
            }
            if self.detectRoomMsg != false {
                os.write_bool(4, self.detectRoomMsg)?;
            }
            if self.httpOptimize != false {
                os.write_bool(5, self.httpOptimize)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TriggerCondition {
            TriggerCondition::new()
        }

        fn clear(&mut self) {
            self.uplinkDetectHttp = false;
            self.uplinkDetectWebSocket = false;
            self.detectP2PMsg = false;
            self.detectRoomMsg = false;
            self.httpOptimize = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TriggerCondition {
            static instance: TriggerCondition = TriggerCondition {
                uplinkDetectHttp: false,
                uplinkDetectWebSocket: false,
                detectP2PMsg: false,
                detectRoomMsg: false,
                httpOptimize: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TriggerCondition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastMsgDetectMessage.TriggerCondition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TriggerCondition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TriggerCondition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastOecLiveShoppingMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastOecLiveShoppingMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.data1)
    pub data1: u32,
    // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.shopData)
    pub shopData: ::protobuf::MessageField<webcast_oec_live_shopping_message::LiveShoppingData>,
    // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.shopTimings)
    pub shopTimings: ::protobuf::MessageField<super::data::TimeStampContainer>,
    // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.details)
    pub details: ::protobuf::MessageField<webcast_oec_live_shopping_message::LiveShoppingDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastOecLiveShoppingMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastOecLiveShoppingMessage {
    fn default() -> &'a WebcastOecLiveShoppingMessage {
        <WebcastOecLiveShoppingMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastOecLiveShoppingMessage {
    pub fn new() -> WebcastOecLiveShoppingMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastOecLiveShoppingMessage| { &m.common },
            |m: &mut WebcastOecLiveShoppingMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data1",
            |m: &WebcastOecLiveShoppingMessage| { &m.data1 },
            |m: &mut WebcastOecLiveShoppingMessage| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_oec_live_shopping_message::LiveShoppingData>(
            "shopData",
            |m: &WebcastOecLiveShoppingMessage| { &m.shopData },
            |m: &mut WebcastOecLiveShoppingMessage| { &mut m.shopData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::TimeStampContainer>(
            "shopTimings",
            |m: &WebcastOecLiveShoppingMessage| { &m.shopTimings },
            |m: &mut WebcastOecLiveShoppingMessage| { &mut m.shopTimings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, webcast_oec_live_shopping_message::LiveShoppingDetails>(
            "details",
            |m: &WebcastOecLiveShoppingMessage| { &m.details },
            |m: &mut WebcastOecLiveShoppingMessage| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastOecLiveShoppingMessage>(
            "WebcastOecLiveShoppingMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastOecLiveShoppingMessage {
    const NAME: &'static str = "WebcastOecLiveShoppingMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.data1 = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shopData)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shopTimings)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.details)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.data1 != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.data1);
        }
        if let Some(v) = self.shopData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shopTimings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.data1 != 0 {
            os.write_uint32(2, self.data1)?;
        }
        if let Some(v) = self.shopData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.shopTimings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastOecLiveShoppingMessage {
        WebcastOecLiveShoppingMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.data1 = 0;
        self.shopData.clear();
        self.shopTimings.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastOecLiveShoppingMessage {
        static instance: WebcastOecLiveShoppingMessage = WebcastOecLiveShoppingMessage {
            common: ::protobuf::MessageField::none(),
            data1: 0,
            shopData: ::protobuf::MessageField::none(),
            shopTimings: ::protobuf::MessageField::none(),
            details: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastOecLiveShoppingMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastOecLiveShoppingMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastOecLiveShoppingMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastOecLiveShoppingMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebcastOecLiveShoppingMessage`
pub mod webcast_oec_live_shopping_message {
    // @@protoc_insertion_point(message:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LiveShoppingData {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.priceString)
        pub priceString: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.imageUrl)
        pub imageUrl: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.shopUrl)
        pub shopUrl: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.data1)
        pub data1: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.shopName)
        pub shopName: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.data2)
        pub data2: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.shopUrl2)
        pub shopUrl2: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.data3)
        pub data3: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.data4)
        pub data4: u64,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LiveShoppingData {
        fn default() -> &'a LiveShoppingData {
            <LiveShoppingData as ::protobuf::Message>::default_instance()
        }
    }

    impl LiveShoppingData {
        pub fn new() -> LiveShoppingData {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &LiveShoppingData| { &m.title },
                |m: &mut LiveShoppingData| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "priceString",
                |m: &LiveShoppingData| { &m.priceString },
                |m: &mut LiveShoppingData| { &mut m.priceString },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "imageUrl",
                |m: &LiveShoppingData| { &m.imageUrl },
                |m: &mut LiveShoppingData| { &mut m.imageUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "shopUrl",
                |m: &LiveShoppingData| { &m.shopUrl },
                |m: &mut LiveShoppingData| { &mut m.shopUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data1",
                |m: &LiveShoppingData| { &m.data1 },
                |m: &mut LiveShoppingData| { &mut m.data1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "shopName",
                |m: &LiveShoppingData| { &m.shopName },
                |m: &mut LiveShoppingData| { &mut m.shopName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data2",
                |m: &LiveShoppingData| { &m.data2 },
                |m: &mut LiveShoppingData| { &mut m.data2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "shopUrl2",
                |m: &LiveShoppingData| { &m.shopUrl2 },
                |m: &mut LiveShoppingData| { &mut m.shopUrl2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data3",
                |m: &LiveShoppingData| { &m.data3 },
                |m: &mut LiveShoppingData| { &mut m.data3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data4",
                |m: &LiveShoppingData| { &m.data4 },
                |m: &mut LiveShoppingData| { &mut m.data4 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveShoppingData>(
                "WebcastOecLiveShoppingMessage.LiveShoppingData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LiveShoppingData {
        const NAME: &'static str = "LiveShoppingData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.priceString = is.read_string()?;
                    },
                    26 => {
                        self.imageUrl = is.read_string()?;
                    },
                    34 => {
                        self.shopUrl = is.read_string()?;
                    },
                    48 => {
                        self.data1 = is.read_uint64()?;
                    },
                    58 => {
                        self.shopName = is.read_string()?;
                    },
                    64 => {
                        self.data2 = is.read_uint64()?;
                    },
                    74 => {
                        self.shopUrl2 = is.read_string()?;
                    },
                    80 => {
                        self.data3 = is.read_uint64()?;
                    },
                    88 => {
                        self.data4 = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.priceString.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.priceString);
            }
            if !self.imageUrl.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.imageUrl);
            }
            if !self.shopUrl.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.shopUrl);
            }
            if self.data1 != 0 {
                my_size += ::protobuf::rt::uint64_size(6, self.data1);
            }
            if !self.shopName.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.shopName);
            }
            if self.data2 != 0 {
                my_size += ::protobuf::rt::uint64_size(8, self.data2);
            }
            if !self.shopUrl2.is_empty() {
                my_size += ::protobuf::rt::string_size(9, &self.shopUrl2);
            }
            if self.data3 != 0 {
                my_size += ::protobuf::rt::uint64_size(10, self.data3);
            }
            if self.data4 != 0 {
                my_size += ::protobuf::rt::uint64_size(11, self.data4);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.priceString.is_empty() {
                os.write_string(2, &self.priceString)?;
            }
            if !self.imageUrl.is_empty() {
                os.write_string(3, &self.imageUrl)?;
            }
            if !self.shopUrl.is_empty() {
                os.write_string(4, &self.shopUrl)?;
            }
            if self.data1 != 0 {
                os.write_uint64(6, self.data1)?;
            }
            if !self.shopName.is_empty() {
                os.write_string(7, &self.shopName)?;
            }
            if self.data2 != 0 {
                os.write_uint64(8, self.data2)?;
            }
            if !self.shopUrl2.is_empty() {
                os.write_string(9, &self.shopUrl2)?;
            }
            if self.data3 != 0 {
                os.write_uint64(10, self.data3)?;
            }
            if self.data4 != 0 {
                os.write_uint64(11, self.data4)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LiveShoppingData {
            LiveShoppingData::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.priceString.clear();
            self.imageUrl.clear();
            self.shopUrl.clear();
            self.data1 = 0;
            self.shopName.clear();
            self.data2 = 0;
            self.shopUrl2.clear();
            self.data3 = 0;
            self.data4 = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LiveShoppingData {
            static instance: LiveShoppingData = LiveShoppingData {
                title: ::std::string::String::new(),
                priceString: ::std::string::String::new(),
                imageUrl: ::std::string::String::new(),
                shopUrl: ::std::string::String::new(),
                data1: 0,
                shopName: ::std::string::String::new(),
                data2: 0,
                shopUrl2: ::std::string::String::new(),
                data3: 0,
                data4: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LiveShoppingData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastOecLiveShoppingMessage.LiveShoppingData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LiveShoppingData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiveShoppingData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LiveShoppingDetails {
        // message fields
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDetails.id1)
        pub id1: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDetails.data1)
        pub data1: ::std::string::String,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDetails.data2)
        pub data2: u32,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDetails.timestamp)
        pub timestamp: u64,
        // @@protoc_insertion_point(field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDetails.data)
        pub data: ::protobuf::MessageField<super::super::data::ValueLabel>,
        // special fields
        // @@protoc_insertion_point(special_field:TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LiveShoppingDetails {
        fn default() -> &'a LiveShoppingDetails {
            <LiveShoppingDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl LiveShoppingDetails {
        pub fn new() -> LiveShoppingDetails {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id1",
                |m: &LiveShoppingDetails| { &m.id1 },
                |m: &mut LiveShoppingDetails| { &mut m.id1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data1",
                |m: &LiveShoppingDetails| { &m.data1 },
                |m: &mut LiveShoppingDetails| { &mut m.data1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data2",
                |m: &LiveShoppingDetails| { &m.data2 },
                |m: &mut LiveShoppingDetails| { &mut m.data2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "timestamp",
                |m: &LiveShoppingDetails| { &m.timestamp },
                |m: &mut LiveShoppingDetails| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::data::ValueLabel>(
                "data",
                |m: &LiveShoppingDetails| { &m.data },
                |m: &mut LiveShoppingDetails| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveShoppingDetails>(
                "WebcastOecLiveShoppingMessage.LiveShoppingDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LiveShoppingDetails {
        const NAME: &'static str = "LiveShoppingDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id1 = is.read_string()?;
                    },
                    26 => {
                        self.data1 = is.read_string()?;
                    },
                    32 => {
                        self.data2 = is.read_uint32()?;
                    },
                    40 => {
                        self.timestamp = is.read_uint64()?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id1.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id1);
            }
            if !self.data1.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.data1);
            }
            if self.data2 != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.data2);
            }
            if self.timestamp != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.timestamp);
            }
            if let Some(v) = self.data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.id1.is_empty() {
                os.write_string(1, &self.id1)?;
            }
            if !self.data1.is_empty() {
                os.write_string(3, &self.data1)?;
            }
            if self.data2 != 0 {
                os.write_uint32(4, self.data2)?;
            }
            if self.timestamp != 0 {
                os.write_uint64(5, self.timestamp)?;
            }
            if let Some(v) = self.data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LiveShoppingDetails {
            LiveShoppingDetails::new()
        }

        fn clear(&mut self) {
            self.id1.clear();
            self.data1.clear();
            self.data2 = 0;
            self.timestamp = 0;
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LiveShoppingDetails {
            static instance: LiveShoppingDetails = LiveShoppingDetails {
                id1: ::std::string::String::new(),
                data1: ::std::string::String::new(),
                data2: 0,
                timestamp: 0,
                data: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LiveShoppingDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WebcastOecLiveShoppingMessage.LiveShoppingDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LiveShoppingDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LiveShoppingDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:TikTok.WebcastRoomPinMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastRoomPinMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastRoomPinMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomPinMessage.pinnedMessage)
    pub pinnedMessage: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomPinMessage.originalMsgType)
    pub originalMsgType: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastRoomPinMessage.timestamp)
    pub timestamp: u64,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastRoomPinMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastRoomPinMessage {
    fn default() -> &'a WebcastRoomPinMessage {
        <WebcastRoomPinMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastRoomPinMessage {
    pub fn new() -> WebcastRoomPinMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastRoomPinMessage| { &m.common },
            |m: &mut WebcastRoomPinMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pinnedMessage",
            |m: &WebcastRoomPinMessage| { &m.pinnedMessage },
            |m: &mut WebcastRoomPinMessage| { &mut m.pinnedMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "originalMsgType",
            |m: &WebcastRoomPinMessage| { &m.originalMsgType },
            |m: &mut WebcastRoomPinMessage| { &mut m.originalMsgType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &WebcastRoomPinMessage| { &m.timestamp },
            |m: &mut WebcastRoomPinMessage| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastRoomPinMessage>(
            "WebcastRoomPinMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastRoomPinMessage {
    const NAME: &'static str = "WebcastRoomPinMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    self.pinnedMessage = is.read_bytes()?;
                },
                242 => {
                    self.originalMsgType = is.read_string()?;
                },
                248 => {
                    self.timestamp = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.pinnedMessage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pinnedMessage);
        }
        if !self.originalMsgType.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.originalMsgType);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(31, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.pinnedMessage.is_empty() {
            os.write_bytes(2, &self.pinnedMessage)?;
        }
        if !self.originalMsgType.is_empty() {
            os.write_string(30, &self.originalMsgType)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(31, self.timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastRoomPinMessage {
        WebcastRoomPinMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.pinnedMessage.clear();
        self.originalMsgType.clear();
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastRoomPinMessage {
        static instance: WebcastRoomPinMessage = WebcastRoomPinMessage {
            common: ::protobuf::MessageField::none(),
            pinnedMessage: ::std::vec::Vec::new(),
            originalMsgType: ::std::string::String::new(),
            timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastRoomPinMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastRoomPinMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastRoomPinMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastRoomPinMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastSystemMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastSystemMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastSystemMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastSystemMessage.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastSystemMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastSystemMessage {
    fn default() -> &'a WebcastSystemMessage {
        <WebcastSystemMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastSystemMessage {
    pub fn new() -> WebcastSystemMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastSystemMessage| { &m.common },
            |m: &mut WebcastSystemMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &WebcastSystemMessage| { &m.message },
            |m: &mut WebcastSystemMessage| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastSystemMessage>(
            "WebcastSystemMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastSystemMessage {
    const NAME: &'static str = "WebcastSystemMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastSystemMessage {
        WebcastSystemMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastSystemMessage {
        static instance: WebcastSystemMessage = WebcastSystemMessage {
            common: ::protobuf::MessageField::none(),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastSystemMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastSystemMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastSystemMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastSystemMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.MessageType)
    pub MessageType: ::protobuf::EnumOrUnknown<super::enums::LinkMessageType>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.LinkerId)
    pub LinkerId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.Scene)
    pub Scene: ::protobuf::EnumOrUnknown<super::enums::Scene>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.InviteContent)
    pub InviteContent: ::protobuf::MessageField<super::data::LinkerInviteContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.ReplyContent)
    pub ReplyContent: ::protobuf::MessageField<super::data::LinkerReplyContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.CreateContent)
    pub CreateContent: ::protobuf::MessageField<super::data::LinkerCreateContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.CloseContent)
    pub CloseContent: ::protobuf::MessageField<super::data::LinkerCloseContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.EnterContent)
    pub EnterContent: ::protobuf::MessageField<super::data::LinkerEnterContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.LeaveContent)
    pub LeaveContent: ::protobuf::MessageField<super::data::LinkerLeaveContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.CancelContent)
    pub CancelContent: ::protobuf::MessageField<super::data::LinkerCancelContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.KickOutContent)
    pub KickOutContent: ::protobuf::MessageField<super::data::LinkerKickOutContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.LinkedListChangeContent)
    pub LinkedListChangeContent: ::protobuf::MessageField<super::data::LinkerLinkedListChangeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.UpdateUserContent)
    pub UpdateUserContent: ::protobuf::MessageField<super::data::LinkerUpdateUserContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.WaitingListChangeContent)
    pub WaitingListChangeContent: ::protobuf::MessageField<super::data::LinkerWaitingListChangeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.MuteContent)
    pub MuteContent: ::protobuf::MessageField<super::data::LinkerMuteContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.RandomMatchContent)
    pub RandomMatchContent: ::protobuf::MessageField<super::data::LinkerRandomMatchContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.UpdateUserSettingContent)
    pub UpdateUserSettingContent: ::protobuf::MessageField<super::data::LinkerUpdateUserSettingContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.MicIdxUpdateContent)
    pub MicIdxUpdateContent: ::protobuf::MessageField<super::data::LinkerMicIdxUpdateContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.ListChangeContent)
    pub ListChangeContent: ::protobuf::MessageField<super::data::LinkerListChangeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.CohostListChangeContent)
    pub CohostListChangeContent: ::protobuf::MessageField<super::data::CohostListChangeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.MediaChangeContent)
    pub MediaChangeContent: ::protobuf::MessageField<super::data::LinkerMediaChangeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.ReplyAcceptNoticeContent)
    pub ReplyAcceptNoticeContent: ::protobuf::MessageField<super::data::LinkerAcceptNoticeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.SysKickOutContent)
    pub SysKickOutContent: ::protobuf::MessageField<super::data::LinkerSysKickOutContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.UserToastContent)
    pub UserToastContent: ::protobuf::MessageField<super::data::LinkmicUserToastContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.extra)
    pub extra: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.expireTimestamp)
    pub expireTimestamp: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkMessage.transferExtra)
    pub transferExtra: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkMessage {
    fn default() -> &'a WebcastLinkMessage {
        <WebcastLinkMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkMessage {
    pub fn new() -> WebcastLinkMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLinkMessage| { &m.common },
            |m: &mut WebcastLinkMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MessageType",
            |m: &WebcastLinkMessage| { &m.MessageType },
            |m: &mut WebcastLinkMessage| { &mut m.MessageType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LinkerId",
            |m: &WebcastLinkMessage| { &m.LinkerId },
            |m: &mut WebcastLinkMessage| { &mut m.LinkerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Scene",
            |m: &WebcastLinkMessage| { &m.Scene },
            |m: &mut WebcastLinkMessage| { &mut m.Scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerInviteContent>(
            "InviteContent",
            |m: &WebcastLinkMessage| { &m.InviteContent },
            |m: &mut WebcastLinkMessage| { &mut m.InviteContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerReplyContent>(
            "ReplyContent",
            |m: &WebcastLinkMessage| { &m.ReplyContent },
            |m: &mut WebcastLinkMessage| { &mut m.ReplyContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerCreateContent>(
            "CreateContent",
            |m: &WebcastLinkMessage| { &m.CreateContent },
            |m: &mut WebcastLinkMessage| { &mut m.CreateContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerCloseContent>(
            "CloseContent",
            |m: &WebcastLinkMessage| { &m.CloseContent },
            |m: &mut WebcastLinkMessage| { &mut m.CloseContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerEnterContent>(
            "EnterContent",
            |m: &WebcastLinkMessage| { &m.EnterContent },
            |m: &mut WebcastLinkMessage| { &mut m.EnterContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerLeaveContent>(
            "LeaveContent",
            |m: &WebcastLinkMessage| { &m.LeaveContent },
            |m: &mut WebcastLinkMessage| { &mut m.LeaveContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerCancelContent>(
            "CancelContent",
            |m: &WebcastLinkMessage| { &m.CancelContent },
            |m: &mut WebcastLinkMessage| { &mut m.CancelContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerKickOutContent>(
            "KickOutContent",
            |m: &WebcastLinkMessage| { &m.KickOutContent },
            |m: &mut WebcastLinkMessage| { &mut m.KickOutContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerLinkedListChangeContent>(
            "LinkedListChangeContent",
            |m: &WebcastLinkMessage| { &m.LinkedListChangeContent },
            |m: &mut WebcastLinkMessage| { &mut m.LinkedListChangeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerUpdateUserContent>(
            "UpdateUserContent",
            |m: &WebcastLinkMessage| { &m.UpdateUserContent },
            |m: &mut WebcastLinkMessage| { &mut m.UpdateUserContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerWaitingListChangeContent>(
            "WaitingListChangeContent",
            |m: &WebcastLinkMessage| { &m.WaitingListChangeContent },
            |m: &mut WebcastLinkMessage| { &mut m.WaitingListChangeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerMuteContent>(
            "MuteContent",
            |m: &WebcastLinkMessage| { &m.MuteContent },
            |m: &mut WebcastLinkMessage| { &mut m.MuteContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerRandomMatchContent>(
            "RandomMatchContent",
            |m: &WebcastLinkMessage| { &m.RandomMatchContent },
            |m: &mut WebcastLinkMessage| { &mut m.RandomMatchContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerUpdateUserSettingContent>(
            "UpdateUserSettingContent",
            |m: &WebcastLinkMessage| { &m.UpdateUserSettingContent },
            |m: &mut WebcastLinkMessage| { &mut m.UpdateUserSettingContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerMicIdxUpdateContent>(
            "MicIdxUpdateContent",
            |m: &WebcastLinkMessage| { &m.MicIdxUpdateContent },
            |m: &mut WebcastLinkMessage| { &mut m.MicIdxUpdateContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerListChangeContent>(
            "ListChangeContent",
            |m: &WebcastLinkMessage| { &m.ListChangeContent },
            |m: &mut WebcastLinkMessage| { &mut m.ListChangeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::CohostListChangeContent>(
            "CohostListChangeContent",
            |m: &WebcastLinkMessage| { &m.CohostListChangeContent },
            |m: &mut WebcastLinkMessage| { &mut m.CohostListChangeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerMediaChangeContent>(
            "MediaChangeContent",
            |m: &WebcastLinkMessage| { &m.MediaChangeContent },
            |m: &mut WebcastLinkMessage| { &mut m.MediaChangeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerAcceptNoticeContent>(
            "ReplyAcceptNoticeContent",
            |m: &WebcastLinkMessage| { &m.ReplyAcceptNoticeContent },
            |m: &mut WebcastLinkMessage| { &mut m.ReplyAcceptNoticeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkerSysKickOutContent>(
            "SysKickOutContent",
            |m: &WebcastLinkMessage| { &m.SysKickOutContent },
            |m: &mut WebcastLinkMessage| { &mut m.SysKickOutContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LinkmicUserToastContent>(
            "UserToastContent",
            |m: &WebcastLinkMessage| { &m.UserToastContent },
            |m: &mut WebcastLinkMessage| { &mut m.UserToastContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra",
            |m: &WebcastLinkMessage| { &m.extra },
            |m: &mut WebcastLinkMessage| { &mut m.extra },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expireTimestamp",
            |m: &WebcastLinkMessage| { &m.expireTimestamp },
            |m: &mut WebcastLinkMessage| { &mut m.expireTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transferExtra",
            |m: &WebcastLinkMessage| { &m.transferExtra },
            |m: &mut WebcastLinkMessage| { &mut m.transferExtra },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkMessage>(
            "WebcastLinkMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkMessage {
    const NAME: &'static str = "WebcastLinkMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.MessageType = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.LinkerId = is.read_int64()?;
                },
                32 => {
                    self.Scene = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.InviteContent)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ReplyContent)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.CreateContent)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.CloseContent)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.EnterContent)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.LeaveContent)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.CancelContent)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.KickOutContent)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.LinkedListChangeContent)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.UpdateUserContent)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.WaitingListChangeContent)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.MuteContent)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.RandomMatchContent)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.UpdateUserSettingContent)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.MicIdxUpdateContent)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ListChangeContent)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.CohostListChangeContent)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.MediaChangeContent)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ReplyAcceptNoticeContent)?;
                },
                810 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.SysKickOutContent)?;
                },
                818 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.UserToastContent)?;
                },
                1602 => {
                    self.extra = is.read_string()?;
                },
                1608 => {
                    self.expireTimestamp = is.read_int64()?;
                },
                1618 => {
                    self.transferExtra = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.MessageType != ::protobuf::EnumOrUnknown::new(super::enums::LinkMessageType::TPYE_LINKER_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.MessageType.value());
        }
        if self.LinkerId != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.LinkerId);
        }
        if self.Scene != ::protobuf::EnumOrUnknown::new(super::enums::Scene::SCENE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.Scene.value());
        }
        if let Some(v) = self.InviteContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ReplyContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.CreateContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.CloseContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.EnterContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.LeaveContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.CancelContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.KickOutContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.LinkedListChangeContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.UpdateUserContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.WaitingListChangeContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.MuteContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.RandomMatchContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.UpdateUserSettingContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.MicIdxUpdateContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ListChangeContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.CohostListChangeContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.MediaChangeContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ReplyAcceptNoticeContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.SysKickOutContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.UserToastContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.extra.is_empty() {
            my_size += ::protobuf::rt::string_size(200, &self.extra);
        }
        if self.expireTimestamp != 0 {
            my_size += ::protobuf::rt::int64_size(201, self.expireTimestamp);
        }
        if !self.transferExtra.is_empty() {
            my_size += ::protobuf::rt::string_size(202, &self.transferExtra);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.MessageType != ::protobuf::EnumOrUnknown::new(super::enums::LinkMessageType::TPYE_LINKER_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.MessageType))?;
        }
        if self.LinkerId != 0 {
            os.write_int64(3, self.LinkerId)?;
        }
        if self.Scene != ::protobuf::EnumOrUnknown::new(super::enums::Scene::SCENE_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.Scene))?;
        }
        if let Some(v) = self.InviteContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.ReplyContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.CreateContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.CloseContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.EnterContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.LeaveContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.CancelContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.KickOutContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.LinkedListChangeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.UpdateUserContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.WaitingListChangeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.MuteContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.RandomMatchContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.UpdateUserSettingContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.MicIdxUpdateContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.ListChangeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.CohostListChangeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.MediaChangeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.ReplyAcceptNoticeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.SysKickOutContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(101, v, os)?;
        }
        if let Some(v) = self.UserToastContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(102, v, os)?;
        }
        if !self.extra.is_empty() {
            os.write_string(200, &self.extra)?;
        }
        if self.expireTimestamp != 0 {
            os.write_int64(201, self.expireTimestamp)?;
        }
        if !self.transferExtra.is_empty() {
            os.write_string(202, &self.transferExtra)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkMessage {
        WebcastLinkMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.MessageType = ::protobuf::EnumOrUnknown::new(super::enums::LinkMessageType::TPYE_LINKER_UNKNOWN);
        self.LinkerId = 0;
        self.Scene = ::protobuf::EnumOrUnknown::new(super::enums::Scene::SCENE_UNKNOWN);
        self.InviteContent.clear();
        self.ReplyContent.clear();
        self.CreateContent.clear();
        self.CloseContent.clear();
        self.EnterContent.clear();
        self.LeaveContent.clear();
        self.CancelContent.clear();
        self.KickOutContent.clear();
        self.LinkedListChangeContent.clear();
        self.UpdateUserContent.clear();
        self.WaitingListChangeContent.clear();
        self.MuteContent.clear();
        self.RandomMatchContent.clear();
        self.UpdateUserSettingContent.clear();
        self.MicIdxUpdateContent.clear();
        self.ListChangeContent.clear();
        self.CohostListChangeContent.clear();
        self.MediaChangeContent.clear();
        self.ReplyAcceptNoticeContent.clear();
        self.SysKickOutContent.clear();
        self.UserToastContent.clear();
        self.extra.clear();
        self.expireTimestamp = 0;
        self.transferExtra.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkMessage {
        static instance: WebcastLinkMessage = WebcastLinkMessage {
            common: ::protobuf::MessageField::none(),
            MessageType: ::protobuf::EnumOrUnknown::from_i32(0),
            LinkerId: 0,
            Scene: ::protobuf::EnumOrUnknown::from_i32(0),
            InviteContent: ::protobuf::MessageField::none(),
            ReplyContent: ::protobuf::MessageField::none(),
            CreateContent: ::protobuf::MessageField::none(),
            CloseContent: ::protobuf::MessageField::none(),
            EnterContent: ::protobuf::MessageField::none(),
            LeaveContent: ::protobuf::MessageField::none(),
            CancelContent: ::protobuf::MessageField::none(),
            KickOutContent: ::protobuf::MessageField::none(),
            LinkedListChangeContent: ::protobuf::MessageField::none(),
            UpdateUserContent: ::protobuf::MessageField::none(),
            WaitingListChangeContent: ::protobuf::MessageField::none(),
            MuteContent: ::protobuf::MessageField::none(),
            RandomMatchContent: ::protobuf::MessageField::none(),
            UpdateUserSettingContent: ::protobuf::MessageField::none(),
            MicIdxUpdateContent: ::protobuf::MessageField::none(),
            ListChangeContent: ::protobuf::MessageField::none(),
            CohostListChangeContent: ::protobuf::MessageField::none(),
            MediaChangeContent: ::protobuf::MessageField::none(),
            ReplyAcceptNoticeContent: ::protobuf::MessageField::none(),
            SysKickOutContent: ::protobuf::MessageField::none(),
            UserToastContent: ::protobuf::MessageField::none(),
            extra: ::std::string::String::new(),
            expireTimestamp: 0,
            transferExtra: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.WebcastLinkLayerMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebcastLinkLayerMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.messageType)
    pub messageType: ::protobuf::EnumOrUnknown<super::enums::MessageType>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.channelId)
    pub channelId: i64,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.scene)
    pub scene: ::protobuf::EnumOrUnknown<super::enums::Scene>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.createChannelContent)
    pub createChannelContent: ::protobuf::MessageField<super::data::CreateChannelContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.listChangeContent)
    pub listChangeContent: ::protobuf::MessageField<super::data::ListChangeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.inviteContent)
    pub inviteContent: ::protobuf::MessageField<super::data::InviteContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.applyContent)
    pub applyContent: ::protobuf::MessageField<super::data::ApplyContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.permitApplyContent)
    pub permitApplyContent: ::protobuf::MessageField<super::data::PermitApplyContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.replyInviteContent)
    pub replyInviteContent: ::protobuf::MessageField<super::data::ReplyInviteContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.kickOutContent)
    pub kickOutContent: ::protobuf::MessageField<super::data::KickOutContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.cancelApplyContent)
    pub cancelApplyContent: ::protobuf::MessageField<super::data::CancelApplyContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.cancelInviteContent)
    pub cancelInviteContent: ::protobuf::MessageField<super::data::CancelInviteContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.leaveContent)
    pub leaveContent: ::protobuf::MessageField<super::data::LeaveContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.finishContent)
    pub finishContent: ::protobuf::MessageField<super::data::FinishChannelContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.joinDirectContent)
    pub joinDirectContent: ::protobuf::MessageField<super::data::JoinDirectContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.joinGroupContent)
    pub joinGroupContent: ::protobuf::MessageField<super::data::JoinGroupContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.permitGroupContent)
    pub permitGroupContent: ::protobuf::MessageField<super::data::PermitJoinGroupContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.cancelGroupContent)
    pub cancelGroupContent: ::protobuf::MessageField<super::data::CancelJoinGroupContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.leaveGroupContent)
    pub leaveGroupContent: ::protobuf::MessageField<super::data::LeaveJoinGroupContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.p2pGroupChangeContent)
    pub p2pGroupChangeContent: ::protobuf::MessageField<super::data::P2PGroupChangeContent>,
    // @@protoc_insertion_point(field:TikTok.WebcastLinkLayerMessage.businessContent)
    pub businessContent: ::protobuf::MessageField<super::data::BusinessContent>,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.WebcastLinkLayerMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebcastLinkLayerMessage {
    fn default() -> &'a WebcastLinkLayerMessage {
        <WebcastLinkLayerMessage as ::protobuf::Message>::default_instance()
    }
}

impl WebcastLinkLayerMessage {
    pub fn new() -> WebcastLinkLayerMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &WebcastLinkLayerMessage| { &m.common },
            |m: &mut WebcastLinkLayerMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "messageType",
            |m: &WebcastLinkLayerMessage| { &m.messageType },
            |m: &mut WebcastLinkLayerMessage| { &mut m.messageType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channelId",
            |m: &WebcastLinkLayerMessage| { &m.channelId },
            |m: &mut WebcastLinkLayerMessage| { &mut m.channelId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scene",
            |m: &WebcastLinkLayerMessage| { &m.scene },
            |m: &mut WebcastLinkLayerMessage| { &mut m.scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::CreateChannelContent>(
            "createChannelContent",
            |m: &WebcastLinkLayerMessage| { &m.createChannelContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.createChannelContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::ListChangeContent>(
            "listChangeContent",
            |m: &WebcastLinkLayerMessage| { &m.listChangeContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.listChangeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::InviteContent>(
            "inviteContent",
            |m: &WebcastLinkLayerMessage| { &m.inviteContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.inviteContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::ApplyContent>(
            "applyContent",
            |m: &WebcastLinkLayerMessage| { &m.applyContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.applyContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::PermitApplyContent>(
            "permitApplyContent",
            |m: &WebcastLinkLayerMessage| { &m.permitApplyContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.permitApplyContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::ReplyInviteContent>(
            "replyInviteContent",
            |m: &WebcastLinkLayerMessage| { &m.replyInviteContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.replyInviteContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::KickOutContent>(
            "kickOutContent",
            |m: &WebcastLinkLayerMessage| { &m.kickOutContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.kickOutContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::CancelApplyContent>(
            "cancelApplyContent",
            |m: &WebcastLinkLayerMessage| { &m.cancelApplyContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.cancelApplyContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::CancelInviteContent>(
            "cancelInviteContent",
            |m: &WebcastLinkLayerMessage| { &m.cancelInviteContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.cancelInviteContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LeaveContent>(
            "leaveContent",
            |m: &WebcastLinkLayerMessage| { &m.leaveContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.leaveContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::FinishChannelContent>(
            "finishContent",
            |m: &WebcastLinkLayerMessage| { &m.finishContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.finishContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::JoinDirectContent>(
            "joinDirectContent",
            |m: &WebcastLinkLayerMessage| { &m.joinDirectContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.joinDirectContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::JoinGroupContent>(
            "joinGroupContent",
            |m: &WebcastLinkLayerMessage| { &m.joinGroupContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.joinGroupContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::PermitJoinGroupContent>(
            "permitGroupContent",
            |m: &WebcastLinkLayerMessage| { &m.permitGroupContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.permitGroupContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::CancelJoinGroupContent>(
            "cancelGroupContent",
            |m: &WebcastLinkLayerMessage| { &m.cancelGroupContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.cancelGroupContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::LeaveJoinGroupContent>(
            "leaveGroupContent",
            |m: &WebcastLinkLayerMessage| { &m.leaveGroupContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.leaveGroupContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::P2PGroupChangeContent>(
            "p2pGroupChangeContent",
            |m: &WebcastLinkLayerMessage| { &m.p2pGroupChangeContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.p2pGroupChangeContent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::BusinessContent>(
            "businessContent",
            |m: &WebcastLinkLayerMessage| { &m.businessContent },
            |m: &mut WebcastLinkLayerMessage| { &mut m.businessContent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebcastLinkLayerMessage>(
            "WebcastLinkLayerMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebcastLinkLayerMessage {
    const NAME: &'static str = "WebcastLinkLayerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.messageType = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.channelId = is.read_int64()?;
                },
                32 => {
                    self.scene = is.read_enum_or_unknown()?;
                },
                802 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.createChannelContent)?;
                },
                818 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.listChangeContent)?;
                },
                826 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inviteContent)?;
                },
                834 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.applyContent)?;
                },
                842 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permitApplyContent)?;
                },
                850 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.replyInviteContent)?;
                },
                858 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kickOutContent)?;
                },
                866 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cancelApplyContent)?;
                },
                874 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cancelInviteContent)?;
                },
                882 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leaveContent)?;
                },
                890 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.finishContent)?;
                },
                898 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.joinDirectContent)?;
                },
                906 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.joinGroupContent)?;
                },
                914 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permitGroupContent)?;
                },
                922 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cancelGroupContent)?;
                },
                930 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leaveGroupContent)?;
                },
                938 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p2pGroupChangeContent)?;
                },
                1602 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.businessContent)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.messageType != ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS) {
            my_size += ::protobuf::rt::int32_size(2, self.messageType.value());
        }
        if self.channelId != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.channelId);
        }
        if self.scene != ::protobuf::EnumOrUnknown::new(super::enums::Scene::SCENE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.scene.value());
        }
        if let Some(v) = self.createChannelContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.listChangeContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inviteContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.applyContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.permitApplyContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.replyInviteContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.kickOutContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cancelApplyContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cancelInviteContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.leaveContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.finishContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.joinDirectContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.joinGroupContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.permitGroupContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cancelGroupContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.leaveGroupContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.p2pGroupChangeContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.businessContent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.messageType != ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.messageType))?;
        }
        if self.channelId != 0 {
            os.write_int64(3, self.channelId)?;
        }
        if self.scene != ::protobuf::EnumOrUnknown::new(super::enums::Scene::SCENE_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.scene))?;
        }
        if let Some(v) = self.createChannelContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
        }
        if let Some(v) = self.listChangeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(102, v, os)?;
        }
        if let Some(v) = self.inviteContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(103, v, os)?;
        }
        if let Some(v) = self.applyContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(104, v, os)?;
        }
        if let Some(v) = self.permitApplyContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(105, v, os)?;
        }
        if let Some(v) = self.replyInviteContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(106, v, os)?;
        }
        if let Some(v) = self.kickOutContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(107, v, os)?;
        }
        if let Some(v) = self.cancelApplyContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(108, v, os)?;
        }
        if let Some(v) = self.cancelInviteContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(109, v, os)?;
        }
        if let Some(v) = self.leaveContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(110, v, os)?;
        }
        if let Some(v) = self.finishContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(111, v, os)?;
        }
        if let Some(v) = self.joinDirectContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(112, v, os)?;
        }
        if let Some(v) = self.joinGroupContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(113, v, os)?;
        }
        if let Some(v) = self.permitGroupContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(114, v, os)?;
        }
        if let Some(v) = self.cancelGroupContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(115, v, os)?;
        }
        if let Some(v) = self.leaveGroupContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(116, v, os)?;
        }
        if let Some(v) = self.p2pGroupChangeContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(117, v, os)?;
        }
        if let Some(v) = self.businessContent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(200, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebcastLinkLayerMessage {
        WebcastLinkLayerMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.messageType = ::protobuf::EnumOrUnknown::new(super::enums::MessageType::MESSAGETYPE_SUBSUCCESS);
        self.channelId = 0;
        self.scene = ::protobuf::EnumOrUnknown::new(super::enums::Scene::SCENE_UNKNOWN);
        self.createChannelContent.clear();
        self.listChangeContent.clear();
        self.inviteContent.clear();
        self.applyContent.clear();
        self.permitApplyContent.clear();
        self.replyInviteContent.clear();
        self.kickOutContent.clear();
        self.cancelApplyContent.clear();
        self.cancelInviteContent.clear();
        self.leaveContent.clear();
        self.finishContent.clear();
        self.joinDirectContent.clear();
        self.joinGroupContent.clear();
        self.permitGroupContent.clear();
        self.cancelGroupContent.clear();
        self.leaveGroupContent.clear();
        self.p2pGroupChangeContent.clear();
        self.businessContent.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebcastLinkLayerMessage {
        static instance: WebcastLinkLayerMessage = WebcastLinkLayerMessage {
            common: ::protobuf::MessageField::none(),
            messageType: ::protobuf::EnumOrUnknown::from_i32(0),
            channelId: 0,
            scene: ::protobuf::EnumOrUnknown::from_i32(0),
            createChannelContent: ::protobuf::MessageField::none(),
            listChangeContent: ::protobuf::MessageField::none(),
            inviteContent: ::protobuf::MessageField::none(),
            applyContent: ::protobuf::MessageField::none(),
            permitApplyContent: ::protobuf::MessageField::none(),
            replyInviteContent: ::protobuf::MessageField::none(),
            kickOutContent: ::protobuf::MessageField::none(),
            cancelApplyContent: ::protobuf::MessageField::none(),
            cancelInviteContent: ::protobuf::MessageField::none(),
            leaveContent: ::protobuf::MessageField::none(),
            finishContent: ::protobuf::MessageField::none(),
            joinDirectContent: ::protobuf::MessageField::none(),
            joinGroupContent: ::protobuf::MessageField::none(),
            permitGroupContent: ::protobuf::MessageField::none(),
            cancelGroupContent: ::protobuf::MessageField::none(),
            leaveGroupContent: ::protobuf::MessageField::none(),
            p2pGroupChangeContent: ::protobuf::MessageField::none(),
            businessContent: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebcastLinkLayerMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebcastLinkLayerMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebcastLinkLayerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebcastLinkLayerMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TikTok.RoomVerifyMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RoomVerifyMessage {
    // message fields
    // @@protoc_insertion_point(field:TikTok.RoomVerifyMessage.common)
    pub common: ::protobuf::MessageField<super::data::Common>,
    // @@protoc_insertion_point(field:TikTok.RoomVerifyMessage.action)
    pub action: i32,
    // @@protoc_insertion_point(field:TikTok.RoomVerifyMessage.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:TikTok.RoomVerifyMessage.noticeType)
    pub noticeType: i64,
    // @@protoc_insertion_point(field:TikTok.RoomVerifyMessage.closeRoom)
    pub closeRoom: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TikTok.RoomVerifyMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoomVerifyMessage {
    fn default() -> &'a RoomVerifyMessage {
        <RoomVerifyMessage as ::protobuf::Message>::default_instance()
    }
}

impl RoomVerifyMessage {
    pub fn new() -> RoomVerifyMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::data::Common>(
            "common",
            |m: &RoomVerifyMessage| { &m.common },
            |m: &mut RoomVerifyMessage| { &mut m.common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &RoomVerifyMessage| { &m.action },
            |m: &mut RoomVerifyMessage| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &RoomVerifyMessage| { &m.content },
            |m: &mut RoomVerifyMessage| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noticeType",
            |m: &RoomVerifyMessage| { &m.noticeType },
            |m: &mut RoomVerifyMessage| { &mut m.noticeType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "closeRoom",
            |m: &RoomVerifyMessage| { &m.closeRoom },
            |m: &mut RoomVerifyMessage| { &mut m.closeRoom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoomVerifyMessage>(
            "RoomVerifyMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoomVerifyMessage {
    const NAME: &'static str = "RoomVerifyMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common)?;
                },
                16 => {
                    self.action = is.read_int32()?;
                },
                26 => {
                    self.content = is.read_string()?;
                },
                32 => {
                    self.noticeType = is.read_int64()?;
                },
                40 => {
                    self.closeRoom = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.action != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.action);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.content);
        }
        if self.noticeType != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.noticeType);
        }
        if self.closeRoom != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.action != 0 {
            os.write_int32(2, self.action)?;
        }
        if !self.content.is_empty() {
            os.write_string(3, &self.content)?;
        }
        if self.noticeType != 0 {
            os.write_int64(4, self.noticeType)?;
        }
        if self.closeRoom != false {
            os.write_bool(5, self.closeRoom)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoomVerifyMessage {
        RoomVerifyMessage::new()
    }

    fn clear(&mut self) {
        self.common.clear();
        self.action = 0;
        self.content.clear();
        self.noticeType = 0;
        self.closeRoom = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoomVerifyMessage {
        static instance: RoomVerifyMessage = RoomVerifyMessage {
            common: ::protobuf::MessageField::none(),
            action: 0,
            content: ::std::string::String::new(),
            noticeType: 0,
            closeRoom: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoomVerifyMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoomVerifyMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoomVerifyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomVerifyMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rwebcast.proto\x12\x06TikTok\x1a\ndata.proto\x1a\x0benums.proto\"\xd3\
    \x02\n\x10WebcastPushFrame\x12\x14\n\x05SeqId\x18\x01\x20\x01(\x04R\x05S\
    eqId\x12\x14\n\x05LogId\x18\x02\x20\x01(\x04R\x05LogId\x12\x18\n\x07Serv\
    ice\x18\x03\x20\x01(\x04R\x07Service\x12\x16\n\x06Method\x18\x04\x20\x01\
    (\x04R\x06Method\x12?\n\x07headers\x18\x05\x20\x03(\x0b2%.TikTok.Webcast\
    PushFrame.HeadersEntryR\x07headers\x12(\n\x0fPayloadEncoding\x18\x06\x20\
    \x01(\tR\x0fPayloadEncoding\x12\x20\n\x0bPayloadType\x18\x07\x20\x01(\tR\
    \x0bPayloadType\x12\x18\n\x07Payload\x18\x08\x20\x01(\x0cR\x07Payload\
    \x1a:\n\x0cHeadersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xf8\x05\n\x0fWe\
    bcastResponse\x12;\n\x08messages\x18\x01\x20\x03(\x0b2\x1f.TikTok.Webcas\
    tResponse.MessageR\x08messages\x12\x16\n\x06cursor\x18\x02\x20\x01(\tR\
    \x06cursor\x12$\n\rfetchInterval\x18\x03\x20\x01(\x03R\rfetchInterval\
    \x12\x10\n\x03now\x18\x04\x20\x01(\x03R\x03now\x12\x20\n\x0binternalExt\
    \x18\x05\x20\x01(\tR\x0binternalExt\x12\x1c\n\tfetchType\x18\x06\x20\x01\
    (\x05R\tfetchType\x12S\n\x0erouteParamsMap\x18\x07\x20\x03(\x0b2+.TikTok\
    .WebcastResponse.RouteParamsMapEntryR\x0erouteParamsMap\x12,\n\x11heartB\
    eatDuration\x18\x08\x20\x01(\x03R\x11heartBeatDuration\x12\x1a\n\x08need\
    sAck\x18\t\x20\x01(\x08R\x08needsAck\x12\x1e\n\npushServer\x18\n\x20\x01\
    (\tR\npushServer\x12\x18\n\x07isFirst\x18\x0b\x20\x01(\x08R\x07isFirst\
    \x122\n\x14historyCommentCursor\x18\x0c\x20\x01(\tR\x14historyCommentCur\
    sor\x12$\n\rhistoryNoMore\x18\r\x20\x01(\x08R\rhistoryNoMore\x1aA\n\x13R\
    outeParamsMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xa1\x01\n\x07Messag\
    e\x12\x16\n\x06method\x18\x01\x20\x01(\tR\x06method\x12\x18\n\x07payload\
    \x18\x02\x20\x01(\x0cR\x07payload\x12\x14\n\x05msgId\x18\x03\x20\x01(\
    \x03R\x05msgId\x12\x18\n\x07msgType\x18\x04\x20\x01(\x05R\x07msgType\x12\
    \x16\n\x06offset\x18\x05\x20\x01(\x03R\x06offset\x12\x1c\n\tisHistory\
    \x18\x06\x20\x01(\x08R\tisHistory\"\xdf\x08\n\x12WebcastGiftMessage\x12&\
    \n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\x16\
    \n\x06giftId\x18\x02\x20\x01(\x03R\x06giftId\x12&\n\x0efanTicketCount\
    \x18\x03\x20\x01(\x03R\x0efanTicketCount\x12\x1e\n\ngroupCount\x18\x04\
    \x20\x01(\x05R\ngroupCount\x12\x20\n\x0brepeatCount\x18\x05\x20\x01(\x05\
    R\x0brepeatCount\x12\x1e\n\ncomboCount\x18\x06\x20\x01(\x05R\ncomboCount\
    \x12\x20\n\x04user\x18\x07\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12$\n\
    \x06toUser\x18\x08\x20\x01(\x0b2\x0c.TikTok.UserR\x06toUser\x12\x1c\n\tr\
    epeatEnd\x18\t\x20\x01(\x05R\trepeatEnd\x12\x18\n\x07groupId\x18\x0b\x20\
    \x01(\x03R\x07groupId\x12(\n\x0fincomeTaskgifts\x18\x0c\x20\x01(\x03R\
    \x0fincomeTaskgifts\x12.\n\x12roomFanTicketCount\x18\r\x20\x01(\x03R\x12\
    roomFanTicketCount\x12&\n\x04gift\x18\x0f\x20\x01(\x0b2\x12.TikTok.GiftS\
    tructR\x04gift\x12\x14\n\x05logId\x18\x10\x20\x01(\tR\x05logId\x12\x1a\n\
    \x08sendType\x18\x11\x20\x01(\x03R\x08sendType\x12\"\n\x0cmonitorExtra\
    \x18\x16\x20\x01(\tR\x0cmonitorExtra\x12\x18\n\x07colorId\x18\x18\x20\
    \x01(\x03R\x07colorId\x12\x20\n\x0bisFirstSent\x18\x19\x20\x01(\x08R\x0b\
    isFirstSent\x12\x18\n\x07orderId\x18\x1c\x20\x01(\tR\x07orderId\x128\n\
    \x0cuserIdentity\x18\x20\x20\x01(\x0b2\x14.TikTok.UserIdentityR\x0cuserI\
    dentity\x12W\n\x10userGiftReciever\x18\x17\x20\x01(\x0b2+.TikTok.Webcast\
    GiftMessage.UserGiftRecieverR\x10userGiftReciever\x1aJ\n\x10UserGiftReci\
    ever\x12\x16\n\x06userId\x18\x01\x20\x01(\x03R\x06userId\x12\x1e\n\ndevi\
    ceName\x18\n\x20\x01(\tR\ndeviceName\x1a\x82\x01\n\x0eGiftIMPriority\x12\
    &\n\x0equeueSizesList\x18\x01\x20\x03(\x03R\x0equeueSizesList\x12,\n\x11\
    selfQueuePriority\x18\x02\x20\x01(\x03R\x11selfQueuePriority\x12\x1a\n\
    \x08priority\x18\x03\x20\x01(\x03R\x08priority\x1am\n\x10PublicAreaCommo\
    n\x12+\n\tuserLabel\x18\x01\x20\x01(\x0b2\r.TikTok.ImageR\tuserLabel\x12\
    ,\n\x11userConsumeInRoom\x18\x02\x20\x01(\x03R\x11userConsumeInRoom\"\
    \xea\x01\n\x0bRoomMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.Tik\
    Tok.CommonR\x06common\x12\x18\n\x07content\x18\x02\x20\x01(\tR\x07conten\
    t\x12*\n\x10supprotLandscape\x18\x03\x20\x01(\x08R\x10supprotLandscape\
    \x12\x16\n\x06source\x18\x04\x20\x01(\x03R\x06source\x12!\n\x04icon\x18\
    \x05\x20\x01(\x0b2\r.TikTok.ImageR\x04icon\x12\x14\n\x05scene\x18\x06\
    \x20\x01(\tR\x05scene\x12\x1c\n\tisWelcome\x18\x07\x20\x01(\x08R\tisWelc\
    ome\"V\n\x12WebcastRoomMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\
    \x0e.TikTok.CommonR\x06common\x12\x18\n\x07content\x18\x02\x20\x01(\tR\
    \x07content\"\x8a\x0b\n\x15WebcastBarrageMessage\x12&\n\x06common\x18\
    \x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12@\n\x05event\x18\x02\
    \x20\x01(\x0b2*.TikTok.WebcastBarrageMessage.BarrageEventR\x05event\x12C\
    \n\x07msgType\x18\x03\x20\x01(\x0e2).TikTok.WebcastBarrageMessage.Barrag\
    eTypeR\x07msgType\x12!\n\x04icon\x18\x04\x20\x01(\x0b2\r.TikTok.ImageR\
    \x04icon\x12&\n\x07content\x18\x05\x20\x01(\x0b2\x0c.TikTok.TextR\x07con\
    tent\x12\x1a\n\x08duration\x18\x06\x20\x01(\x05R\x08duration\x12-\n\nbac\
    kground\x18\x07\x20\x01(\x0b2\r.TikTok.ImageR\nbackground\x12+\n\trightI\
    con\x18\x08\x20\x01(\x0b2\r.TikTok.ImageR\trightIcon\x12_\n\x0euserGrade\
    Param\x18d\x20\x01(\x0b27.TikTok.WebcastBarrageMessage.BarrageTypeUserGr\
    adeParamR\x0euserGradeParam\x12_\n\x0efansLevelParam\x18e\x20\x01(\x0b27\
    .TikTok.WebcastBarrageMessage.BarrageTypeFansLevelParamR\x0efansLevelPar\
    am\x12k\n\x12subscribeGiftParam\x18f\x20\x01(\x0b2;.TikTok.WebcastBarrag\
    eMessage.BarrageTypeSubscribeGiftParamR\x12subscribeGiftParam\x1a\x9f\
    \x01\n\x19BarrageTypeUserGradeParam\x12\"\n\x0ccurrentGrade\x18\x01\x20\
    \x01(\x05R\x0ccurrentGrade\x12$\n\rdisplayConfig\x18\x02\x20\x01(\x05R\r\
    displayConfig\x12\x16\n\x06userId\x18\x03\x20\x01(\tR\x06userId\x12\x20\
    \n\x04user\x18\x04\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x1a\x87\x01\n\
    \x19BarrageTypeFansLevelParam\x12\"\n\x0ccurrentGrade\x18\x01\x20\x01(\
    \x05R\x0ccurrentGrade\x12$\n\rdisplayConfig\x18\x02\x20\x01(\x05R\rdispl\
    ayConfig\x12\x20\n\x04user\x18\x04\x20\x01(\x0b2\x0c.TikTok.UserR\x04use\
    r\x1ao\n\x1dBarrageTypeSubscribeGiftParam\x12\"\n\x0cgiftSubCount\x18\
    \x01\x20\x01(\x03R\x0cgiftSubCount\x12*\n\x10showGiftSubCount\x18\x02\
    \x20\x01(\x08R\x10showGiftSubCount\x1a,\n\x0cBarrageEvent\x12\x1c\n\teve\
    ntName\x18\x01\x20\x01(\tR\teventName\"\x84\x02\n\x0bBarrageType\x12\x0b\
    \n\x07UNKNOWN\x10\0\x12\x10\n\x0cECOMORDERING\x10\x01\x12\x0e\n\nECOMBUY\
    ING\x10\x02\x12\n\n\x06NORMAL\x10\x03\x12\r\n\tSUBSCRIBE\x10\x04\x12\r\n\
    \tEVENTVIEW\x10\x05\x12\x13\n\x0fEVENTREGISTERED\x10\x06\x12\x11\n\rSUBS\
    CRIBEGIFT\x10\x07\x12\x0f\n\x0bUSERUPGRADE\x10\x08\x12!\n\x1dGRADEUSEREN\
    TRANCENOTIFICATION\x10\t\x12\x14\n\x10FANSLEVELUPGRADE\x10\n\x12\x15\n\
    \x11FANSLEVELENTRANCE\x10\x0b\x12\x13\n\x0fGAMEPARTNERSHIP\x10\x0c\"\xe9\
    \x01\n\x15WebcastCaptionMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\
    \x0e.TikTok.CommonR\x06common\x12\x1c\n\ttimeStamp\x18\x02\x20\x01(\x04R\
    \ttimeStamp\x12K\n\x0bcaptionData\x18\x04\x20\x01(\x0b2).TikTok.WebcastC\
    aptionMessage.CaptionDataR\x0bcaptionData\x1a=\n\x0bCaptionData\x12\x1a\
    \n\x08language\x18\x01\x20\x01(\tR\x08language\x12\x12\n\x04text\x18\x02\
    \x20\x01(\tR\x04text\"\xca\x07\n\x12WebcastChatMessage\x12&\n\x06common\
    \x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\x20\n\x04user\
    \x18\x02\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12\x18\n\x07content\x18\
    \x03\x20\x01(\tR\x07content\x12(\n\x0fvisibleToSender\x18\x04\x20\x01(\
    \x08R\x0fvisibleToSender\x127\n\x0fbackgroundImage\x18\x05\x20\x01(\x0b2\
    \r.TikTok.ImageR\x0fbackgroundImage\x120\n\x13fullScreenTextColor\x18\
    \x06\x20\x01(\tR\x13fullScreenTextColor\x12;\n\x11backgroundImageV2\x18\
    \x07\x20\x01(\x0b2\r.TikTok.ImageR\x11backgroundImageV2\x12+\n\tgiftImag\
    e\x18\n\x20\x01(\x0b2\r.TikTok.ImageR\tgiftImage\x12\x1c\n\tinputType\
    \x18\x0b\x20\x01(\x05R\tinputType\x12$\n\x06atUser\x18\x0c\x20\x01(\x0b2\
    \x0c.TikTok.UserR\x06atUser\x12I\n\nemotesList\x18\r\x20\x03(\x0b2).TikT\
    ok.WebcastChatMessage.EmoteWithIndexR\nemotesList\x12(\n\x0fcontentLangu\
    age\x18\x0e\x20\x01(\tR\x0fcontentLanguage\x12&\n\x0equickChatScene\x18\
    \x10\x20\x01(\x05R\x0equickChatScene\x126\n\x16communityFlaggedStatus\
    \x18\x11\x20\x01(\x05R\x16communityFlaggedStatus\x128\n\x0cUserIdentity\
    \x18\x12\x20\x01(\x0b2\x14.TikTok.UserIdentityR\x0cUserIdentity\x12h\n\
    \x14CommentQualityScores\x18\x13\x20\x03(\x0b24.TikTok.WebcastChatMessag\
    e.CommentQualityScoresEntryR\x14CommentQualityScores\x1aG\n\x19CommentQu\
    alityScoresEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aK\n\x0eEmoteWithInde\
    x\x12\x14\n\x05index\x18\x01\x20\x01(\x03R\x05index\x12#\n\x05emote\x18\
    \x02\x20\x01(\x0b2\r.TikTok.EmoteR\x05emote\"\xd2\x05\n\x15WebcastContro\
    lMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06co\
    mmon\x12-\n\x06action\x18\x02\x20\x01(\x0e2\x15.TikTok.ControlActionR\
    \x06action\x12\x12\n\x04tips\x18\x03\x20\x01(\tR\x04tips\x129\n\x05extra\
    \x18\x04\x20\x01(\x0b2#.TikTok.WebcastControlMessage.ExtraR\x05extra\x12\
    D\n\x16perceptionAudienceText\x18\x06\x20\x01(\x0b2\x0c.TikTok.TextR\x16\
    perceptionAudienceText\x127\n\npunishInfo\x18\x07\x20\x01(\x0b2\x17.TikT\
    ok.PunishEventInfoR\npunishInfo\x12*\n\tfloatText\x18\x08\x20\x01(\x0b2\
    \x0c.TikTok.TextR\tfloatText\x12\x1e\n\nfloatStyle\x18\t\x20\x01(\x05R\n\
    floatStyle\x1a\xc7\x02\n\x05Extra\x12\x1e\n\nbanInfoUrl\x18\x01\x20\x01(\
    \tR\nbanInfoUrl\x12\x1a\n\x08reasonNo\x18\x02\x20\x01(\x03R\x08reasonNo\
    \x12\"\n\x05title\x18\x03\x20\x01(\x0b2\x0c.TikTok.TextR\x05title\x126\n\
    \x0fviolationReason\x18\x04\x20\x01(\x0b2\x0c.TikTok.TextR\x0fviolationR\
    eason\x12&\n\x07content\x18\x05\x20\x01(\x0b2\x0c.TikTok.TextR\x07conten\
    t\x12.\n\x0bgotItButton\x18\x06\x20\x01(\x0b2\x0c.TikTok.TextR\x0bgotItB\
    utton\x126\n\x0fbanDetailButton\x18\x07\x20\x01(\x0b2\x0c.TikTok.TextR\
    \x0fbanDetailButton\x12\x16\n\x06source\x18\x08\x20\x01(\tR\x06source\"\
    \xfb\x01\n\x17WebcastEmoteChatMessage\x12&\n\x06common\x18\x01\x20\x01(\
    \x0b2\x0e.TikTok.CommonR\x06common\x12\x20\n\x04user\x18\x02\x20\x01(\
    \x0b2\x0c.TikTok.UserR\x04user\x12+\n\temoteList\x18\x03\x20\x03(\x0b2\r\
    .TikTok.EmoteR\temoteList\x12/\n\tmsgFilter\x18\x04\x20\x01(\x0b2\x11.Ti\
    kTok.MsgFilterR\tmsgFilter\x128\n\x0cuserIdentity\x18\x05\x20\x01(\x0b2\
    \x14.TikTok.UserIdentityR\x0cuserIdentity\"\xd0\x05\n\x16WebcastEnvelope\
    Message\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06com\
    mon\x12O\n\x0cenvelopeInfo\x18\x02\x20\x01(\x0b2+.TikTok.WebcastEnvelope\
    Message.EnvelopeInfoR\x0cenvelopeInfo\x121\n\x07display\x18\x03\x20\x01(\
    \x0e2\x17.TikTok.EnvelopeDisplayR\x07display\x1a\x89\x04\n\x0cEnvelopeIn\
    fo\x12\x1e\n\nenvelopeId\x18\x01\x20\x01(\tR\nenvelopeId\x12@\n\x0cbusin\
    essType\x18\x02\x20\x01(\x0e2\x1c.TikTok.EnvelopeBusinessTypeR\x0cbusine\
    ssType\x12\x20\n\x0benvelopeIdc\x18\x03\x20\x01(\tR\x0benvelopeIdc\x12\"\
    \n\x0csendUserName\x18\x04\x20\x01(\tR\x0csendUserName\x12\"\n\x0cdiamon\
    dCount\x18\x05\x20\x01(\x05R\x0cdiamondCount\x12\x20\n\x0bpeopleCount\
    \x18\x06\x20\x01(\x05R\x0bpeopleCount\x12\x1a\n\x08unpackAt\x18\x07\x20\
    \x01(\x05R\x08unpackAt\x12\x1e\n\nsendUserId\x18\x08\x20\x01(\tR\nsendUs\
    erId\x125\n\x0esendUserAvatar\x18\t\x20\x01(\x0b2\r.TikTok.ImageR\x0esen\
    dUserAvatar\x12\x1a\n\x08createAt\x18\n\x20\x01(\tR\x08createAt\x12\x16\
    \n\x06roomId\x18\x0b\x20\x01(\tR\x06roomId\x12L\n\x10followShowStatus\
    \x18\x0c\x20\x01(\x0e2\x20.TikTok.EnvelopeFollowShowStatusR\x10followSho\
    wStatus\x12\x16\n\x06skinId\x18\r\x20\x01(\x05R\x06skinId\"\xfe\x03\n\
    \x18WebcastGoalUpdateMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.\
    TikTok.CommonR\x06common\x12/\n\tindicator\x18\x02\x20\x01(\x0b2\x11.Tik\
    Tok.IndicatorR\tindicator\x12\x20\n\x04goal\x18\x03\x20\x01(\x0b2\x0c.Ti\
    kTok.GoalR\x04goal\x12$\n\rcontributorId\x18\x04\x20\x01(\x03R\rcontribu\
    torId\x12;\n\x11contributorAvatar\x18\x05\x20\x01(\x0b2\r.TikTok.ImageR\
    \x11contributorAvatar\x122\n\x14contributorDisplayId\x18\x06\x20\x01(\tR\
    \x14contributorDisplayId\x12(\n\x0fcontributeCount\x18\t\x20\x01(\x03R\
    \x0fcontributeCount\x12(\n\x0fcontributeScore\x18\n\x20\x01(\x03R\x0fcon\
    tributeScore\x12(\n\x0fgiftRepeatCount\x18\x0b\x20\x01(\x03R\x0fgiftRepe\
    atCount\x12*\n\x10contributorIdStr\x18\x0c\x20\x01(\tR\x10contributorIdS\
    tr\x12\x10\n\x03pin\x18\r\x20\x01(\x08R\x03pin\x12\x14\n\x05unpin\x18\
    \x0e\x20\x01(\x08R\x05unpin\"\x9a\x01\n\x16WebcastImDeleteMessage\x12&\n\
    \x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12*\n\x10\
    deleteMsgIdsList\x18\x02\x20\x03(\x03R\x10deleteMsgIdsList\x12,\n\x11del\
    eteUserIdsList\x18\x03\x20\x03(\x03R\x11deleteUserIdsList\"X\n\x1aWebcas\
    tInRoomBannerMessage\x12&\n\x06header\x18\x01\x20\x01(\x0b2\x0e.TikTok.C\
    ommonR\x06header\x12\x12\n\x04json\x18\x02\x20\x01(\tR\x04json\"\x8a\x01\
    \n\x12WebcastLikeMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikT\
    ok.CommonR\x06common\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\
    \x12\x14\n\x05total\x18\x03\x20\x01(\x05R\x05total\x12\x20\n\x04user\x18\
    \x05\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\"\xd8\x03\n\x19WebcastRoomUs\
    erSeqMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\
    \x06common\x12K\n\tranksList\x18\x02\x20\x03(\x0b2-.TikTok.WebcastRoomUs\
    erSeqMessage.ContributorR\tranksList\x12\x14\n\x05total\x18\x03\x20\x01(\
    \x03R\x05total\x12\x16\n\x06popStr\x18\x04\x20\x01(\tR\x06popStr\x12K\n\
    \tseatsList\x18\x05\x20\x03(\x0b2-.TikTok.WebcastRoomUserSeqMessage.Cont\
    ributorR\tseatsList\x12\x1e\n\npopularity\x18\x06\x20\x01(\x03R\npopular\
    ity\x12\x1c\n\ttotalUser\x18\x07\x20\x01(\x05R\ttotalUser\x12\x1c\n\tano\
    nymous\x18\x08\x20\x01(\x03R\tanonymous\x1ao\n\x0bContributor\x12\x14\n\
    \x05score\x18\x01\x20\x01(\x05R\x05score\x12\x20\n\x04user\x18\x02\x20\
    \x01(\x0b2\x0c.TikTok.UserR\x04user\x12\x12\n\x04rank\x18\x03\x20\x01(\
    \x05R\x04rank\x12\x14\n\x05delta\x18\x04\x20\x01(\x03R\x05delta\"\xa8\
    \x02\n\x14WebcastSocialMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\
    \x0e.TikTok.CommonR\x06common\x12\x20\n\x04user\x18\x02\x20\x01(\x0b2\
    \x0c.TikTok.UserR\x04user\x12\x1c\n\tshareType\x18\x03\x20\x01(\x03R\tsh\
    areType\x12\x16\n\x06action\x18\x04\x20\x01(\x03R\x06action\x12\x20\n\
    \x0bshareTarget\x18\x05\x20\x01(\tR\x0bshareTarget\x12\x20\n\x0bfollowCo\
    unt\x18\x06\x20\x01(\x05R\x0bfollowCount\x12,\n\x11shareDisplayStyle\x18\
    \x07\x20\x01(\x03R\x11shareDisplayStyle\x12\x1e\n\nshareCount\x18\x08\
    \x20\x01(\x05R\nshareCount\"\x85\x03\n\x17WebcastSubNotifyMessage\x12&\n\
    \x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\x20\n\
    \x04user\x18\x02\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12\x1a\n\x08sub\
    Month\x18\x04\x20\x01(\x03R\x08subMonth\x12;\n\rsubscribeType\x18\x05\
    \x20\x01(\x0e2\x15.TikTok.SubscribeTypeR\rsubscribeType\x12J\n\x12oldSub\
    scribeStatus\x18\x06\x20\x01(\x0e2\x1a.TikTok.OldSubscribeStatusR\x12old\
    SubscribeStatus\x12G\n\x11subscribingStatus\x18\x08\x20\x01(\x0e2\x19.Ti\
    kTok.SubscribingStatusR\x11subscribingStatus\x12\x16\n\x06isSend\x18\t\
    \x20\x01(\x08R\x06isSend\x12\x1a\n\x08isCustom\x18\n\x20\x01(\x08R\x08is\
    Custom\"\x90\x07\n\x18WebcastRankUpdateMessage\x12&\n\x06common\x18\x01\
    \x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12M\n\x0bupdatesList\x18\
    \x02\x20\x03(\x0b2+.TikTok.WebcastRankUpdateMessage.RankUpdateR\x0bupdat\
    esList\x12\x1c\n\tgroupType\x18\x03\x20\x01(\x03R\tgroupType\x12\x1a\n\
    \x08priority\x18\x05\x20\x01(\x03R\x08priority\x12H\n\x08tabsList\x18\
    \x06\x20\x03(\x0b2,.TikTok.WebcastRankUpdateMessage.RankTabInfoR\x08tabs\
    List\x120\n\x13isAnimationLoopPlay\x18\x07\x20\x01(\x08R\x13isAnimationL\
    oopPlay\x120\n\x13animationLoopForOff\x18\x08\x20\x01(\x08R\x13animation\
    LoopForOff\x1a\x8f\x01\n\x0bRankTabInfo\x12\x1a\n\x08rankType\x18\x01\
    \x20\x01(\x03R\x08rankType\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05tit\
    le\x12*\n\ttitleText\x18\x03\x20\x01(\x0b2\x0c.TikTok.TextR\ttitleText\
    \x12\"\n\x0clistLynxType\x18\x04\x20\x01(\x03R\x0clistLynxType\x1a\x82\
    \x03\n\nRankUpdate\x12\x1a\n\x08rankType\x18\x01\x20\x01(\x03R\x08rankTy\
    pe\x12\x1c\n\townerRank\x18\x02\x20\x01(\x03R\townerRank\x124\n\x0edefau\
    ltContent\x18\x03\x20\x01(\x0b2\x0c.TikTok.TextR\x0edefaultContent\x124\
    \n\x15showEntranceAnimation\x18\x05\x20\x01(\x08R\x15showEntranceAnimati\
    on\x12\x1c\n\tcountdown\x18\x06\x20\x01(\x03R\tcountdown\x12.\n\x12relat\
    edTabRankType\x18\x08\x20\x01(\x03R\x12relatedTabRankType\x122\n\x14requ\
    estFirstShowType\x18\t\x20\x01(\x03R\x14requestFirstShowType\x12*\n\x10s\
    upportedVersion\x18\n\x20\x01(\x03R\x10supportedVersion\x12\x20\n\x0bown\
    eronrank\x18\x0b\x20\x01(\x08R\x0bowneronrank\"\xd1\n\n\x14WebcastMember\
    Message\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06com\
    mon\x12\x20\n\x04user\x18\x02\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12\
    \x20\n\x0bmemberCount\x18\x03\x20\x01(\x05R\x0bmemberCount\x12(\n\x08ope\
    rator\x18\x04\x20\x01(\x0b2\x0c.TikTok.UserR\x08operator\x12\"\n\x0cisSe\
    tToAdmin\x18\x05\x20\x01(\x08R\x0cisSetToAdmin\x12\x1c\n\tisTopUser\x18\
    \x06\x20\x01(\x08R\tisTopUser\x12\x1c\n\trankScore\x18\x07\x20\x01(\x03R\
    \trankScore\x12\x1c\n\ttopUserNo\x18\x08\x20\x01(\x03R\ttopUserNo\x12\
    \x1c\n\tenterType\x18\t\x20\x01(\x03R\tenterType\x123\n\x06action\x18\n\
    \x20\x01(\x0e2\x1b.TikTok.MemberMessageActionR\x06action\x12,\n\x11actio\
    nDescription\x18\x0b\x20\x01(\tR\x11actionDescription\x12\x16\n\x06userI\
    d\x18\x0c\x20\x01(\x03R\x06userId\x12M\n\x0ceffectConfig\x18\r\x20\x01(\
    \x0b2).TikTok.WebcastMemberMessage.EffectConfigR\x0ceffectConfig\x12\x16\
    \n\x06popStr\x18\x0e\x20\x01(\tR\x06popStr\x12W\n\x11enterEffectConfig\
    \x18\x0f\x20\x01(\x0b2).TikTok.WebcastMemberMessage.EffectConfigR\x11ent\
    erEffectConfig\x127\n\x0fbackgroundImage\x18\x10\x20\x01(\x0b2\r.TikTok.\
    ImageR\x0fbackgroundImage\x12;\n\x11backgroundImageV2\x18\x11\x20\x01(\
    \x0b2\r.TikTok.ImageR\x11backgroundImageV2\x12:\n\x11anchorDisplayText\
    \x18\x12\x20\x01(\x0b2\x0c.TikTok.TextR\x11anchorDisplayText\x12,\n\x11c\
    lientEnterSource\x18\x13\x20\x01(\tR\x11clientEnterSource\x12(\n\x0fclie\
    ntEnterType\x18\x14\x20\x01(\tR\x0fclientEnterType\x12*\n\x10clientLiveR\
    eason\x18\x15\x20\x01(\tR\x10clientLiveReason\x12&\n\x0eactionDuration\
    \x18\x16\x20\x01(\x03R\x0eactionDuration\x12$\n\ruserShareType\x18\x17\
    \x20\x01(\tR\ruserShareType\x1a\xc7\x02\n\x0cEffectConfig\x12\x12\n\x04t\
    ype\x18\x01\x20\x01(\x03R\x04type\x12!\n\x04icon\x18\x02\x20\x01(\x0b2\r\
    .TikTok.ImageR\x04icon\x12\x1c\n\tavatarPos\x18\x03\x20\x01(\x03R\tavata\
    rPos\x12\x20\n\x04text\x18\x04\x20\x01(\x0b2\x0c.TikTok.TextR\x04text\
    \x12)\n\x08textIcon\x18\x05\x20\x01(\x0b2\r.TikTok.ImageR\x08textIcon\
    \x12\x1a\n\x08stayTime\x18\x06\x20\x01(\x05R\x08stayTime\x12\x20\n\x0ban\
    imAssetId\x18\x07\x20\x01(\x03R\x0banimAssetId\x12#\n\x05badge\x18\x08\
    \x20\x01(\x0b2\r.TikTok.ImageR\x05badge\x122\n\x14flexSettingArrayList\
    \x18\t\x20\x03(\x03R\x14flexSettingArrayList\"\xe3\x02\n\x12WebcastPollM\
    essage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06comm\
    on\x125\n\x0bmessageType\x18\x02\x20\x01(\x0e2\x13.TikTok.MessageTypeR\
    \x0bmessageType\x12\x16\n\x06pollId\x18\x03\x20\x01(\x03R\x06pollId\x12<\
    \n\x0cstartContent\x18\x04\x20\x01(\x0b2\x18.TikTok.PollStartContentR\
    \x0cstartContent\x126\n\nendContent\x18\x05\x20\x01(\x0b2\x16.TikTok.Pol\
    lEndContentR\nendContent\x12D\n\rupdateContent\x18\x06\x20\x01(\x0b2\x1e\
    .TikTok.PollUpdateVotesContentR\rupdateContent\x12\x1a\n\x08pollKind\x18\
    \x07\x20\x01(\x05R\x08pollKind\"\x9e\x02\n\x19WebcastQuestionNewMessage\
    \x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\
    K\n\x07details\x18\x02\x20\x01(\x0b21.TikTok.WebcastQuestionNewMessage.Q\
    uestionDetailsR\x07details\x1a\x8b\x01\n\x0fQuestionDetails\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x04R\x02id\x12\x12\n\x04text\x18\x02\x20\x01(\tR\
    \x04text\x12\x1c\n\ttimeStamp\x18\x04\x20\x01(\x04R\ttimeStamp\x12\x20\n\
    \x04user\x18\x05\x20\x01(\x0b2\x0c.TikTok.UserR\x04user\x12\x14\n\x05dat\
    a1\x18\x14\x20\x01(\rR\x05data1\"\xcc\x02\n\x16WebcastRankTextMessage\
    \x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\
    \x14\n\x05scene\x18\x02\x20\x01(\x05R\x05scene\x122\n\x14ownerIdxBeforeU\
    pdate\x18\x03\x20\x01(\x03R\x14ownerIdxBeforeUpdate\x120\n\x13ownerIdxAf\
    terUpdate\x18\x04\x20\x01(\x03R\x13ownerIdxAfterUpdate\x126\n\x0fselfGet\
    BadgeMsg\x18\x05\x20\x01(\x0b2\x0c.TikTok.TextR\x0fselfGetBadgeMsg\x128\
    \n\x10otherGetBadgeMsg\x18\x06\x20\x01(\x0b2\x0c.TikTok.TextR\x10otherGe\
    tBadgeMsg\x12\x1c\n\tcurUserId\x18\x07\x20\x01(\x03R\tcurUserId\"\x86\
    \x06\n\x18WebcastHourlyRankMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b\
    2\x0e.TikTok.CommonR\x06common\x12B\n\x04data\x18\x02\x20\x01(\x0b2..Tik\
    Tok.WebcastHourlyRankMessage.RankContainerR\x04data\x12\x14\n\x05data2\
    \x18\x03\x20\x01(\rR\x05data2\x1a\xe7\x04\n\rRankContainer\x12\x14\n\x05\
    data1\x18\x01\x20\x01(\rR\x05data1\x12\\\n\x0brankingdata\x18\x02\x20\
    \x01(\x0b2:.TikTok.WebcastHourlyRankMessage.RankContainer.RankingDataR\
    \x0brankingdata\x12\x14\n\x05data2\x18\x03\x20\x01(\rR\x05data2\x12+\n\
    \x08rankings\x18\x04\x20\x01(\x0b2\x0f.TikTok.RankingR\x08rankings\x12_\
    \n\x0crankingdata2\x18\x05\x20\x01(\x0b2;.TikTok.WebcastHourlyRankMessag\
    e.RankContainer.RankingData2R\x0crankingdata2\x12\x14\n\x05data3\x18\x06\
    \x20\x01(\rR\x05data3\x12\x14\n\x05data4\x18\x07\x20\x01(\rR\x05data4\
    \x1af\n\x0bRankingData\x12\x14\n\x05data1\x18\x01\x20\x01(\rR\x05data1\
    \x12+\n\x08rankdata\x18\x02\x20\x01(\x0b2\x0f.TikTok.RankingR\x08rankdat\
    a\x12\x14\n\x05data2\x18\x03\x20\x01(\tR\x05data2\x1a\xa9\x01\n\x0cRanki\
    ngData2\x12\x14\n\x05data1\x18\x01\x20\x01(\rR\x05data1\x12\x14\n\x05dat\
    a2\x18\x02\x20\x01(\rR\x05data2\x12+\n\x08rankdata\x18\x03\x20\x01(\x0b2\
    \x0f.TikTok.RankingR\x08rankdata\x12\x14\n\x05data3\x18\x04\x20\x01(\tR\
    \x05data3\x12\x14\n\x05data4\x18\x05\x20\x01(\rR\x05data4\x12\x14\n\x05d\
    ata5\x18\x06\x20\x01(\rR\x05data5\"\x95\x03\n\x14WebcastLinkMicArmies\
    \x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\x04R\x02id\x12<\n\x0bbattleItems\x18\x03\
    \x20\x03(\x0b2\x1a.TikTok.LinkMicArmiesItemsR\x0bbattleItems\x12\x10\n\
    \x03id2\x18\x04\x20\x01(\x04R\x03id2\x12\x1e\n\ntimeStamp1\x18\x05\x20\
    \x01(\x04R\ntimeStamp1\x12\x1e\n\ntimeStamp2\x18\x06\x20\x01(\x04R\ntime\
    Stamp2\x12\"\n\x0cbattleStatus\x18\x07\x20\x01(\x05R\x0cbattleStatus\x12\
    \x14\n\x05data1\x18\x08\x20\x01(\x04R\x05data1\x12\x14\n\x05data2\x18\t\
    \x20\x01(\x04R\x05data2\x12\x14\n\x05data3\x18\n\x20\x01(\rR\x05data3\
    \x12#\n\x05Image\x18\x0b\x20\x01(\x0b2\r.TikTok.ImageR\x05Image\x12\x14\
    \n\x05data4\x18\x0c\x20\x01(\rR\x05data4\x12\x14\n\x05data5\x18\r\x20\
    \x01(\rR\x05data5\"\xbc\x03\n\x20WebcastLinkMicBattlePunishFinish\x12&\n\
    \x06Header\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06Header\x12\x10\n\
    \x03Id1\x18\x02\x20\x01(\x04R\x03Id1\x12\x1c\n\tTimestamp\x18\x03\x20\
    \x01(\x04R\tTimestamp\x12\x14\n\x05Data4\x18\x04\x20\x01(\rR\x05Data4\
    \x12\x10\n\x03Id2\x18\x05\x20\x01(\x04R\x03Id2\x12\\\n\x05Data6\x18\x06\
    \x20\x01(\x0b2F.TikTok.WebcastLinkMicBattlePunishFinish.LinkMicBattlePun\
    ishFinishDataR\x05Data6\x1a\xb9\x01\n\x1dLinkMicBattlePunishFinishData\
    \x12\x10\n\x03Id2\x18\x01\x20\x01(\x04R\x03Id2\x12\x1c\n\tTimestamp\x18\
    \x02\x20\x01(\x04R\tTimestamp\x12\x14\n\x05Data3\x18\x03\x20\x01(\rR\x05\
    Data3\x12\x10\n\x03Id1\x18\x04\x20\x01(\x04R\x03Id1\x12\x14\n\x05Data5\
    \x18\x05\x20\x01(\rR\x05Data5\x12\x14\n\x05Data6\x18\x06\x20\x01(\rR\x05\
    Data6\x12\x14\n\x05Data8\x18\x08\x20\x01(\rR\x05Data8\"\xdf\x03\n\x1fWeb\
    castLinkmicBattleTaskMessage\x12&\n\x06Header\x18\x01\x20\x01(\x0b2\x0e.\
    TikTok.CommonR\x06Header\x12\x14\n\x05Data2\x18\x02\x20\x01(\rR\x05Data2\
    \x12S\n\x05Data3\x18\x03\x20\x01(\x0b2=.TikTok.WebcastLinkmicBattleTaskM\
    essage.LinkmicBattleTaskDataR\x05Data3\x12T\n\x05Data5\x18\x05\x20\x01(\
    \x0b2>.TikTok.WebcastLinkmicBattleTaskMessage.LinkmicBattleTaskData2R\
    \x05Data5\x1ae\n\x15LinkmicBattleTaskData\x12L\n\x05Data1\x18\x01\x20\
    \x01(\x0b26.TikTok.WebcastLinkmicBattleTaskMessage.BattleTaskDataR\x05Da\
    ta1\x1a&\n\x0eBattleTaskData\x12\x14\n\x05Data1\x18\x01\x20\x01(\rR\x05D\
    ata1\x1aD\n\x16LinkmicBattleTaskData2\x12\x14\n\x05Data1\x18\x01\x20\x01\
    (\rR\x05Data1\x12\x14\n\x05Data2\x18\x02\x20\x01(\rR\x05Data2\"\x96\x08\
    \n\x14WebcastLinkMicBattle\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.Ti\
    kTok.CommonR\x06common\x12\x0e\n\x02id\x18\x02\x20\x01(\x04R\x02id\x12T\
    \n\x0cbattleConfig\x18\x03\x20\x01(\x0b20.TikTok.WebcastLinkMicBattle.Li\
    nkMicBattleConfigR\x0cbattleConfig\x12\x14\n\x05data2\x18\x04\x20\x01(\r\
    R\x05data2\x12K\n\x07details\x18\x05\x20\x03(\x0b21.TikTok.WebcastLinkMi\
    cBattle.LinkMicBattleDetailsR\x07details\x12F\n\x06teams1\x18\t\x20\x03(\
    \x0b2..TikTok.WebcastLinkMicBattle.LinkMicBattleTeamR\x06teams1\x12F\n\
    \x06teams2\x18\n\x20\x03(\x0b2..TikTok.WebcastLinkMicBattle.LinkMicBattl\
    eTeamR\x06teams2\x12N\n\x08teamData\x18\r\x20\x03(\x0b22.TikTok.WebcastL\
    inkMicBattle.LinkMicBattleTeamDataR\x08teamData\x1a\x83\x01\n\x13LinkMic\
    BattleConfig\x12\x10\n\x03id1\x18\x01\x20\x01(\x04R\x03id1\x12\x1c\n\tti\
    mestamp\x18\x02\x20\x01(\x04R\ttimestamp\x12\x14\n\x05data1\x18\x03\x20\
    \x01(\rR\x05data1\x12\x10\n\x03id2\x18\x04\x20\x01(\x04R\x03id2\x12\x14\
    \n\x05data2\x18\x05\x20\x01(\rR\x05data2\x1aw\n\x11LinkMicBattleData\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\x14\n\x05data1\x18\x02\x20\
    \x01(\rR\x05data1\x12\x14\n\x05data2\x18\x03\x20\x01(\rR\x05data2\x12\
    \x14\n\x05data3\x18\x05\x20\x01(\rR\x05data3\x12\x10\n\x03url\x18\x06\
    \x20\x01(\tR\x03url\x1ap\n\x14LinkMicBattleDetails\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x04R\x02id\x12H\n\x07details\x18\x02\x20\x01(\x0b2..TikTok\
    .WebcastLinkMicBattle.LinkMicBattleDataR\x07details\x1aG\n\x11LinkMicBat\
    tleTeam\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\"\n\x05users\x18\
    \x02\x20\x03(\x0b2\x0c.TikTok.UserR\x05users\x1as\n\x15LinkMicBattleTeam\
    Data\x12\x16\n\x06teamId\x18\x01\x20\x01(\x04R\x06teamId\x12B\n\x04data\
    \x18\x02\x20\x01(\x0b2..TikTok.WebcastLinkMicBattle.LinkMicBattleDataR\
    \x04data\"\x9d\x01\n\x1dWebcastLinkMicFanTicketMethod\x12&\n\x06common\
    \x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12T\n\x13FanTicketR\
    oomNotice\x18\x02\x20\x01(\x0b2\".TikTok.FanTicketRoomNoticeContentR\x13\
    FanTicketRoomNotice\"\xc9\x03\n\x14WebcastLinkMicMethod\x12&\n\x06common\
    \x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x125\n\x0bmessageTyp\
    e\x18\x02\x20\x01(\x0e2\x13.TikTok.MessageTypeR\x0bmessageType\x12\x1c\n\
    \taccessKey\x18\x03\x20\x01(\tR\taccessKey\x12(\n\x0fanchorLinkmicId\x18\
    \x04\x20\x01(\x03R\x0fanchorLinkmicId\x12\x16\n\x06userId\x18\x05\x20\
    \x01(\x03R\x06userId\x12\x1c\n\tfanTicket\x18\x06\x20\x01(\x03R\tfanTick\
    et\x124\n\x15totalLinkMicFanTicket\x18\x07\x20\x01(\x03R\x15totalLinkMic\
    FanTicket\x12\x1c\n\tchannelId\x18\x08\x20\x01(\x03R\tchannelId\x12\x16\
    \n\x06layout\x18\t\x20\x01(\x03R\x06layout\x12\x16\n\x06vendor\x18\n\x20\
    \x01(\x03R\x06vendor\x12\x1c\n\tdimension\x18\x0b\x20\x01(\x03R\tdimensi\
    on\x12\x14\n\x05theme\x18\x0c\x20\x01(\tR\x05theme\x12\x1c\n\tinviteUid\
    \x18\r\x20\x01(\x03R\tinviteUid\"\xb3\x02\n\x17WebcastLiveIntroMessage\
    \x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\
    \x16\n\x06roomId\x18\x02\x20\x01(\x03R\x06roomId\x125\n\x0bauditStatus\
    \x18\x03\x20\x01(\x0e2\x13.TikTok.AuditStatusR\x0bauditStatus\x12\x18\n\
    \x07content\x18\x04\x20\x01(\tR\x07content\x12\x20\n\x04host\x18\x05\x20\
    \x01(\x0b2\x0c.TikTok.UserR\x04host\x12\x1c\n\tintroMode\x18\x06\x20\x01\
    (\x05R\tintroMode\x12+\n\x06badges\x18\x07\x20\x03(\x0b2\x13.TikTok.Badg\
    eStructR\x06badges\x12\x1a\n\x08language\x18\x08\x20\x01(\tR\x08language\
    \"\xe0\x01\n\x20WebcastUnauthorizedMemberMessage\x12&\n\x06common\x18\
    \x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\x16\n\x06action\x18\
    \x02\x20\x01(\x05R\x06action\x124\n\x0enickNamePrefix\x18\x03\x20\x01(\
    \x0b2\x0c.TikTok.TextR\x0enickNamePrefix\x12\x1a\n\x08nickName\x18\x04\
    \x20\x01(\tR\x08nickName\x12*\n\tenterText\x18\x05\x20\x01(\x0b2\x0c.Tik\
    Tok.TextR\tenterText\"\xab\x05\n\x17WebcastMsgDetectMessage\x12&\n\x06co\
    mmon\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\x1e\n\ndetec\
    tType\x18\x02\x20\x01(\x05R\ndetectType\x12\\\n\x10triggerCondition\x18\
    \x03\x20\x01(\x0b20.TikTok.WebcastMsgDetectMessage.TriggerConditionR\x10\
    triggerCondition\x12D\n\x08timeInfo\x18\x04\x20\x01(\x0b2(.TikTok.Webcas\
    tMsgDetectMessage.TimeInfoR\x08timeInfo\x12\x1c\n\ttriggerBy\x18\x05\x20\
    \x01(\x05R\ttriggerBy\x12\x1e\n\nfromRegion\x18\x06\x20\x01(\tR\nfromReg\
    ion\x1a\x80\x01\n\x08TimeInfo\x12$\n\rclientStartMs\x18\x01\x20\x01(\x03\
    R\rclientStartMs\x12$\n\rapiRecvTimeMs\x18\x02\x20\x01(\x03R\rapiRecvTim\
    eMs\x12(\n\x0fapiSendToGoimMs\x18\x03\x20\x01(\x03R\x0fapiSendToGoimMs\
    \x1a\xe2\x01\n\x10TriggerCondition\x12*\n\x10uplinkDetectHttp\x18\x01\
    \x20\x01(\x08R\x10uplinkDetectHttp\x124\n\x15uplinkDetectWebSocket\x18\
    \x02\x20\x01(\x08R\x15uplinkDetectWebSocket\x12\"\n\x0cdetectP2PMsg\x18\
    \x03\x20\x01(\x08R\x0cdetectP2PMsg\x12$\n\rdetectRoomMsg\x18\x04\x20\x01\
    (\x08R\rdetectRoomMsg\x12\"\n\x0chttpOptimize\x18\x05\x20\x01(\x08R\x0ch\
    ttpOptimize\"\xf3\x05\n\x1dWebcastOecLiveShoppingMessage\x12&\n\x06commo\
    n\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x12\x14\n\x05data1\
    \x18\x02\x20\x01(\rR\x05data1\x12R\n\x08shopData\x18\x04\x20\x01(\x0b26.\
    TikTok.WebcastOecLiveShoppingMessage.LiveShoppingDataR\x08shopData\x12<\
    \n\x0bshopTimings\x18\x05\x20\x01(\x0b2\x1a.TikTok.TimeStampContainerR\
    \x0bshopTimings\x12S\n\x07details\x18\t\x20\x01(\x0b29.TikTok.WebcastOec\
    LiveShoppingMessage.LiveShoppingDetailsR\x07details\x1a\x90\x02\n\x10Liv\
    eShoppingData\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x20\n\
    \x0bpriceString\x18\x02\x20\x01(\tR\x0bpriceString\x12\x1a\n\x08imageUrl\
    \x18\x03\x20\x01(\tR\x08imageUrl\x12\x18\n\x07shopUrl\x18\x04\x20\x01(\t\
    R\x07shopUrl\x12\x14\n\x05data1\x18\x06\x20\x01(\x04R\x05data1\x12\x1a\n\
    \x08shopName\x18\x07\x20\x01(\tR\x08shopName\x12\x14\n\x05data2\x18\x08\
    \x20\x01(\x04R\x05data2\x12\x1a\n\x08shopUrl2\x18\t\x20\x01(\tR\x08shopU\
    rl2\x12\x14\n\x05data3\x18\n\x20\x01(\x04R\x05data3\x12\x14\n\x05data4\
    \x18\x0b\x20\x01(\x04R\x05data4\x1a\x99\x01\n\x13LiveShoppingDetails\x12\
    \x10\n\x03id1\x18\x01\x20\x01(\tR\x03id1\x12\x14\n\x05data1\x18\x03\x20\
    \x01(\tR\x05data1\x12\x14\n\x05data2\x18\x04\x20\x01(\rR\x05data2\x12\
    \x1c\n\ttimestamp\x18\x05\x20\x01(\x04R\ttimestamp\x12&\n\x04data\x18\
    \x06\x20\x01(\x0b2\x12.TikTok.ValueLabelR\x04data\"\xad\x01\n\x15Webcast\
    RoomPinMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\
    \x06common\x12$\n\rpinnedMessage\x18\x02\x20\x01(\x0cR\rpinnedMessage\
    \x12(\n\x0foriginalMsgType\x18\x1e\x20\x01(\tR\x0foriginalMsgType\x12\
    \x1c\n\ttimestamp\x18\x1f\x20\x01(\x04R\ttimestamp\"X\n\x14WebcastSystem\
    Message\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06com\
    mon\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\x83\x0f\n\x12W\
    ebcastLinkMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b2\x0e.TikTok.Comm\
    onR\x06common\x129\n\x0bMessageType\x18\x02\x20\x01(\x0e2\x17.TikTok.Lin\
    kMessageTypeR\x0bMessageType\x12\x1a\n\x08LinkerId\x18\x03\x20\x01(\x03R\
    \x08LinkerId\x12#\n\x05Scene\x18\x04\x20\x01(\x0e2\r.TikTok.SceneR\x05Sc\
    ene\x12A\n\rInviteContent\x18\x05\x20\x01(\x0b2\x1b.TikTok.LinkerInviteC\
    ontentR\rInviteContent\x12>\n\x0cReplyContent\x18\x06\x20\x01(\x0b2\x1a.\
    TikTok.LinkerReplyContentR\x0cReplyContent\x12A\n\rCreateContent\x18\x07\
    \x20\x01(\x0b2\x1b.TikTok.LinkerCreateContentR\rCreateContent\x12>\n\x0c\
    CloseContent\x18\x08\x20\x01(\x0b2\x1a.TikTok.LinkerCloseContentR\x0cClo\
    seContent\x12>\n\x0cEnterContent\x18\t\x20\x01(\x0b2\x1a.TikTok.LinkerEn\
    terContentR\x0cEnterContent\x12>\n\x0cLeaveContent\x18\n\x20\x01(\x0b2\
    \x1a.TikTok.LinkerLeaveContentR\x0cLeaveContent\x12A\n\rCancelContent\
    \x18\x0b\x20\x01(\x0b2\x1b.TikTok.LinkerCancelContentR\rCancelContent\
    \x12D\n\x0eKickOutContent\x18\x0c\x20\x01(\x0b2\x1c.TikTok.LinkerKickOut\
    ContentR\x0eKickOutContent\x12_\n\x17LinkedListChangeContent\x18\r\x20\
    \x01(\x0b2%.TikTok.LinkerLinkedListChangeContentR\x17LinkedListChangeCon\
    tent\x12M\n\x11UpdateUserContent\x18\x0e\x20\x01(\x0b2\x1f.TikTok.Linker\
    UpdateUserContentR\x11UpdateUserContent\x12b\n\x18WaitingListChangeConte\
    nt\x18\x0f\x20\x01(\x0b2&.TikTok.LinkerWaitingListChangeContentR\x18Wait\
    ingListChangeContent\x12;\n\x0bMuteContent\x18\x10\x20\x01(\x0b2\x19.Tik\
    Tok.LinkerMuteContentR\x0bMuteContent\x12P\n\x12RandomMatchContent\x18\
    \x11\x20\x01(\x0b2\x20.TikTok.LinkerRandomMatchContentR\x12RandomMatchCo\
    ntent\x12b\n\x18UpdateUserSettingContent\x18\x12\x20\x01(\x0b2&.TikTok.L\
    inkerUpdateUserSettingContentR\x18UpdateUserSettingContent\x12S\n\x13Mic\
    IdxUpdateContent\x18\x13\x20\x01(\x0b2!.TikTok.LinkerMicIdxUpdateContent\
    R\x13MicIdxUpdateContent\x12M\n\x11ListChangeContent\x18\x14\x20\x01(\
    \x0b2\x1f.TikTok.LinkerListChangeContentR\x11ListChangeContent\x12Y\n\
    \x17CohostListChangeContent\x18\x15\x20\x01(\x0b2\x1f.TikTok.CohostListC\
    hangeContentR\x17CohostListChangeContent\x12P\n\x12MediaChangeContent\
    \x18\x16\x20\x01(\x0b2\x20.TikTok.LinkerMediaChangeContentR\x12MediaChan\
    geContent\x12]\n\x18ReplyAcceptNoticeContent\x18\x17\x20\x01(\x0b2!.TikT\
    ok.LinkerAcceptNoticeContentR\x18ReplyAcceptNoticeContent\x12M\n\x11SysK\
    ickOutContent\x18e\x20\x01(\x0b2\x1f.TikTok.LinkerSysKickOutContentR\x11\
    SysKickOutContent\x12K\n\x10UserToastContent\x18f\x20\x01(\x0b2\x1f.TikT\
    ok.LinkmicUserToastContentR\x10UserToastContent\x12\x15\n\x05extra\x18\
    \xc8\x01\x20\x01(\tR\x05extra\x12)\n\x0fexpireTimestamp\x18\xc9\x01\x20\
    \x01(\x03R\x0fexpireTimestamp\x12%\n\rtransferExtra\x18\xca\x01\x20\x01(\
    \tR\rtransferExtra\"\xd3\x0b\n\x17WebcastLinkLayerMessage\x12&\n\x06comm\
    on\x18\x01\x20\x01(\x0b2\x0e.TikTok.CommonR\x06common\x125\n\x0bmessageT\
    ype\x18\x02\x20\x01(\x0e2\x13.TikTok.MessageTypeR\x0bmessageType\x12\x1c\
    \n\tchannelId\x18\x03\x20\x01(\x03R\tchannelId\x12#\n\x05scene\x18\x04\
    \x20\x01(\x0e2\r.TikTok.SceneR\x05scene\x12P\n\x14createChannelContent\
    \x18d\x20\x01(\x0b2\x1c.TikTok.CreateChannelContentR\x14createChannelCon\
    tent\x12G\n\x11listChangeContent\x18f\x20\x01(\x0b2\x19.TikTok.ListChang\
    eContentR\x11listChangeContent\x12;\n\rinviteContent\x18g\x20\x01(\x0b2\
    \x15.TikTok.InviteContentR\rinviteContent\x128\n\x0capplyContent\x18h\
    \x20\x01(\x0b2\x14.TikTok.ApplyContentR\x0capplyContent\x12J\n\x12permit\
    ApplyContent\x18i\x20\x01(\x0b2\x1a.TikTok.PermitApplyContentR\x12permit\
    ApplyContent\x12J\n\x12replyInviteContent\x18j\x20\x01(\x0b2\x1a.TikTok.\
    ReplyInviteContentR\x12replyInviteContent\x12>\n\x0ekickOutContent\x18k\
    \x20\x01(\x0b2\x16.TikTok.KickOutContentR\x0ekickOutContent\x12J\n\x12ca\
    ncelApplyContent\x18l\x20\x01(\x0b2\x1a.TikTok.CancelApplyContentR\x12ca\
    ncelApplyContent\x12M\n\x13cancelInviteContent\x18m\x20\x01(\x0b2\x1b.Ti\
    kTok.CancelInviteContentR\x13cancelInviteContent\x128\n\x0cleaveContent\
    \x18n\x20\x01(\x0b2\x14.TikTok.LeaveContentR\x0cleaveContent\x12B\n\rfin\
    ishContent\x18o\x20\x01(\x0b2\x1c.TikTok.FinishChannelContentR\rfinishCo\
    ntent\x12G\n\x11joinDirectContent\x18p\x20\x01(\x0b2\x19.TikTok.JoinDire\
    ctContentR\x11joinDirectContent\x12D\n\x10joinGroupContent\x18q\x20\x01(\
    \x0b2\x18.TikTok.JoinGroupContentR\x10joinGroupContent\x12N\n\x12permitG\
    roupContent\x18r\x20\x01(\x0b2\x1e.TikTok.PermitJoinGroupContentR\x12per\
    mitGroupContent\x12N\n\x12cancelGroupContent\x18s\x20\x01(\x0b2\x1e.TikT\
    ok.CancelJoinGroupContentR\x12cancelGroupContent\x12K\n\x11leaveGroupCon\
    tent\x18t\x20\x01(\x0b2\x1d.TikTok.LeaveJoinGroupContentR\x11leaveGroupC\
    ontent\x12S\n\x15p2pGroupChangeContent\x18u\x20\x01(\x0b2\x1d.TikTok.P2P\
    GroupChangeContentR\x15p2pGroupChangeContent\x12B\n\x0fbusinessContent\
    \x18\xc8\x01\x20\x01(\x0b2\x17.TikTok.BusinessContentR\x0fbusinessConten\
    t\"\xab\x01\n\x11RoomVerifyMessage\x12&\n\x06common\x18\x01\x20\x01(\x0b\
    2\x0e.TikTok.CommonR\x06common\x12\x16\n\x06action\x18\x02\x20\x01(\x05R\
    \x06action\x12\x18\n\x07content\x18\x03\x20\x01(\tR\x07content\x12\x1e\n\
    \nnoticeType\x18\x04\x20\x01(\x03R\nnoticeType\x12\x1c\n\tcloseRoom\x18\
    \x05\x20\x01(\x08R\tcloseRoomB1\n-io.github.jwdeveloper.tiktok.messages.\
    webcastP\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::data::file_descriptor().clone());
            deps.push(super::enums::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(72);
            messages.push(WebcastPushFrame::generated_message_descriptor_data());
            messages.push(WebcastResponse::generated_message_descriptor_data());
            messages.push(WebcastGiftMessage::generated_message_descriptor_data());
            messages.push(RoomMessage::generated_message_descriptor_data());
            messages.push(WebcastRoomMessage::generated_message_descriptor_data());
            messages.push(WebcastBarrageMessage::generated_message_descriptor_data());
            messages.push(WebcastCaptionMessage::generated_message_descriptor_data());
            messages.push(WebcastChatMessage::generated_message_descriptor_data());
            messages.push(WebcastControlMessage::generated_message_descriptor_data());
            messages.push(WebcastEmoteChatMessage::generated_message_descriptor_data());
            messages.push(WebcastEnvelopeMessage::generated_message_descriptor_data());
            messages.push(WebcastGoalUpdateMessage::generated_message_descriptor_data());
            messages.push(WebcastImDeleteMessage::generated_message_descriptor_data());
            messages.push(WebcastInRoomBannerMessage::generated_message_descriptor_data());
            messages.push(WebcastLikeMessage::generated_message_descriptor_data());
            messages.push(WebcastRoomUserSeqMessage::generated_message_descriptor_data());
            messages.push(WebcastSocialMessage::generated_message_descriptor_data());
            messages.push(WebcastSubNotifyMessage::generated_message_descriptor_data());
            messages.push(WebcastRankUpdateMessage::generated_message_descriptor_data());
            messages.push(WebcastMemberMessage::generated_message_descriptor_data());
            messages.push(WebcastPollMessage::generated_message_descriptor_data());
            messages.push(WebcastQuestionNewMessage::generated_message_descriptor_data());
            messages.push(WebcastRankTextMessage::generated_message_descriptor_data());
            messages.push(WebcastHourlyRankMessage::generated_message_descriptor_data());
            messages.push(WebcastLinkMicArmies::generated_message_descriptor_data());
            messages.push(WebcastLinkMicBattlePunishFinish::generated_message_descriptor_data());
            messages.push(WebcastLinkmicBattleTaskMessage::generated_message_descriptor_data());
            messages.push(WebcastLinkMicBattle::generated_message_descriptor_data());
            messages.push(WebcastLinkMicFanTicketMethod::generated_message_descriptor_data());
            messages.push(WebcastLinkMicMethod::generated_message_descriptor_data());
            messages.push(WebcastLiveIntroMessage::generated_message_descriptor_data());
            messages.push(WebcastUnauthorizedMemberMessage::generated_message_descriptor_data());
            messages.push(WebcastMsgDetectMessage::generated_message_descriptor_data());
            messages.push(WebcastOecLiveShoppingMessage::generated_message_descriptor_data());
            messages.push(WebcastRoomPinMessage::generated_message_descriptor_data());
            messages.push(WebcastSystemMessage::generated_message_descriptor_data());
            messages.push(WebcastLinkMessage::generated_message_descriptor_data());
            messages.push(WebcastLinkLayerMessage::generated_message_descriptor_data());
            messages.push(RoomVerifyMessage::generated_message_descriptor_data());
            messages.push(webcast_response::Message::generated_message_descriptor_data());
            messages.push(webcast_gift_message::UserGiftReciever::generated_message_descriptor_data());
            messages.push(webcast_gift_message::GiftIMPriority::generated_message_descriptor_data());
            messages.push(webcast_gift_message::PublicAreaCommon::generated_message_descriptor_data());
            messages.push(webcast_barrage_message::BarrageTypeUserGradeParam::generated_message_descriptor_data());
            messages.push(webcast_barrage_message::BarrageTypeFansLevelParam::generated_message_descriptor_data());
            messages.push(webcast_barrage_message::BarrageTypeSubscribeGiftParam::generated_message_descriptor_data());
            messages.push(webcast_barrage_message::BarrageEvent::generated_message_descriptor_data());
            messages.push(webcast_caption_message::CaptionData::generated_message_descriptor_data());
            messages.push(webcast_chat_message::EmoteWithIndex::generated_message_descriptor_data());
            messages.push(webcast_control_message::Extra::generated_message_descriptor_data());
            messages.push(webcast_envelope_message::EnvelopeInfo::generated_message_descriptor_data());
            messages.push(webcast_room_user_seq_message::Contributor::generated_message_descriptor_data());
            messages.push(webcast_rank_update_message::RankTabInfo::generated_message_descriptor_data());
            messages.push(webcast_rank_update_message::RankUpdate::generated_message_descriptor_data());
            messages.push(webcast_member_message::EffectConfig::generated_message_descriptor_data());
            messages.push(webcast_question_new_message::QuestionDetails::generated_message_descriptor_data());
            messages.push(webcast_hourly_rank_message::RankContainer::generated_message_descriptor_data());
            messages.push(webcast_hourly_rank_message::rank_container::RankingData::generated_message_descriptor_data());
            messages.push(webcast_hourly_rank_message::rank_container::RankingData2::generated_message_descriptor_data());
            messages.push(webcast_link_mic_battle_punish_finish::LinkMicBattlePunishFinishData::generated_message_descriptor_data());
            messages.push(webcast_linkmic_battle_task_message::LinkmicBattleTaskData::generated_message_descriptor_data());
            messages.push(webcast_linkmic_battle_task_message::BattleTaskData::generated_message_descriptor_data());
            messages.push(webcast_linkmic_battle_task_message::LinkmicBattleTaskData2::generated_message_descriptor_data());
            messages.push(webcast_link_mic_battle::LinkMicBattleConfig::generated_message_descriptor_data());
            messages.push(webcast_link_mic_battle::LinkMicBattleData::generated_message_descriptor_data());
            messages.push(webcast_link_mic_battle::LinkMicBattleDetails::generated_message_descriptor_data());
            messages.push(webcast_link_mic_battle::LinkMicBattleTeam::generated_message_descriptor_data());
            messages.push(webcast_link_mic_battle::LinkMicBattleTeamData::generated_message_descriptor_data());
            messages.push(webcast_msg_detect_message::TimeInfo::generated_message_descriptor_data());
            messages.push(webcast_msg_detect_message::TriggerCondition::generated_message_descriptor_data());
            messages.push(webcast_oec_live_shopping_message::LiveShoppingData::generated_message_descriptor_data());
            messages.push(webcast_oec_live_shopping_message::LiveShoppingDetails::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(webcast_barrage_message::BarrageType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}